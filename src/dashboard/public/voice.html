<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kingston Voice</title>
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#6c8cff">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Kingston">
<link rel="apple-touch-icon" href="/icon-192.png">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #0a0a0f;
    color: #e0e0e0;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 20px;
    background: #111118;
    border-bottom: 1px solid #222;
  }
  .header h1 { font-size: 18px; font-weight: 600; }
  .header h1 span { color: #6c8cff; }
  .header-right { display: flex; gap: 10px; align-items: center; }
  .status-dot {
    width: 10px; height: 10px; border-radius: 50%;
    display: inline-block; transition: background 0.3s;
  }
  .status-dot.disconnected { background: #666; }
  .status-dot.wakeword { background: #ff9800; animation: pulse 2.5s infinite; }
  .status-dot.connecting { background: #ff9800; animation: blink 1s infinite; }
  .status-dot.ready { background: #4caf50; }
  .status-dot.listening { background: #ff9800; animation: blink 0.6s infinite; }
  .status-dot.speaking { background: #6c8cff; animation: blink 1.2s infinite; }
  @keyframes blink { 50% { opacity: 0.3; } }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
  #statusLabel { font-size: 13px; color: #888; }

  .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }

  /* Webcam */
  .webcam-box {
    position: absolute; top: 10px; right: 16px;
    width: 180px; height: 135px; border-radius: 10px;
    overflow: hidden; border: 2px solid #333; background: #000;
    z-index: 10; transition: border-color 0.3s;
  }
  .webcam-box.hidden { display: none; }
  .webcam-box.vision { border-color: #a78bfa; }
  .webcam-box video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
  .webcam-tag {
    position: absolute; bottom: 4px; left: 6px;
    font-size: 10px; background: rgba(0,0,0,0.7); padding: 2px 6px;
    border-radius: 4px; color: #aaa;
  }

  /* Transcript */
  .transcript {
    flex: 1; overflow-y: auto; padding: 20px;
    display: flex; flex-direction: column; gap: 10px;
  }
  .msg {
    max-width: 80%; padding: 10px 14px; border-radius: 12px;
    font-size: 15px; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word;
  }
  .msg.user { align-self: flex-end; background: #1a3a6a; border-bottom-right-radius: 4px; }
  .msg.model { align-self: flex-start; background: #1e1e2a; border-bottom-left-radius: 4px; }
  .msg.system { align-self: center; color: #666; font-size: 13px; font-style: italic; }
  .msg.tool {
    align-self: flex-start; background: #1a1a2e; border-left: 3px solid #6c8cff;
    font-size: 13px; color: #aaa; max-width: 90%;
  }
  .msg .lbl {
    font-size: 10px; color: #666; margin-bottom: 3px;
    text-transform: uppercase; font-weight: 600;
  }

  /* Wake word live text */
  .wake-bar {
    padding: 6px 20px;
    background: #0d0d15;
    border-top: 1px solid #1a1a24;
    min-height: 28px;
    display: none;
  }
  .wake-bar.active { display: block; }
  #wakeText {
    font-size: 12px; color: #555; font-style: italic;
    overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
  }
  #wakeText.heard { color: #ff9800; }

  /* Controls */
  .controls {
    padding: 14px 20px 22px;
    display: flex; flex-direction: column; align-items: center; gap: 10px;
    background: #111118; border-top: 1px solid #222;
  }
  .big-btn {
    width: 80px; height: 80px; border-radius: 50%;
    border: 3px solid #333; background: #1a1a24;
    cursor: pointer; display: flex; align-items: center; justify-content: center;
    font-size: 32px; transition: all 0.2s; position: relative;
  }
  .big-btn:hover { border-color: #6c8cff; }
  .big-btn.active { border-color: #4caf50; background: #0a2a0a; animation: glow 2s infinite; }
  .big-btn.speaking { border-color: #6c8cff; background: #0a0a2a; }
  .big-btn.wakeword { border-color: #ff9800; background: #1a1408; }
  @keyframes glow { 50% { box-shadow: 0 0 20px rgba(76,175,80,0.3); } }

  .btn-row { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
  .ctrl {
    padding: 6px 12px; border-radius: 6px; border: 1px solid #333;
    background: #1a1a24; color: #aaa; cursor: pointer; font-size: 12px;
    transition: all 0.2s;
  }
  .ctrl:hover { border-color: #6c8cff; color: #fff; }
  .ctrl.on { border-color: #4caf50; color: #4caf50; }

  .text-row { display: flex; gap: 8px; width: 100%; max-width: 600px; }
  .text-row input {
    flex: 1; padding: 10px 14px; border-radius: 8px; border: 1px solid #333;
    background: #1a1a24; color: #e0e0e0; font-size: 14px; outline: none;
  }
  .text-row input:focus { border-color: #6c8cff; }
  .text-row button {
    padding: 10px 16px; border-radius: 8px; border: none;
    background: #6c8cff; color: #fff; cursor: pointer; font-size: 14px; font-weight: 600;
  }
  .hint { color: #555; font-size: 11px; }

  canvas { display: none; }
</style>
</head>
<body>

<div class="header">
  <h1><span>Kingston</span> Voice <small style="font-size:11px;color:#555;margin-left:6px">Gemini Live</small></h1>
  <div class="header-right">
    <span class="status-dot disconnected" id="dot"></span>
    <span id="statusLabel">Deconnecte</span>
  </div>
</div>

<div class="main">
  <div class="webcam-box hidden" id="camBox">
    <video id="camVideo" autoplay playsinline muted></video>
    <canvas id="camCanvas"></canvas>
    <div class="webcam-tag" id="camTag">Webcam</div>
  </div>
  <div class="transcript" id="transcript">
    <div class="msg system">Dis "Kingston" pour demarrer la conversation, ou appuie sur le bouton.</div>
  </div>
</div>

<div class="wake-bar" id="wakeBar">
  <div id="wakeText">...</div>
</div>

<div class="controls">
  <button class="big-btn" id="mainBtn" title="Demarrer / Arreter">&#x1F3A4;</button>
  <div class="btn-row">
    <button class="ctrl" id="wakeBtn">&#x1F514; Wake Word</button>
    <button class="ctrl" id="camBtn">&#x1F4F7; Webcam</button>
    <button class="ctrl" id="visionBtn">&#x1F441; Vision</button>
  </div>
  <div class="text-row">
    <input id="textIn" placeholder="Ou tape ton message..." />
    <button id="textSend">Envoyer</button>
  </div>
  <div class="hint">Gemini Live — conversation naturelle en temps reel &nbsp;|&nbsp; Escape = stop &nbsp;|&nbsp; Dis "Kingston" pour activer</div>
</div>

<script>
// ═══════════════════════════════════════════════════════
// Kingston Voice — Gemini Live + Wake Word (Web Speech API)
// ═══════════════════════════════════════════════════════

const API_BASE = window.location.origin;
const WS_URL = API_BASE.replace(/^http/, 'ws') + '/ws/voice';
const AUTH_TOKEN = localStorage.getItem('bastilon_token') || '';
const WAKE_WORD = 'kingston';

// Auth prompt
if (!AUTH_TOKEN) {
  const t = prompt('Token Bastilon (DASHBOARD_TOKEN):');
  if (t) { localStorage.setItem('bastilon_token', t); location.reload(); }
}

// ─── State ───
let ws = null;
let sessionActive = false;
let micStream = null;
let audioCtx = null;
let workletNode = null;
let playCtx = null;
let nextPlayTime = 0;
let playQueue = [];
let webcamOn = false;
let visionOn = false;
let visionInterval = null;
let currentTranscriptEl = null;
let isSpeaking = false;

// Wake word state
let wakeWordEnabled = false;
let wakeRecognition = null;
let wakeWordActive = false; // currently listening via Web Speech

// ─── DOM ───
const dot = document.getElementById('dot');
const statusLabel = document.getElementById('statusLabel');
const transcript = document.getElementById('transcript');
const mainBtn = document.getElementById('mainBtn');
const textIn = document.getElementById('textIn');
const camVideo = document.getElementById('camVideo');
const camCanvas = document.getElementById('camCanvas');
const camBox = document.getElementById('camBox');
const camTag = document.getElementById('camTag');
const wakeBar = document.getElementById('wakeBar');
const wakeText = document.getElementById('wakeText');
const wakeBtn = document.getElementById('wakeBtn');

// ═══════════════════════════════════════════════════════
// Status
// ═══════════════════════════════════════════════════════
function setStatus(state, label) {
  dot.className = 'status-dot ' + state;
  statusLabel.textContent = label;
  if (state === 'ready' || state === 'listening') {
    mainBtn.className = 'big-btn active';
    mainBtn.innerHTML = '&#x1F534;';
  } else if (state === 'speaking') {
    mainBtn.className = 'big-btn speaking';
    mainBtn.innerHTML = '&#x1F50A;';
  } else if (state === 'wakeword') {
    mainBtn.className = 'big-btn wakeword';
    mainBtn.innerHTML = '&#x1F514;';
  } else {
    mainBtn.className = 'big-btn';
    mainBtn.innerHTML = '&#x1F3A4;';
  }
}

function addMsg(role, text) {
  const div = document.createElement('div');
  div.className = 'msg ' + role;
  if (role === 'user' || role === 'model') {
    const lbl = document.createElement('div');
    lbl.className = 'lbl';
    lbl.textContent = role === 'user' ? 'Toi' : 'Kingston';
    div.appendChild(lbl);
  }
  const span = document.createElement('span');
  span.textContent = text;
  div.appendChild(span);
  transcript.appendChild(div);
  transcript.scrollTop = transcript.scrollHeight;
  return div;
}

// ═══════════════════════════════════════════════════════
// Wake Word — Web Speech API (runs when Gemini is idle)
// ═══════════════════════════════════════════════════════
function hasWebSpeech() {
  return !!(window.SpeechRecognition || window.webkitSpeechRecognition);
}

function startWakeWord() {
  if (!hasWebSpeech()) {
    addMsg('system', 'Web Speech API non supportee. Utilise Chrome ou Edge.');
    return;
  }
  if (wakeWordActive || sessionActive) return;

  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  wakeRecognition = new SR();
  wakeRecognition.continuous = true;
  wakeRecognition.interimResults = true;
  wakeRecognition.lang = 'fr-FR';
  wakeRecognition.maxAlternatives = 1;

  wakeRecognition.onstart = () => {
    wakeWordActive = true;
    wakeBar.classList.add('active');
    wakeText.textContent = 'En ecoute...';
    wakeText.className = '';
    if (!sessionActive) {
      setStatus('wakeword', 'Dis "Kingston"...');
    }
  };

  wakeRecognition.onresult = (event) => {
    let interim = '';
    let final = '';
    for (let i = event.resultIndex; i < event.results.length; i++) {
      const t = event.results[i][0].transcript;
      if (event.results[i].isFinal) final += t;
      else interim += t;
    }

    const display = (final || interim).trim();
    if (display) {
      wakeText.textContent = display;
    }

    // Check for wake word in any text
    const check = (final || interim).toLowerCase();
    if (check.includes(WAKE_WORD)) {
      onWakeWordDetected();
    }
  };

  wakeRecognition.onerror = (event) => {
    if (event.error === 'no-speech' || event.error === 'aborted') return;
    console.warn('Wake word speech error:', event.error);
    if (event.error === 'not-allowed') {
      addMsg('system', 'Microphone refuse — autorise l\'acces au micro.');
      wakeWordActive = false;
      wakeWordEnabled = false;
      wakeBtn.classList.remove('on');
      wakeBar.classList.remove('active');
      return;
    }
    // Auto-restart on transient errors
    if (wakeWordEnabled && !sessionActive) {
      setTimeout(() => restartWakeWord(), 500);
    }
  };

  wakeRecognition.onend = () => {
    wakeWordActive = false;
    // Auto-restart if still enabled and no Gemini session
    if (wakeWordEnabled && !sessionActive) {
      setTimeout(() => restartWakeWord(), 300);
    } else {
      wakeBar.classList.remove('active');
      if (!sessionActive) {
        setStatus('disconnected', 'Deconnecte');
      }
    }
  };

  try {
    wakeRecognition.start();
  } catch (e) {
    console.warn('Wake word start failed:', e);
  }
}

function stopWakeWord() {
  wakeWordActive = false;
  try { if (wakeRecognition) wakeRecognition.stop(); } catch {}
  wakeRecognition = null;
  wakeBar.classList.remove('active');
}

function restartWakeWord() {
  if (!wakeWordEnabled || sessionActive || wakeWordActive) return;
  stopWakeWord();
  setTimeout(() => {
    if (wakeWordEnabled && !sessionActive) startWakeWord();
  }, 200);
}

function onWakeWordDetected() {
  // Stop wake word listener, start Gemini Live session
  addMsg('system', '"Kingston" detecte — demarrage conversation...');
  playBeep(880, 120);
  wakeText.textContent = 'Kingston detecte!';
  wakeText.className = 'heard';

  stopWakeWord();

  // Small delay to let speech recognition release the mic
  setTimeout(() => {
    startSession();
  }, 400);
}

function toggleWakeWord() {
  wakeWordEnabled = !wakeWordEnabled;
  wakeBtn.classList.toggle('on', wakeWordEnabled);

  if (wakeWordEnabled) {
    if (!sessionActive) {
      startWakeWord();
      addMsg('system', 'Wake word active — dis "Kingston" pour demarrer.');
    }
  } else {
    stopWakeWord();
    if (!sessionActive) {
      setStatus('disconnected', 'Deconnecte');
    }
    addMsg('system', 'Wake word desactive.');
  }
}

function playBeep(freq, duration) {
  try {
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.frequency.value = freq;
    osc.type = 'sine';
    gain.gain.value = 0.15;
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration / 1000);
    osc.stop(ctx.currentTime + duration / 1000 + 0.05);
    setTimeout(() => ctx.close(), duration + 200);
  } catch {}
}

// ═══════════════════════════════════════════════════════
// WebSocket connection (Gemini Live)
// ═══════════════════════════════════════════════════════
function connectWS() {
  if (ws) return;
  setStatus('connecting', 'Connexion...');

  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    ws.send(JSON.stringify({
      type: 'auth',
      token: AUTH_TOKEN,
      voice: 'Enceladus',
      language: 'fr',
    }));
    setStatus('connecting', 'Authentification...');
  };

  ws.onmessage = (evt) => {
    let msg;
    try { msg = JSON.parse(evt.data); } catch { return; }
    handleServerMessage(msg);
  };

  ws.onerror = () => {
    addMsg('system', 'Erreur de connexion WebSocket.');
  };

  ws.onclose = () => {
    ws = null;
    if (sessionActive) {
      addMsg('system', 'Connexion perdue.');
      stopSession();
    }
  };
}

function handleServerMessage(msg) {
  switch (msg.type) {
    case 'ready':
      setStatus('ready', 'Kingston ecoute...');
      addMsg('system', 'Connecte! Parle naturellement — Kingston t\'entend en temps reel.');
      startMic();
      break;

    case 'audio':
      playAudioChunk(msg.data);
      if (!isSpeaking) {
        isSpeaking = true;
        setStatus('speaking', 'Kingston parle...');
      }
      break;

    case 'transcript':
      if (msg.role === 'model') {
        if (!currentTranscriptEl || currentTranscriptEl.dataset.role !== 'model') {
          currentTranscriptEl = addMsg('model', msg.text);
          currentTranscriptEl.dataset.role = 'model';
        } else {
          const span = currentTranscriptEl.querySelector('span');
          if (span) span.textContent += msg.text;
          transcript.scrollTop = transcript.scrollHeight;
        }
      } else {
        currentTranscriptEl = addMsg('user', msg.text);
        currentTranscriptEl.dataset.role = 'user';
      }
      break;

    case 'interrupted':
      stopPlayback();
      isSpeaking = false;
      setStatus('ready', 'Kingston ecoute...');
      currentTranscriptEl = null;
      break;

    case 'turn_complete':
      isSpeaking = false;
      setStatus('ready', 'Kingston ecoute...');
      currentTranscriptEl = null;
      break;

    case 'tool':
      if (msg.status === 'calling') {
        addMsg('tool', '> ' + msg.name + '...');
      } else if (msg.status === 'done') {
        addMsg('tool', '< ' + msg.name + ': ' + (msg.result || '').slice(0, 200));
      }
      break;

    case 'session_closed':
      addMsg('system', 'Session Gemini expiree — reconnexion...');
      break;

    case 'error':
      addMsg('system', 'Erreur: ' + msg.message);
      break;
  }
}

// ═══════════════════════════════════════════════════════
// Microphone capture → PCM 16kHz mono int16 → base64
// ═══════════════════════════════════════════════════════
async function startMic() {
  try {
    audioCtx = new AudioContext({ sampleRate: 16000 });
    if (audioCtx.state === 'suspended') await audioCtx.resume();

    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { channelCount: 1, sampleRate: 16000, echoCancellation: true, noiseSuppression: true },
    });

    const workletCode = `
      class PCMSender extends AudioWorkletProcessor {
        constructor() {
          super();
          this.buffer = [];
        }
        process(inputs) {
          const ch = inputs[0]?.[0];
          if (!ch) return true;
          for (let i = 0; i < ch.length; i++) this.buffer.push(ch[i]);
          if (this.buffer.length >= 1600) {
            const f32 = new Float32Array(this.buffer.splice(0, 1600));
            this.port.postMessage(f32);
          }
          return true;
        }
      }
      registerProcessor('pcm-sender', PCMSender);
    `;
    const blob = new Blob([workletCode], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(blobUrl);
    URL.revokeObjectURL(blobUrl);

    const source = audioCtx.createMediaStreamSource(micStream);
    workletNode = new AudioWorkletNode(audioCtx, 'pcm-sender');

    workletNode.port.onmessage = (e) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      const float32 = e.data;
      const int16 = new Int16Array(float32.length);
      for (let i = 0; i < float32.length; i++) {
        int16[i] = Math.max(-32768, Math.min(32767, Math.round(float32[i] * 32767)));
      }
      const bytes = new Uint8Array(int16.buffer);
      let binary = '';
      for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
      ws.send(JSON.stringify({ type: 'audio', data: btoa(binary) }));
    };

    source.connect(workletNode);
    workletNode.connect(audioCtx.destination);
  } catch (err) {
    console.warn('AudioWorklet failed, using ScriptProcessor fallback:', err);
    await startMicFallback();
  }
}

async function startMicFallback() {
  audioCtx = new AudioContext();
  if (audioCtx.state === 'suspended') await audioCtx.resume();

  micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const source = audioCtx.createMediaStreamSource(micStream);
  const processor = audioCtx.createScriptProcessor(4096, 1, 1);

  const nativeSR = audioCtx.sampleRate;
  const targetSR = 16000;
  const ratio = nativeSR / targetSR;

  processor.onaudioprocess = (e) => {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    const input = e.inputBuffer.getChannelData(0);
    const len = Math.floor(input.length / ratio);
    const int16 = new Int16Array(len);
    for (let i = 0; i < len; i++) {
      const sample = input[Math.round(i * ratio)];
      int16[i] = Math.max(-32768, Math.min(32767, Math.round(sample * 32767)));
    }
    const bytes = new Uint8Array(int16.buffer);
    let binary = '';
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    ws.send(JSON.stringify({ type: 'audio', data: btoa(binary) }));
  };

  source.connect(processor);
  processor.connect(audioCtx.destination);
}

function stopMic() {
  if (workletNode) { workletNode.disconnect(); workletNode = null; }
  if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
  if (audioCtx) { audioCtx.close().catch(() => {}); audioCtx = null; }
}

// ═══════════════════════════════════════════════════════
// Audio playback — PCM 24kHz from Gemini
// ═══════════════════════════════════════════════════════
function ensurePlayCtx() {
  if (!playCtx) {
    playCtx = new AudioContext({ sampleRate: 24000 });
  }
  if (playCtx.state === 'suspended') playCtx.resume();
}

function playAudioChunk(base64Pcm24k) {
  ensurePlayCtx();

  const raw = atob(base64Pcm24k);
  const bytes = new Uint8Array(raw.length);
  for (let i = 0; i < raw.length; i++) bytes[i] = raw.charCodeAt(i);
  const int16 = new Int16Array(bytes.buffer);
  const float32 = new Float32Array(int16.length);
  for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 32768;

  const buffer = playCtx.createBuffer(1, float32.length, 24000);
  buffer.getChannelData(0).set(float32);

  const source = playCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(playCtx.destination);

  const now = playCtx.currentTime;
  const startAt = Math.max(now + 0.01, nextPlayTime);
  source.start(startAt);
  nextPlayTime = startAt + buffer.duration;

  playQueue.push(source);
  source.onended = () => {
    const idx = playQueue.indexOf(source);
    if (idx >= 0) playQueue.splice(idx, 1);
  };
}

function stopPlayback() {
  playQueue.forEach(s => { try { s.stop(); } catch {} });
  playQueue = [];
  nextPlayTime = 0;
}

// ═══════════════════════════════════════════════════════
// Webcam + Vision
// ═══════════════════════════════════════════════════════
async function toggleCam() {
  if (webcamOn) {
    camVideo.srcObject?.getTracks().forEach(t => t.stop());
    camVideo.srcObject = null;
    webcamOn = false;
    camBox.classList.add('hidden');
    document.getElementById('camBtn').classList.remove('on');
    if (visionOn) toggleVision();
  } else {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: { ideal: 640 }, height: { ideal: 480 } }, audio: false,
      });
      camVideo.srcObject = stream;
      webcamOn = true;
      camBox.classList.remove('hidden');
      document.getElementById('camBtn').classList.add('on');
    } catch (e) {
      addMsg('system', 'Webcam non disponible: ' + e.message);
    }
  }
}

function toggleVision() {
  visionOn = !visionOn;
  document.getElementById('visionBtn').classList.toggle('on', visionOn);
  camBox.classList.toggle('vision', visionOn);
  camTag.textContent = visionOn ? 'Vision active' : 'Webcam';

  if (visionOn) {
    if (!webcamOn) toggleCam();
    visionInterval = setInterval(sendVisionFrame, 5000);
    sendVisionFrame();
  } else {
    if (visionInterval) { clearInterval(visionInterval); visionInterval = null; }
  }
}

function sendVisionFrame() {
  if (!ws || ws.readyState !== WebSocket.OPEN || !webcamOn || !visionOn) return;
  if (!camVideo.videoWidth) return;

  camCanvas.width = Math.min(camVideo.videoWidth, 640);
  camCanvas.height = Math.min(camVideo.videoHeight, 480);
  camCanvas.getContext('2d').drawImage(camVideo, 0, 0, camCanvas.width, camCanvas.height);

  const dataUrl = camCanvas.toDataURL('image/jpeg', 0.6);
  ws.send(JSON.stringify({ type: 'image', data: dataUrl }));

  camBox.style.borderColor = '#a78bfa';
  setTimeout(() => { camBox.style.borderColor = ''; }, 300);
}

// ═══════════════════════════════════════════════════════
// Session management (Gemini Live)
// ═══════════════════════════════════════════════════════
function startSession() {
  if (sessionActive) return;
  sessionActive = true;

  // Stop wake word — Gemini takes over the mic
  stopWakeWord();

  connectWS();
}

function stopSession() {
  sessionActive = false;
  stopMic();
  stopPlayback();
  if (visionInterval) { clearInterval(visionInterval); visionInterval = null; }
  if (ws) { ws.close(); ws = null; }
  isSpeaking = false;
  currentTranscriptEl = null;

  // Resume wake word if enabled
  if (wakeWordEnabled) {
    setTimeout(() => {
      if (!sessionActive) {
        startWakeWord();
        setStatus('wakeword', 'Dis "Kingston"...');
      }
    }, 500);
  } else {
    setStatus('disconnected', 'Deconnecte');
  }
}

function toggleSession() {
  if (sessionActive) stopSession();
  else startSession();
}

// ═══════════════════════════════════════════════════════
// Event listeners
// ═══════════════════════════════════════════════════════
mainBtn.addEventListener('click', toggleSession);
wakeBtn.addEventListener('click', toggleWakeWord);
document.getElementById('camBtn').addEventListener('click', toggleCam);
document.getElementById('visionBtn').addEventListener('click', toggleVision);

textIn.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendText();
  }
});
document.getElementById('textSend').addEventListener('click', sendText);

function sendText() {
  const text = textIn.value.trim();
  if (!text) return;
  textIn.value = '';

  if (!sessionActive) {
    // Auto-start session if text is sent while idle
    startSession();
    // Wait for connection then send
    const waitAndSend = setInterval(() => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        clearInterval(waitAndSend);
        addMsg('user', text);
        ws.send(JSON.stringify({ type: 'text', text }));
      }
    }, 200);
    setTimeout(() => clearInterval(waitAndSend), 10000);
    return;
  }

  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  addMsg('user', text);
  ws.send(JSON.stringify({ type: 'text', text }));
}

// Escape = stop Gemini session (wake word resumes if enabled)
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && sessionActive) {
    stopSession();
    addMsg('system', 'Session arretee.');
  }
});

// ── PWA: Service Worker ──
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(() => {});
}

// ── PWA: Install prompt ──
let deferredInstallPrompt = null;
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredInstallPrompt = e;
  // Show install button
  const installBtn = document.createElement('button');
  installBtn.className = 'ctrl';
  installBtn.innerHTML = '&#x1F4E5; Installer';
  installBtn.title = 'Installer Kingston Voice comme application';
  installBtn.addEventListener('click', async () => {
    if (!deferredInstallPrompt) return;
    deferredInstallPrompt.prompt();
    const result = await deferredInstallPrompt.userChoice;
    if (result.outcome === 'accepted') {
      addMsg('system', 'Kingston Voice installe! Tu peux fermer cet onglet.');
      installBtn.remove();
    }
    deferredInstallPrompt = null;
  });
  document.querySelector('.btn-row').appendChild(installBtn);
});

// Detect if running as installed PWA
const isStandalone = window.matchMedia('(display-mode: standalone)').matches
  || window.navigator.standalone === true;
if (isStandalone) {
  document.querySelector('.hint').textContent = 'Kingston Voice — application installee | Dis "Kingston" pour activer';
}

// ── Init ──
// Auto-enable wake word if Web Speech API is available
if (hasWebSpeech()) {
  wakeWordEnabled = true;
  wakeBtn.classList.add('on');
  startWakeWord();
} else {
  setStatus('disconnected', 'Pret — appuie sur le micro pour commencer');
}
</script>
</body>
</html>
