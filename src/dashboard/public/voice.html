<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kingston Voice</title>
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#6c8cff">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Kingston">
<link rel="apple-touch-icon" href="/icon-192.png">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #0a0a0f;
    color: #e0e0e0;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 20px;
    background: #111118;
    border-bottom: 1px solid #222;
  }
  .header h1 { font-size: 18px; font-weight: 600; }
  .header h1 span { color: #6c8cff; }
  .header-right { display: flex; gap: 10px; align-items: center; }
  .status-dot {
    width: 10px; height: 10px; border-radius: 50%;
    display: inline-block; transition: background 0.3s;
  }
  .status-dot.disconnected { background: #666; }
  .status-dot.wakeword { background: #ff9800; animation: pulse 2.5s infinite; }
  .status-dot.connecting { background: #ff9800; animation: blink 1s infinite; }
  .status-dot.ready { background: #4caf50; }
  .status-dot.listening { background: #ff9800; animation: blink 0.6s infinite; }
  .status-dot.speaking { background: #6c8cff; animation: blink 1.2s infinite; }
  .status-dot.processing { background: #a78bfa; animation: blink 0.8s infinite; }
  .status-dot.local-listening { background: #4caf50; animation: pulse 2s infinite; }
  @keyframes blink { 50% { opacity: 0.3; } }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
  #statusLabel { font-size: 13px; color: #888; }

  .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }

  /* Webcam */
  .webcam-box {
    position: absolute; top: 10px; right: 16px;
    width: 180px; height: 135px; border-radius: 10px;
    overflow: hidden; border: 2px solid #333; background: #000;
    z-index: 10; transition: border-color 0.3s;
  }
  .webcam-box.hidden { display: none; }
  .webcam-box.vision { border-color: #a78bfa; }
  .webcam-box video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
  .webcam-tag {
    position: absolute; bottom: 4px; left: 6px;
    font-size: 10px; background: rgba(0,0,0,0.7); padding: 2px 6px;
    border-radius: 4px; color: #aaa;
  }

  /* Transcript */
  .transcript {
    flex: 1; overflow-y: auto; padding: 20px;
    display: flex; flex-direction: column; gap: 10px;
  }
  .msg {
    max-width: 80%; padding: 10px 14px; border-radius: 12px;
    font-size: 15px; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word;
  }
  .msg.user { align-self: flex-end; background: #1a3a6a; border-bottom-right-radius: 4px; }
  .msg.model { align-self: flex-start; background: #1e1e2a; border-bottom-left-radius: 4px; }
  .msg.system { align-self: center; color: #666; font-size: 13px; font-style: italic; }
  .msg.tool {
    align-self: flex-start; background: #1a1a2e; border-left: 3px solid #6c8cff;
    font-size: 13px; color: #aaa; max-width: 90%;
  }
  .msg .lbl {
    font-size: 10px; color: #666; margin-bottom: 3px;
    text-transform: uppercase; font-weight: 600;
  }
  .msg img {
    max-width: 100%; border-radius: 8px; margin: 6px 0;
    cursor: pointer; transition: transform 0.2s;
  }
  .msg img:hover { transform: scale(1.02); }
  .msg code {
    background: #0d0d15; padding: 2px 6px; border-radius: 4px;
    font-family: 'Cascadia Code', 'Fira Code', monospace; font-size: 13px;
    color: #a78bfa;
  }
  .msg pre {
    background: #0d0d15; padding: 10px 12px; border-radius: 8px;
    overflow-x: auto; margin: 6px 0; white-space: pre-wrap;
    font-family: 'Cascadia Code', 'Fira Code', monospace; font-size: 13px;
    line-height: 1.4; border: 1px solid #1a1a2e;
  }
  .msg pre code { background: none; padding: 0; }
  .msg a { color: #6c8cff; text-decoration: none; }
  .msg a:hover { text-decoration: underline; }
  .msg strong { color: #fff; }
  .msg ul, .msg ol { margin: 4px 0 4px 18px; }
  .msg li { margin: 2px 0; }
  .msg blockquote {
    border-left: 3px solid #6c8cff; padding-left: 10px;
    margin: 6px 0; color: #aaa; font-style: italic;
  }
  .msg .img-caption {
    font-size: 11px; color: #666; text-align: center; margin-top: 2px;
  }
  /* Fullscreen image overlay */
  .img-overlay {
    display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9); z-index: 1000; cursor: zoom-out;
    justify-content: center; align-items: center;
  }
  .img-overlay.active { display: flex; }
  .img-overlay img { max-width: 95%; max-height: 95%; object-fit: contain; border-radius: 8px; }

  /* Wake word live text */
  .wake-bar {
    padding: 6px 20px;
    background: #0d0d15;
    border-top: 1px solid #1a1a24;
    min-height: 28px;
    display: none;
  }
  .wake-bar.active { display: block; }
  #wakeText {
    font-size: 12px; color: #555; font-style: italic;
    overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
  }
  #wakeText.heard { color: #ff9800; }

  /* Controls */
  .controls {
    padding: 14px 20px 22px;
    display: flex; flex-direction: column; align-items: center; gap: 10px;
    background: #111118; border-top: 1px solid #222;
  }
  .big-btn {
    width: 80px; height: 80px; border-radius: 50%;
    border: 3px solid #333; background: #1a1a24;
    cursor: pointer; display: flex; align-items: center; justify-content: center;
    font-size: 32px; transition: all 0.2s; position: relative;
  }
  .big-btn:hover { border-color: #6c8cff; }
  .big-btn.active { border-color: #4caf50; background: #0a2a0a; animation: glow 2s infinite; }
  .big-btn.speaking { border-color: #6c8cff; background: #0a0a2a; }
  .big-btn.wakeword { border-color: #ff9800; background: #1a1408; }
  .big-btn.local-active { border-color: #4caf50; background: #0a2a0a; animation: glow 2s infinite; }
  .big-btn.processing { border-color: #a78bfa; background: #1a0a2a; }
  @keyframes glow { 50% { box-shadow: 0 0 20px rgba(76,175,80,0.3); } }
  .ctrl.mode-toggle { border-color: #a78bfa; color: #a78bfa; font-weight: 600; }

  .btn-row { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
  .ctrl {
    padding: 6px 12px; border-radius: 6px; border: 1px solid #333;
    background: #1a1a24; color: #aaa; cursor: pointer; font-size: 12px;
    transition: all 0.2s;
  }
  .ctrl:hover { border-color: #6c8cff; color: #fff; }
  .ctrl.on { border-color: #4caf50; color: #4caf50; }

  .text-row { display: flex; gap: 8px; width: 100%; max-width: 600px; }
  .text-row input {
    flex: 1; padding: 10px 14px; border-radius: 8px; border: 1px solid #333;
    background: #1a1a24; color: #e0e0e0; font-size: 14px; outline: none;
  }
  .text-row input:focus { border-color: #6c8cff; }
  .text-row button {
    padding: 10px 16px; border-radius: 8px; border: none;
    background: #6c8cff; color: #fff; cursor: pointer; font-size: 14px; font-weight: 600;
  }
  .hint { color: #555; font-size: 11px; }

  canvas { display: none; }
</style>
</head>
<body>

<div class="img-overlay" id="imgOverlay" onclick="this.classList.remove('active')">
  <img id="overlayImg" src="" alt="Fullscreen">
</div>

<div class="header">
  <h1><span>Kingston</span> Voice <small style="font-size:11px;color:#555;margin-left:6px" id="modeLabel">Local</small></h1>
  <div class="header-right">
    <span class="status-dot disconnected" id="dot"></span>
    <span id="statusLabel">Deconnecte</span>
  </div>
</div>

<div class="main">
  <div class="webcam-box hidden" id="camBox">
    <video id="camVideo" autoplay playsinline muted></video>
    <canvas id="camCanvas"></canvas>
    <div class="webcam-tag" id="camTag">Webcam</div>
  </div>
  <div class="transcript" id="transcript">
    <div class="msg system">Dis "Kingston" pour demarrer la conversation, ou appuie sur le bouton.</div>
  </div>
</div>

<div class="wake-bar" id="wakeBar">
  <div id="wakeText">...</div>
</div>

<div class="controls">
  <button class="big-btn" id="mainBtn" title="Demarrer / Arreter">&#x1F3A4;</button>
  <div class="btn-row">
    <button class="ctrl mode-toggle" id="modeBtn">&#x1F504; Local</button>
    <button class="ctrl" id="wakeBtn">&#x1F514; Wake Word</button>
    <button class="ctrl" id="camBtn">&#x1F4F7; Webcam</button>
    <button class="ctrl" id="visionBtn">&#x1F441; Vision</button>
  </div>
  <div class="text-row">
    <input id="textIn" placeholder="Ou tape ton message..." />
    <button id="textSend">Envoyer</button>
  </div>
  <div class="hint" id="hintText">Local — Web Speech + Edge TTS &nbsp;|&nbsp; Escape = stop &nbsp;|&nbsp; Dis "Kingston" pour activer</div>
</div>

<script>
// ═══════════════════════════════════════════════════════
// Kingston Voice — Local + Gemini Live + Wake Word
// ═══════════════════════════════════════════════════════

const API_BASE = window.location.origin;
const WS_URL = API_BASE.replace(/^http/, 'ws') + '/ws/voice';
const AUTH_TOKEN = localStorage.getItem('bastilon_token') || '';
// Wake word variants — Web Speech API often mistranscribes
const WAKE_WORDS = [
  'kingston', 'kengston', 'kingstonn', 'kengstone', 'kingstone',
  'king stone', 'king ston', 'kington', 'kenston', 'kinston',
  'kingstown', 'kingstonne', 'kings ton', 'kings tone',
  'quinston', 'quingston', 'kingstan', 'kinkston',
];

// Auth prompt
if (!AUTH_TOKEN) {
  const t = prompt('Token Bastilon (DASHBOARD_TOKEN):');
  if (t) { localStorage.setItem('bastilon_token', t); location.reload(); }
}

// ─── Modes: 'local' | 'cloud' ───
let voiceMode = localStorage.getItem('kingston_voice_mode') || 'local';

// ─── State ───
let ws = null;
let sessionActive = false;
let micStream = null;
let audioCtx = null;
let workletNode = null;
let playCtx = null;
let nextPlayTime = 0;
let playQueue = [];
let webcamOn = false;
let visionOn = false;
let visionInterval = null;
let currentTranscriptEl = null;
let isSpeaking = false;

// Wake word state
let wakeWordEnabled = false;
let wakeRecognition = null;
let wakeWordActive = false; // currently listening via Web Speech

// Local mode state
let localRecognition = null;
let localListening = false;
let localProcessing = false;
let localAudio = null;       // current Audio element for TTS playback
let localSilenceTimer = null;
let localFinalText = '';     // accumulates final results for current utterance

// ─── DOM ───
const dot = document.getElementById('dot');
const statusLabel = document.getElementById('statusLabel');
const transcript = document.getElementById('transcript');
const mainBtn = document.getElementById('mainBtn');
const textIn = document.getElementById('textIn');
const camVideo = document.getElementById('camVideo');
const camCanvas = document.getElementById('camCanvas');
const camBox = document.getElementById('camBox');
const camTag = document.getElementById('camTag');
const wakeBar = document.getElementById('wakeBar');
const wakeText = document.getElementById('wakeText');
const wakeBtn = document.getElementById('wakeBtn');
const modeBtn = document.getElementById('modeBtn');
const modeLabel = document.getElementById('modeLabel');
const hintText = document.getElementById('hintText');

// ═══════════════════════════════════════════════════════
// Status
// ═══════════════════════════════════════════════════════
function setStatus(state, label) {
  dot.className = 'status-dot ' + state;
  statusLabel.textContent = label;
  if (state === 'ready' || state === 'listening' || state === 'local-listening') {
    mainBtn.className = 'big-btn ' + (voiceMode === 'local' ? 'local-active' : 'active');
    mainBtn.innerHTML = '&#x1F534;';
  } else if (state === 'speaking') {
    mainBtn.className = 'big-btn speaking';
    mainBtn.innerHTML = '&#x1F50A;';
  } else if (state === 'processing') {
    mainBtn.className = 'big-btn processing';
    mainBtn.innerHTML = '&#x23F3;';
  } else if (state === 'wakeword') {
    mainBtn.className = 'big-btn wakeword';
    mainBtn.innerHTML = '&#x1F514;';
  } else {
    mainBtn.className = 'big-btn';
    mainBtn.innerHTML = '&#x1F3A4;';
  }
}

function addMsg(role, text) {
  const div = document.createElement('div');
  div.className = 'msg ' + role;
  if (role === 'user' || role === 'model') {
    const lbl = document.createElement('div');
    lbl.className = 'lbl';
    lbl.textContent = role === 'user' ? 'Toi' : 'Kingston';
    div.appendChild(lbl);
  }
  const content = document.createElement('div');
  if (role === 'model' || role === 'tool') {
    content.innerHTML = renderRichText(text);
    // Make images clickable for fullscreen
    content.querySelectorAll('img').forEach(img => {
      img.addEventListener('click', (e) => {
        e.stopPropagation();
        document.getElementById('overlayImg').src = img.src;
        document.getElementById('imgOverlay').classList.add('active');
      });
    });
  } else {
    content.textContent = text;
  }
  div.appendChild(content);
  transcript.appendChild(div);
  transcript.scrollTop = transcript.scrollHeight;
  return div;
}

/** Parse markdown-like text into HTML with image support */
function renderRichText(text) {
  if (!text) return '';
  let html = escapeHtml(text);

  // Code blocks (``` ... ```)
  html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, (_, lang, code) =>
    '<pre><code>' + code.trim() + '</code></pre>');

  // Inline code (`...`)
  html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

  // Images: ![alt](url)
  html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (_, alt, url) =>
    '<img src="' + url + '" alt="' + alt + '" loading="lazy">' +
    (alt ? '<div class="img-caption">' + alt + '</div>' : ''));

  // Standalone image URLs on their own line
  html = html.replace(/(^|\n)(https?:\/\/[^\s]+\.(?:png|jpg|jpeg|gif|webp|svg|bmp)(?:\?[^\s]*)?)(\n|$)/gi, (_, pre, url, post) =>
    pre + '<img src="' + url + '" alt="Image" loading="lazy">' + post);

  // Base64 images (data:image/...)
  html = html.replace(/(data:image\/[a-z+]+;base64,[A-Za-z0-9+/=]+)/g,
    '<img src="$1" alt="Image" loading="lazy">');

  // Links: [text](url)
  html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');

  // Bare URLs (not already in href or src)
  html = html.replace(/(?<!(?:href|src)=")(?<!["\w])(https?:\/\/[^\s<]+[^\s<.,;:!?\)])/g,
    '<a href="$1" target="_blank" rel="noopener">$1</a>');

  // Bold: **text** or __text__
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');

  // Italic: *text* or _text_
  html = html.replace(/(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)/g, '<em>$1</em>');

  // Blockquotes: > text
  html = html.replace(/(^|\n)&gt; (.+)/g, '$1<blockquote>$2</blockquote>');

  // Unordered lists: - item or * item
  html = html.replace(/(^|\n)[*-] (.+)/g, '$1<li>$2</li>');
  html = html.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');

  // Line breaks
  html = html.replace(/\n/g, '<br>');

  // Clean up double <br> inside blocks
  html = html.replace(/<br><\/?(ul|ol|pre|blockquote)/g, '</$1');

  return html;
}

function escapeHtml(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

// ═══════════════════════════════════════════════════════
// Mode switching
// ═══════════════════════════════════════════════════════
function updateModeUI() {
  if (voiceMode === 'local') {
    modeBtn.innerHTML = '&#x1F504; Local';
    modeBtn.style.borderColor = '#4caf50';
    modeBtn.style.color = '#4caf50';
    modeLabel.textContent = 'Local';
    hintText.textContent = 'Local — Web Speech + Edge TTS ($0)  |  Escape = stop  |  Dis "Kingston" pour activer';
  } else {
    modeBtn.innerHTML = '&#x1F504; Cloud';
    modeBtn.style.borderColor = '#a78bfa';
    modeBtn.style.color = '#a78bfa';
    modeLabel.textContent = 'Gemini Live';
    hintText.textContent = 'Gemini Live — conversation naturelle en temps reel  |  Escape = stop  |  Dis "Kingston" pour activer';
  }
  const isStandalone = window.matchMedia('(display-mode: standalone)').matches
    || window.navigator.standalone === true;
  if (isStandalone) {
    hintText.textContent = 'Kingston Voice — application installee  |  ' + (voiceMode === 'local' ? 'Mode Local ($0)' : 'Mode Gemini Live');
  }
}

function toggleMode() {
  // Stop any active session first
  if (sessionActive) {
    if (voiceMode === 'local') stopLocalSession();
    else stopSession();
  }
  voiceMode = voiceMode === 'local' ? 'cloud' : 'local';
  localStorage.setItem('kingston_voice_mode', voiceMode);
  updateModeUI();
  addMsg('system', 'Mode: ' + (voiceMode === 'local' ? 'Local (Web Speech + Edge TTS)' : 'Cloud (Gemini Live)'));

  // Restart wake word
  if (wakeWordEnabled && !sessionActive) {
    restartWakeWord();
  }
}

// ═══════════════════════════════════════════════════════
// Wake Word — Web Speech API (runs when idle in both modes)
// ═══════════════════════════════════════════════════════
function hasWebSpeech() {
  return !!(window.SpeechRecognition || window.webkitSpeechRecognition);
}

function startWakeWord() {
  if (!hasWebSpeech()) {
    addMsg('system', 'Web Speech API non supportee. Utilise Chrome ou Edge.');
    return;
  }
  if (wakeWordActive || sessionActive) return;

  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  wakeRecognition = new SR();
  wakeRecognition.continuous = true;
  wakeRecognition.interimResults = true;
  wakeRecognition.lang = 'fr-FR';
  wakeRecognition.maxAlternatives = 1;

  wakeRecognition.onstart = () => {
    wakeWordActive = true;
    wakeBar.classList.add('active');
    wakeText.textContent = 'En ecoute...';
    wakeText.className = '';
    if (!sessionActive) {
      setStatus('wakeword', 'Dis "Kingston"...');
    }
  };

  wakeRecognition.onresult = (event) => {
    let interim = '';
    let final = '';
    for (let i = event.resultIndex; i < event.results.length; i++) {
      const t = event.results[i][0].transcript;
      if (event.results[i].isFinal) final += t;
      else interim += t;
    }

    const display = (final || interim).trim();
    if (display) {
      wakeText.textContent = display;
    }

    // Check for wake word in any text (fuzzy matching)
    const check = (final || interim).toLowerCase().replace(/[.,!?;:'"]/g, '');
    if (WAKE_WORDS.some(w => check.includes(w))) {
      onWakeWordDetected();
    }
  };

  wakeRecognition.onerror = (event) => {
    if (event.error === 'no-speech' || event.error === 'aborted') return;
    console.warn('Wake word speech error:', event.error);
    if (event.error === 'not-allowed') {
      addMsg('system', 'Microphone refuse — autorise l\'acces au micro.');
      wakeWordActive = false;
      wakeWordEnabled = false;
      wakeBtn.classList.remove('on');
      wakeBar.classList.remove('active');
      return;
    }
    // Auto-restart on transient errors
    if (wakeWordEnabled && !sessionActive) {
      setTimeout(() => restartWakeWord(), 500);
    }
  };

  wakeRecognition.onend = () => {
    wakeWordActive = false;
    // Auto-restart if still enabled and no session
    if (wakeWordEnabled && !sessionActive) {
      setTimeout(() => restartWakeWord(), 300);
    } else {
      wakeBar.classList.remove('active');
      if (!sessionActive) {
        setStatus('disconnected', 'Deconnecte');
      }
    }
  };

  try {
    wakeRecognition.start();
  } catch (e) {
    console.warn('Wake word start failed:', e);
  }
}

function stopWakeWord() {
  wakeWordActive = false;
  try { if (wakeRecognition) wakeRecognition.stop(); } catch {}
  wakeRecognition = null;
  wakeBar.classList.remove('active');
}

function restartWakeWord() {
  if (!wakeWordEnabled || sessionActive || wakeWordActive) return;
  stopWakeWord();
  setTimeout(() => {
    if (wakeWordEnabled && !sessionActive) startWakeWord();
  }, 200);
}

function onWakeWordDetected() {
  addMsg('system', '"Kingston" detecte — demarrage conversation...');
  playBeep(880, 120);
  wakeText.textContent = 'Kingston detecte!';
  wakeText.className = 'heard';

  stopWakeWord();

  // Small delay to let speech recognition release the mic
  setTimeout(() => {
    if (voiceMode === 'local') startLocalSession();
    else startSession();
  }, 400);
}

function toggleWakeWord() {
  wakeWordEnabled = !wakeWordEnabled;
  wakeBtn.classList.toggle('on', wakeWordEnabled);

  if (wakeWordEnabled) {
    if (!sessionActive) {
      startWakeWord();
      addMsg('system', 'Wake word active — dis "Kingston" pour demarrer.');
    }
  } else {
    stopWakeWord();
    if (!sessionActive) {
      setStatus('disconnected', 'Deconnecte');
    }
    addMsg('system', 'Wake word desactive.');
  }
}

function playBeep(freq, duration) {
  try {
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.frequency.value = freq;
    osc.type = 'sine';
    gain.gain.value = 0.15;
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration / 1000);
    osc.stop(ctx.currentTime + duration / 1000 + 0.05);
    setTimeout(() => ctx.close(), duration + 200);
  } catch {}
}

// ═══════════════════════════════════════════════════════
// LOCAL MODE — Web Speech STT → Kingston API → Edge TTS
// ═══════════════════════════════════════════════════════

function startLocalSession() {
  if (sessionActive) return;
  sessionActive = true;
  localListening = false;
  localProcessing = false;
  localFinalText = '';

  stopWakeWord();
  addMsg('system', 'Mode local — parle, Kingston ecoute...');
  startLocalListening();
}

function startLocalListening() {
  if (!hasWebSpeech() || localProcessing) return;
  if (localListening) return;

  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  localRecognition = new SR();
  localRecognition.continuous = true;
  localRecognition.interimResults = true;
  localRecognition.lang = 'fr-FR';
  localRecognition.maxAlternatives = 1;

  localRecognition.onstart = () => {
    localListening = true;
    localFinalText = '';
    wakeBar.classList.add('active');
    wakeText.textContent = 'Ecoute...';
    wakeText.className = '';
    setStatus('local-listening', 'Kingston ecoute...');
  };

  localRecognition.onresult = (event) => {
    let interim = '';
    let newFinal = '';
    for (let i = event.resultIndex; i < event.results.length; i++) {
      const t = event.results[i][0].transcript;
      if (event.results[i].isFinal) newFinal += t;
      else interim += t;
    }

    if (newFinal) {
      localFinalText += (localFinalText ? ' ' : '') + newFinal.trim();
    }

    const display = (localFinalText + (interim ? ' ' + interim : '')).trim();
    if (display) {
      wakeText.textContent = display;
    }

    // Reset silence timer on any speech
    clearTimeout(localSilenceTimer);
    if (localFinalText) {
      // After 1.5s of silence following final text, send to Kingston
      localSilenceTimer = setTimeout(() => {
        if (localFinalText && !localProcessing && sessionActive) {
          processLocalUtterance(localFinalText.trim());
        }
      }, 1500);
    }
  };

  localRecognition.onerror = (event) => {
    if (event.error === 'no-speech' || event.error === 'aborted') return;
    console.warn('Local speech error:', event.error);
    if (event.error === 'not-allowed') {
      addMsg('system', 'Microphone refuse.');
      stopLocalSession();
      return;
    }
    // Auto-restart on transient errors
    if (sessionActive && !localProcessing) {
      localListening = false;
      setTimeout(() => {
        if (sessionActive && !localProcessing) startLocalListening();
      }, 300);
    }
  };

  localRecognition.onend = () => {
    localListening = false;
    wakeBar.classList.remove('active');
    // Auto-restart if session active and not processing
    if (sessionActive && !localProcessing) {
      setTimeout(() => {
        if (sessionActive && !localProcessing) startLocalListening();
      }, 200);
    }
  };

  try {
    localRecognition.start();
  } catch (e) {
    console.warn('Local listening start failed:', e);
    localListening = false;
  }
}

function stopLocalListening() {
  localListening = false;
  clearTimeout(localSilenceTimer);
  try { if (localRecognition) localRecognition.stop(); } catch {}
  localRecognition = null;
  wakeBar.classList.remove('active');
}

async function processLocalUtterance(text) {
  if (!text || localProcessing) return;
  localProcessing = true;
  localFinalText = '';

  // Stop listening while processing + speaking
  stopLocalListening();

  addMsg('user', text);
  setStatus('processing', 'Kingston reflechit...');
  wakeBar.classList.add('active');
  wakeText.textContent = 'Reflexion...';
  wakeText.className = '';

  try {
    // 1. Send to Kingston API (with timeout)
    const chatController = new AbortController();
    const chatTimeout = setTimeout(() => chatController.abort(), 120000); // 2min max

    const chatRes = await fetch(API_BASE + '/api/chat/kingston', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Auth-Token': AUTH_TOKEN,
      },
      body: JSON.stringify({ message: text }),
      signal: chatController.signal,
    });
    clearTimeout(chatTimeout);

    if (!chatRes.ok) throw new Error('Chat API error: ' + chatRes.status);
    const chatData = await chatRes.json();
    const response = chatData.response || 'Desole, je n\'ai pas pu repondre.';

    addMsg('model', response);

    // 2. Convert response to speech via Edge TTS
    setStatus('speaking', 'Kingston parle...');
    wakeText.textContent = 'Synthese vocale...';

    const ttsController = new AbortController();
    const ttsTimeout = setTimeout(() => ttsController.abort(), 30000); // 30s max

    const ttsRes = await fetch(API_BASE + '/api/tts', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Auth-Token': AUTH_TOKEN,
      },
      body: JSON.stringify({ text: response.slice(0, 2000), voice: 'fr-male' }),
      signal: ttsController.signal,
    });
    clearTimeout(ttsTimeout);

    if (ttsRes.ok) {
      const mp3Blob = await ttsRes.blob();
      const audioUrl = URL.createObjectURL(mp3Blob);
      localAudio = new Audio(audioUrl);

      await new Promise((resolve) => {
        localAudio.onended = () => {
          URL.revokeObjectURL(audioUrl);
          localAudio = null;
          resolve();
        };
        localAudio.onerror = () => {
          URL.revokeObjectURL(audioUrl);
          localAudio = null;
          resolve();
        };
        localAudio.play().catch(() => resolve());
      });
    } else {
      console.warn('TTS failed:', ttsRes.status);
    }

  } catch (err) {
    console.error('Local processing error:', err);
    if (err.name === 'AbortError') {
      addMsg('system', 'Timeout — Kingston met trop de temps.');
    } else {
      addMsg('system', 'Erreur: ' + (err.message || 'echec'));
    }
  }

  // 3. Resume listening
  localProcessing = false;
  if (sessionActive) {
    startLocalListening();
  }
}

function stopLocalSession() {
  sessionActive = false;
  localProcessing = false;
  localFinalText = '';
  clearTimeout(localSilenceTimer);

  // Stop local listening
  stopLocalListening();

  // Stop any playing audio
  if (localAudio) {
    try { localAudio.pause(); } catch {}
    localAudio = null;
  }

  // Resume wake word if enabled
  if (wakeWordEnabled) {
    setTimeout(() => {
      if (!sessionActive) {
        startWakeWord();
        setStatus('wakeword', 'Dis "Kingston"...');
      }
    }, 500);
  } else {
    setStatus('disconnected', 'Deconnecte');
  }
}

// ═══════════════════════════════════════════════════════
// WebSocket connection (Gemini Live — Cloud mode)
// ═══════════════════════════════════════════════════════
function connectWS() {
  if (ws) return;
  setStatus('connecting', 'Connexion...');

  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    ws.send(JSON.stringify({
      type: 'auth',
      token: AUTH_TOKEN,
      voice: 'Enceladus',
      language: 'fr',
    }));
    setStatus('connecting', 'Authentification...');
  };

  ws.onmessage = (evt) => {
    let msg;
    try { msg = JSON.parse(evt.data); } catch { return; }
    handleServerMessage(msg);
  };

  ws.onerror = () => {
    addMsg('system', 'Erreur de connexion WebSocket.');
  };

  ws.onclose = () => {
    ws = null;
    if (sessionActive) {
      addMsg('system', 'Connexion perdue.');
      stopSession();
    }
  };
}

function handleServerMessage(msg) {
  switch (msg.type) {
    case 'ready':
      setStatus('ready', 'Kingston ecoute...');
      addMsg('system', 'Connecte! Parle naturellement — Kingston t\'entend en temps reel.');
      startMic();
      break;

    case 'audio':
      playAudioChunk(msg.data);
      if (!isSpeaking) {
        isSpeaking = true;
        setStatus('speaking', 'Kingston parle...');
      }
      break;

    case 'transcript':
      if (msg.role === 'model') {
        if (!currentTranscriptEl || currentTranscriptEl.dataset.role !== 'model') {
          currentTranscriptEl = addMsg('model', msg.text);
          currentTranscriptEl.dataset.role = 'model';
          currentTranscriptEl._rawText = msg.text;
        } else {
          // Append streaming text then re-render rich content
          currentTranscriptEl._rawText = (currentTranscriptEl._rawText || '') + msg.text;
          const contentDiv = currentTranscriptEl.querySelector('div:last-child');
          if (contentDiv) contentDiv.innerHTML = renderRichText(currentTranscriptEl._rawText);
          transcript.scrollTop = transcript.scrollHeight;
        }
      } else {
        currentTranscriptEl = addMsg('user', msg.text);
        currentTranscriptEl.dataset.role = 'user';
      }
      break;

    case 'interrupted':
      stopPlayback();
      isSpeaking = false;
      setStatus('ready', 'Kingston ecoute...');
      currentTranscriptEl = null;
      break;

    case 'turn_complete':
      isSpeaking = false;
      setStatus('ready', 'Kingston ecoute...');
      currentTranscriptEl = null;
      break;

    case 'tool':
      if (msg.status === 'calling') {
        addMsg('tool', '> ' + msg.name + '...');
      } else if (msg.status === 'done') {
        addMsg('tool', '< ' + msg.name + ': ' + (msg.result || '').slice(0, 200));
      }
      break;

    case 'session_closed':
      addMsg('system', 'Session Gemini expiree — reconnexion automatique...');
      // Auto-reconnect: close current WS, reopen after short delay
      if (ws) { try { ws.close(); } catch {} ws = null; }
      stopMic(); stopPlayback();
      isSpeaking = false;
      currentTranscriptEl = null;
      setTimeout(() => {
        if (sessionActive) {
          setStatus('connecting', 'Reconnexion...');
          connectWS();
        }
      }, 1500);
      break;

    case 'error':
      addMsg('system', 'Erreur: ' + msg.message);
      break;
  }
}

// ═══════════════════════════════════════════════════════
// Microphone capture → PCM 16kHz mono int16 → base64
// ═══════════════════════════════════════════════════════
async function startMic() {
  try {
    audioCtx = new AudioContext({ sampleRate: 16000 });
    if (audioCtx.state === 'suspended') await audioCtx.resume();

    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { channelCount: 1, sampleRate: 16000, echoCancellation: true, noiseSuppression: true },
    });

    const workletCode = `
      class PCMSender extends AudioWorkletProcessor {
        constructor() {
          super();
          this.buffer = [];
        }
        process(inputs) {
          const ch = inputs[0]?.[0];
          if (!ch) return true;
          for (let i = 0; i < ch.length; i++) this.buffer.push(ch[i]);
          if (this.buffer.length >= 1600) {
            const f32 = new Float32Array(this.buffer.splice(0, 1600));
            this.port.postMessage(f32);
          }
          return true;
        }
      }
      registerProcessor('pcm-sender', PCMSender);
    `;
    const blob = new Blob([workletCode], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(blobUrl);
    URL.revokeObjectURL(blobUrl);

    const source = audioCtx.createMediaStreamSource(micStream);
    workletNode = new AudioWorkletNode(audioCtx, 'pcm-sender');

    workletNode.port.onmessage = (e) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      const float32 = e.data;
      const int16 = new Int16Array(float32.length);
      for (let i = 0; i < float32.length; i++) {
        int16[i] = Math.max(-32768, Math.min(32767, Math.round(float32[i] * 32767)));
      }
      const bytes = new Uint8Array(int16.buffer);
      let binary = '';
      for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
      ws.send(JSON.stringify({ type: 'audio', data: btoa(binary) }));
    };

    source.connect(workletNode);
    workletNode.connect(audioCtx.destination);
  } catch (err) {
    console.warn('AudioWorklet failed, using ScriptProcessor fallback:', err);
    await startMicFallback();
  }
}

async function startMicFallback() {
  audioCtx = new AudioContext();
  if (audioCtx.state === 'suspended') await audioCtx.resume();

  micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const source = audioCtx.createMediaStreamSource(micStream);
  const processor = audioCtx.createScriptProcessor(4096, 1, 1);

  const nativeSR = audioCtx.sampleRate;
  const targetSR = 16000;
  const ratio = nativeSR / targetSR;

  processor.onaudioprocess = (e) => {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    const input = e.inputBuffer.getChannelData(0);
    const len = Math.floor(input.length / ratio);
    const int16 = new Int16Array(len);
    for (let i = 0; i < len; i++) {
      const sample = input[Math.round(i * ratio)];
      int16[i] = Math.max(-32768, Math.min(32767, Math.round(sample * 32767)));
    }
    const bytes = new Uint8Array(int16.buffer);
    let binary = '';
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    ws.send(JSON.stringify({ type: 'audio', data: btoa(binary) }));
  };

  source.connect(processor);
  processor.connect(audioCtx.destination);
}

function stopMic() {
  if (workletNode) { workletNode.disconnect(); workletNode = null; }
  if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
  if (audioCtx) { audioCtx.close().catch(() => {}); audioCtx = null; }
}

// ═══════════════════════════════════════════════════════
// Audio playback — PCM 24kHz from Gemini
// ═══════════════════════════════════════════════════════
function ensurePlayCtx() {
  if (!playCtx) {
    playCtx = new AudioContext({ sampleRate: 24000 });
  }
  if (playCtx.state === 'suspended') playCtx.resume();
}

function playAudioChunk(base64Pcm24k) {
  ensurePlayCtx();

  const raw = atob(base64Pcm24k);
  const bytes = new Uint8Array(raw.length);
  for (let i = 0; i < raw.length; i++) bytes[i] = raw.charCodeAt(i);
  const int16 = new Int16Array(bytes.buffer);
  const float32 = new Float32Array(int16.length);
  for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 32768;

  const buffer = playCtx.createBuffer(1, float32.length, 24000);
  buffer.getChannelData(0).set(float32);

  const source = playCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(playCtx.destination);

  const now = playCtx.currentTime;
  const startAt = Math.max(now + 0.01, nextPlayTime);
  source.start(startAt);
  nextPlayTime = startAt + buffer.duration;

  playQueue.push(source);
  source.onended = () => {
    const idx = playQueue.indexOf(source);
    if (idx >= 0) playQueue.splice(idx, 1);
  };
}

function stopPlayback() {
  playQueue.forEach(s => { try { s.stop(); } catch {} });
  playQueue = [];
  nextPlayTime = 0;
}

// ═══════════════════════════════════════════════════════
// Webcam + Vision
// ═══════════════════════════════════════════════════════
async function toggleCam() {
  if (webcamOn) {
    camVideo.srcObject?.getTracks().forEach(t => t.stop());
    camVideo.srcObject = null;
    webcamOn = false;
    camBox.classList.add('hidden');
    document.getElementById('camBtn').classList.remove('on');
    if (visionOn) toggleVision();
  } else {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: { ideal: 640 }, height: { ideal: 480 } }, audio: false,
      });
      camVideo.srcObject = stream;
      webcamOn = true;
      camBox.classList.remove('hidden');
      document.getElementById('camBtn').classList.add('on');
    } catch (e) {
      addMsg('system', 'Webcam non disponible: ' + e.message);
    }
  }
}

function toggleVision() {
  visionOn = !visionOn;
  document.getElementById('visionBtn').classList.toggle('on', visionOn);
  camBox.classList.toggle('vision', visionOn);
  camTag.textContent = visionOn ? 'Vision active' : 'Webcam';

  if (visionOn) {
    if (!webcamOn) toggleCam();
    visionInterval = setInterval(sendVisionFrame, 5000);
    sendVisionFrame();
  } else {
    if (visionInterval) { clearInterval(visionInterval); visionInterval = null; }
  }
}

function sendVisionFrame() {
  if (!ws || ws.readyState !== WebSocket.OPEN || !webcamOn || !visionOn) return;
  if (!camVideo.videoWidth) return;

  camCanvas.width = Math.min(camVideo.videoWidth, 640);
  camCanvas.height = Math.min(camVideo.videoHeight, 480);
  camCanvas.getContext('2d').drawImage(camVideo, 0, 0, camCanvas.width, camCanvas.height);

  const dataUrl = camCanvas.toDataURL('image/jpeg', 0.6);
  ws.send(JSON.stringify({ type: 'image', data: dataUrl }));

  camBox.style.borderColor = '#a78bfa';
  setTimeout(() => { camBox.style.borderColor = ''; }, 300);
}

// ═══════════════════════════════════════════════════════
// Session management — dispatches to local or cloud
// ═══════════════════════════════════════════════════════
function startSession() {
  if (sessionActive) return;
  if (voiceMode === 'local') {
    startLocalSession();
    return;
  }
  sessionActive = true;

  // Stop wake word — Gemini takes over the mic
  stopWakeWord();
  connectWS();
}

function stopSession() {
  if (voiceMode === 'local') {
    stopLocalSession();
    return;
  }
  sessionActive = false;
  stopMic();
  stopPlayback();
  if (visionInterval) { clearInterval(visionInterval); visionInterval = null; }
  if (ws) { ws.close(); ws = null; }
  isSpeaking = false;
  currentTranscriptEl = null;

  // Resume wake word if enabled
  if (wakeWordEnabled) {
    setTimeout(() => {
      if (!sessionActive) {
        startWakeWord();
        setStatus('wakeword', 'Dis "Kingston"...');
      }
    }, 500);
  } else {
    setStatus('disconnected', 'Deconnecte');
  }
}

function toggleSession() {
  if (sessionActive) stopSession();
  else startSession();
}

// ═══════════════════════════════════════════════════════
// Text input — works in both modes
// ═══════════════════════════════════════════════════════
function sendText() {
  const text = textIn.value.trim();
  if (!text) return;
  textIn.value = '';

  if (voiceMode === 'local') {
    // In local mode, send directly to Kingston API
    processLocalUtterance(text);
    return;
  }

  // Cloud mode — send via WebSocket
  if (!sessionActive) {
    startSession();
    const waitAndSend = setInterval(() => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        clearInterval(waitAndSend);
        addMsg('user', text);
        ws.send(JSON.stringify({ type: 'text', text }));
      }
    }, 200);
    setTimeout(() => clearInterval(waitAndSend), 10000);
    return;
  }

  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  addMsg('user', text);
  ws.send(JSON.stringify({ type: 'text', text }));
}

// ═══════════════════════════════════════════════════════
// Event listeners
// ═══════════════════════════════════════════════════════
mainBtn.addEventListener('click', toggleSession);
wakeBtn.addEventListener('click', toggleWakeWord);
modeBtn.addEventListener('click', toggleMode);
document.getElementById('camBtn').addEventListener('click', toggleCam);
document.getElementById('visionBtn').addEventListener('click', toggleVision);

textIn.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendText();
  }
});
document.getElementById('textSend').addEventListener('click', sendText);

// Escape = stop session (wake word resumes if enabled)
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && sessionActive) {
    stopSession();
    addMsg('system', 'Session arretee.');
  }
});

// ── PWA: Service Worker ──
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(() => {});
}

// ── PWA: Install prompt ──
let deferredInstallPrompt = null;
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredInstallPrompt = e;
  const installBtn = document.createElement('button');
  installBtn.className = 'ctrl';
  installBtn.innerHTML = '&#x1F4E5; Installer';
  installBtn.title = 'Installer Kingston Voice comme application';
  installBtn.addEventListener('click', async () => {
    if (!deferredInstallPrompt) return;
    deferredInstallPrompt.prompt();
    const result = await deferredInstallPrompt.userChoice;
    if (result.outcome === 'accepted') {
      addMsg('system', 'Kingston Voice installe! Tu peux fermer cet onglet.');
      installBtn.remove();
    }
    deferredInstallPrompt = null;
  });
  document.querySelector('.btn-row').appendChild(installBtn);
});

// ── Init ──
updateModeUI();

// Auto-enable wake word if Web Speech API is available
if (hasWebSpeech()) {
  wakeWordEnabled = true;
  wakeBtn.classList.add('on');
  startWakeWord();
} else {
  setStatus('disconnected', 'Pret — appuie sur le micro pour commencer');
}
</script>
</body>
</html>
