<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kingston Voice â€” Gemini Live</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #0a0a0f;
    color: #e0e0e0;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 20px;
    background: #111118;
    border-bottom: 1px solid #222;
  }
  .header h1 { font-size: 18px; font-weight: 600; }
  .header h1 span { color: #6c8cff; }
  .header-right { display: flex; gap: 10px; align-items: center; }
  .status-dot {
    width: 10px; height: 10px; border-radius: 50%;
    display: inline-block; transition: background 0.3s;
  }
  .status-dot.disconnected { background: #666; }
  .status-dot.connecting { background: #ff9800; animation: blink 1s infinite; }
  .status-dot.ready { background: #4caf50; }
  .status-dot.listening { background: #ff9800; animation: blink 0.6s infinite; }
  .status-dot.speaking { background: #6c8cff; animation: blink 1.2s infinite; }
  @keyframes blink { 50% { opacity: 0.3; } }
  #statusLabel { font-size: 13px; color: #888; }

  .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }

  /* Webcam */
  .webcam-box {
    position: absolute; top: 10px; right: 16px;
    width: 180px; height: 135px; border-radius: 10px;
    overflow: hidden; border: 2px solid #333; background: #000;
    z-index: 10; transition: border-color 0.3s;
  }
  .webcam-box.hidden { display: none; }
  .webcam-box.vision { border-color: #a78bfa; }
  .webcam-box video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
  .webcam-tag {
    position: absolute; bottom: 4px; left: 6px;
    font-size: 10px; background: rgba(0,0,0,0.7); padding: 2px 6px;
    border-radius: 4px; color: #aaa;
  }

  /* Transcript */
  .transcript {
    flex: 1; overflow-y: auto; padding: 20px;
    display: flex; flex-direction: column; gap: 10px;
  }
  .msg {
    max-width: 80%; padding: 10px 14px; border-radius: 12px;
    font-size: 15px; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word;
  }
  .msg.user { align-self: flex-end; background: #1a3a6a; border-bottom-right-radius: 4px; }
  .msg.model { align-self: flex-start; background: #1e1e2a; border-bottom-left-radius: 4px; }
  .msg.system { align-self: center; color: #666; font-size: 13px; font-style: italic; }
  .msg.tool {
    align-self: flex-start; background: #1a1a2e; border-left: 3px solid #6c8cff;
    font-size: 13px; color: #aaa; max-width: 90%;
  }
  .msg .lbl {
    font-size: 10px; color: #666; margin-bottom: 3px;
    text-transform: uppercase; font-weight: 600;
  }

  /* Controls */
  .controls {
    padding: 14px 20px 22px;
    display: flex; flex-direction: column; align-items: center; gap: 10px;
    background: #111118; border-top: 1px solid #222;
  }
  .big-btn {
    width: 80px; height: 80px; border-radius: 50%;
    border: 3px solid #333; background: #1a1a24;
    cursor: pointer; display: flex; align-items: center; justify-content: center;
    font-size: 32px; transition: all 0.2s; position: relative;
  }
  .big-btn:hover { border-color: #6c8cff; }
  .big-btn.active { border-color: #4caf50; background: #0a2a0a; animation: glow 2s infinite; }
  .big-btn.speaking { border-color: #6c8cff; background: #0a0a2a; }
  @keyframes glow { 50% { box-shadow: 0 0 20px rgba(76,175,80,0.3); } }

  .btn-row { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
  .ctrl {
    padding: 6px 12px; border-radius: 6px; border: 1px solid #333;
    background: #1a1a24; color: #aaa; cursor: pointer; font-size: 12px;
    transition: all 0.2s;
  }
  .ctrl:hover { border-color: #6c8cff; color: #fff; }
  .ctrl.on { border-color: #4caf50; color: #4caf50; }

  .text-row { display: flex; gap: 8px; width: 100%; max-width: 600px; }
  .text-row input {
    flex: 1; padding: 10px 14px; border-radius: 8px; border: 1px solid #333;
    background: #1a1a24; color: #e0e0e0; font-size: 14px; outline: none;
  }
  .text-row input:focus { border-color: #6c8cff; }
  .text-row button {
    padding: 10px 16px; border-radius: 8px; border: none;
    background: #6c8cff; color: #fff; cursor: pointer; font-size: 14px; font-weight: 600;
  }
  .hint { color: #555; font-size: 11px; }

  canvas { display: none; }
</style>
</head>
<body>

<div class="header">
  <h1><span>Kingston</span> Voice <small style="font-size:11px;color:#555;margin-left:6px">Gemini Live</small></h1>
  <div class="header-right">
    <span class="status-dot disconnected" id="dot"></span>
    <span id="statusLabel">DÃ©connectÃ©</span>
  </div>
</div>

<div class="main">
  <div class="webcam-box hidden" id="camBox">
    <video id="camVideo" autoplay playsinline muted></video>
    <canvas id="camCanvas"></canvas>
    <div class="webcam-tag" id="camTag">Webcam</div>
  </div>
  <div class="transcript" id="transcript">
    <div class="msg system">Appuie sur le bouton pour dÃ©marrer la conversation. Kingston te parle en temps rÃ©el via Gemini Live.</div>
  </div>
</div>

<div class="controls">
  <button class="big-btn" id="mainBtn" title="DÃ©marrer / ArrÃªter">ğŸ¤</button>
  <div class="btn-row">
    <button class="ctrl" id="camBtn">ğŸ“· Webcam</button>
    <button class="ctrl" id="visionBtn">ğŸ‘ Vision</button>
  </div>
  <div class="text-row">
    <input id="textIn" placeholder="Ou tape ton message..." />
    <button id="textSend">Envoyer</button>
  </div>
  <div class="hint">Gemini Live â€” conversation naturelle en temps rÃ©el &nbsp;|&nbsp; Escape = stop &nbsp;|&nbsp; La voix c'est mieux!</div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Kingston Voice â€” Gemini Live (WebSocket + PCM audio)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const API_BASE = window.location.origin;
const WS_URL = API_BASE.replace(/^http/, 'ws') + '/ws/voice';
const AUTH_TOKEN = localStorage.getItem('bastilon_token') || '';

// Auth prompt
if (!AUTH_TOKEN) {
  const t = prompt('Token Bastilon (DASHBOARD_TOKEN):');
  if (t) { localStorage.setItem('bastilon_token', t); location.reload(); }
}

// â”€â”€â”€ State â”€â”€â”€
let ws = null;
let sessionActive = false;
let micStream = null;
let audioCtx = null;
let workletNode = null;
let playCtx = null;          // separate context for playback
let nextPlayTime = 0;        // scheduler for gapless playback
let playQueue = [];           // queued AudioBufferSourceNodes
let webcamOn = false;
let visionOn = false;
let visionInterval = null;
let currentTranscriptEl = null;  // for streaming model text
let isSpeaking = false;

// â”€â”€â”€ DOM â”€â”€â”€
const dot = document.getElementById('dot');
const statusLabel = document.getElementById('statusLabel');
const transcript = document.getElementById('transcript');
const mainBtn = document.getElementById('mainBtn');
const textIn = document.getElementById('textIn');
const camVideo = document.getElementById('camVideo');
const camCanvas = document.getElementById('camCanvas');
const camBox = document.getElementById('camBox');
const camTag = document.getElementById('camTag');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Status
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setStatus(state, label) {
  dot.className = 'status-dot ' + state;
  statusLabel.textContent = label;
  if (state === 'ready' || state === 'listening') {
    mainBtn.className = 'big-btn active';
    mainBtn.textContent = 'ğŸ”´';
  } else if (state === 'speaking') {
    mainBtn.className = 'big-btn speaking';
    mainBtn.textContent = 'ğŸ”Š';
  } else {
    mainBtn.className = 'big-btn';
    mainBtn.textContent = 'ğŸ¤';
  }
}

function addMsg(role, text) {
  const div = document.createElement('div');
  div.className = 'msg ' + role;
  if (role === 'user' || role === 'model') {
    const lbl = document.createElement('div');
    lbl.className = 'lbl';
    lbl.textContent = role === 'user' ? 'Toi' : 'Kingston';
    div.appendChild(lbl);
  }
  const span = document.createElement('span');
  span.textContent = text;
  div.appendChild(span);
  transcript.appendChild(div);
  transcript.scrollTop = transcript.scrollHeight;
  return div;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WebSocket connection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function connectWS() {
  if (ws) return;
  setStatus('connecting', 'Connexion...');

  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    // Send auth + config
    ws.send(JSON.stringify({
      type: 'auth',
      token: AUTH_TOKEN,
      voice: 'Enceladus',
      language: 'fr',
    }));
    setStatus('connecting', 'Authentification...');
  };

  ws.onmessage = (evt) => {
    let msg;
    try { msg = JSON.parse(evt.data); } catch { return; }
    handleServerMessage(msg);
  };

  ws.onerror = () => {
    addMsg('system', 'Erreur de connexion WebSocket.');
  };

  ws.onclose = () => {
    ws = null;
    if (sessionActive) {
      addMsg('system', 'Connexion perdue. Appuie sur le bouton pour reconnecter.');
      stopSession();
    }
    setStatus('disconnected', 'DÃ©connectÃ©');
  };
}

function handleServerMessage(msg) {
  switch (msg.type) {
    case 'ready':
      setStatus('ready', 'Kingston Ã©coute...');
      addMsg('system', 'ConnectÃ©! Parle naturellement â€” Kingston t\'entend en temps rÃ©el.');
      startMic();
      break;

    case 'audio':
      playAudioChunk(msg.data);
      if (!isSpeaking) {
        isSpeaking = true;
        setStatus('speaking', 'Kingston parle...');
      }
      break;

    case 'transcript':
      if (msg.role === 'model') {
        // Append to current model message or create new
        if (!currentTranscriptEl || currentTranscriptEl.dataset.role !== 'model') {
          currentTranscriptEl = addMsg('model', msg.text);
          currentTranscriptEl.dataset.role = 'model';
        } else {
          const span = currentTranscriptEl.querySelector('span');
          if (span) span.textContent += msg.text;
          transcript.scrollTop = transcript.scrollHeight;
        }
      } else {
        currentTranscriptEl = addMsg('user', msg.text);
        currentTranscriptEl.dataset.role = 'user';
      }
      break;

    case 'interrupted':
      stopPlayback();
      isSpeaking = false;
      setStatus('ready', 'Kingston Ã©coute...');
      currentTranscriptEl = null;
      break;

    case 'turn_complete':
      isSpeaking = false;
      setStatus('ready', 'Kingston Ã©coute...');
      currentTranscriptEl = null;
      break;

    case 'tool':
      if (msg.status === 'calling') {
        addMsg('tool', `ğŸ”§ ${msg.name}...`);
      } else if (msg.status === 'done') {
        addMsg('tool', `âœ“ ${msg.name}: ${(msg.result || '').slice(0, 200)}`);
      }
      break;

    case 'session_closed':
      addMsg('system', 'Session Gemini expirÃ©e â€” reconnexion...');
      break;

    case 'error':
      addMsg('system', 'Erreur: ' + msg.message);
      break;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Microphone capture â†’ PCM 16kHz mono int16 â†’ base64
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function startMic() {
  try {
    audioCtx = new AudioContext({ sampleRate: 16000 });
    // Resume if suspended (Chrome autoplay policy)
    if (audioCtx.state === 'suspended') await audioCtx.resume();

    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { channelCount: 1, sampleRate: 16000, echoCancellation: true, noiseSuppression: true },
    });

    // AudioWorklet for low-latency capture
    const workletCode = `
      class PCMSender extends AudioWorkletProcessor {
        constructor() {
          super();
          this.buffer = [];
        }
        process(inputs) {
          const ch = inputs[0]?.[0];
          if (!ch) return true;
          // Accumulate ~100ms of audio at 16kHz = 1600 samples
          for (let i = 0; i < ch.length; i++) this.buffer.push(ch[i]);
          if (this.buffer.length >= 1600) {
            const f32 = new Float32Array(this.buffer.splice(0, 1600));
            this.port.postMessage(f32);
          }
          return true;
        }
      }
      registerProcessor('pcm-sender', PCMSender);
    `;
    const blob = new Blob([workletCode], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(blobUrl);
    URL.revokeObjectURL(blobUrl);

    const source = audioCtx.createMediaStreamSource(micStream);
    workletNode = new AudioWorkletNode(audioCtx, 'pcm-sender');

    workletNode.port.onmessage = (e) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      const float32 = e.data;
      // Float32 â†’ Int16
      const int16 = new Int16Array(float32.length);
      for (let i = 0; i < float32.length; i++) {
        int16[i] = Math.max(-32768, Math.min(32767, Math.round(float32[i] * 32767)));
      }
      // Int16 â†’ base64
      const bytes = new Uint8Array(int16.buffer);
      let binary = '';
      for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
      const b64 = btoa(binary);
      ws.send(JSON.stringify({ type: 'audio', data: b64 }));
    };

    source.connect(workletNode);
    workletNode.connect(audioCtx.destination); // needed to keep the worklet alive
  } catch (err) {
    // Fallback: ScriptProcessorNode (deprecated but wider support)
    console.warn('AudioWorklet failed, using ScriptProcessor fallback:', err);
    await startMicFallback();
  }
}

async function startMicFallback() {
  audioCtx = new AudioContext();
  if (audioCtx.state === 'suspended') await audioCtx.resume();

  micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const source = audioCtx.createMediaStreamSource(micStream);
  const processor = audioCtx.createScriptProcessor(4096, 1, 1);

  const nativeSR = audioCtx.sampleRate;
  const targetSR = 16000;
  const ratio = nativeSR / targetSR;

  processor.onaudioprocess = (e) => {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    const input = e.inputBuffer.getChannelData(0);
    // Downsample
    const len = Math.floor(input.length / ratio);
    const int16 = new Int16Array(len);
    for (let i = 0; i < len; i++) {
      const sample = input[Math.round(i * ratio)];
      int16[i] = Math.max(-32768, Math.min(32767, Math.round(sample * 32767)));
    }
    const bytes = new Uint8Array(int16.buffer);
    let binary = '';
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    ws.send(JSON.stringify({ type: 'audio', data: btoa(binary) }));
  };

  source.connect(processor);
  processor.connect(audioCtx.destination);
}

function stopMic() {
  if (workletNode) { workletNode.disconnect(); workletNode = null; }
  if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
  if (audioCtx) { audioCtx.close().catch(() => {}); audioCtx = null; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Audio playback â€” PCM 24kHz from Gemini
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function ensurePlayCtx() {
  if (!playCtx) {
    playCtx = new AudioContext({ sampleRate: 24000 });
  }
  if (playCtx.state === 'suspended') playCtx.resume();
}

function playAudioChunk(base64Pcm24k) {
  ensurePlayCtx();

  // Base64 â†’ Uint8Array â†’ Int16Array â†’ Float32Array
  const raw = atob(base64Pcm24k);
  const bytes = new Uint8Array(raw.length);
  for (let i = 0; i < raw.length; i++) bytes[i] = raw.charCodeAt(i);
  const int16 = new Int16Array(bytes.buffer);
  const float32 = new Float32Array(int16.length);
  for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 32768;

  // Create buffer and schedule for gapless playback
  const buffer = playCtx.createBuffer(1, float32.length, 24000);
  buffer.getChannelData(0).set(float32);

  const source = playCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(playCtx.destination);

  const now = playCtx.currentTime;
  const startAt = Math.max(now + 0.01, nextPlayTime);
  source.start(startAt);
  nextPlayTime = startAt + buffer.duration;

  playQueue.push(source);
  // Clean up old refs
  source.onended = () => {
    const idx = playQueue.indexOf(source);
    if (idx >= 0) playQueue.splice(idx, 1);
  };
}

function stopPlayback() {
  playQueue.forEach(s => { try { s.stop(); } catch {} });
  playQueue = [];
  nextPlayTime = 0;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Webcam + Vision
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function toggleCam() {
  if (webcamOn) {
    camVideo.srcObject?.getTracks().forEach(t => t.stop());
    camVideo.srcObject = null;
    webcamOn = false;
    camBox.classList.add('hidden');
    document.getElementById('camBtn').classList.remove('on');
    if (visionOn) toggleVision();
  } else {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: { ideal: 640 }, height: { ideal: 480 } }, audio: false,
      });
      camVideo.srcObject = stream;
      webcamOn = true;
      camBox.classList.remove('hidden');
      document.getElementById('camBtn').classList.add('on');
    } catch (e) {
      addMsg('system', 'Webcam non disponible: ' + e.message);
    }
  }
}

function toggleVision() {
  visionOn = !visionOn;
  document.getElementById('visionBtn').classList.toggle('on', visionOn);
  camBox.classList.toggle('vision', visionOn);
  camTag.textContent = visionOn ? 'Vision active' : 'Webcam';

  if (visionOn) {
    if (!webcamOn) toggleCam();
    // Send a frame every 5 seconds
    visionInterval = setInterval(sendVisionFrame, 5000);
    sendVisionFrame(); // send one immediately
  } else {
    if (visionInterval) { clearInterval(visionInterval); visionInterval = null; }
  }
}

function sendVisionFrame() {
  if (!ws || ws.readyState !== WebSocket.OPEN || !webcamOn || !visionOn) return;
  if (!camVideo.videoWidth) return;

  camCanvas.width = Math.min(camVideo.videoWidth, 640);
  camCanvas.height = Math.min(camVideo.videoHeight, 480);
  camCanvas.getContext('2d').drawImage(camVideo, 0, 0, camCanvas.width, camCanvas.height);

  const dataUrl = camCanvas.toDataURL('image/jpeg', 0.6);
  ws.send(JSON.stringify({ type: 'image', data: dataUrl }));

  // Flash border
  camBox.style.borderColor = '#a78bfa';
  setTimeout(() => { camBox.style.borderColor = ''; }, 300);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Session management
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startSession() {
  if (sessionActive) return;
  sessionActive = true;
  connectWS();
}

function stopSession() {
  sessionActive = false;
  stopMic();
  stopPlayback();
  if (visionInterval) { clearInterval(visionInterval); visionInterval = null; }
  if (ws) { ws.close(); ws = null; }
  isSpeaking = false;
  currentTranscriptEl = null;
  setStatus('disconnected', 'DÃ©connectÃ©');
}

function toggleSession() {
  if (sessionActive) stopSession();
  else startSession();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Event listeners
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
mainBtn.addEventListener('click', toggleSession);
document.getElementById('camBtn').addEventListener('click', toggleCam);
document.getElementById('visionBtn').addEventListener('click', toggleVision);

textIn.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendText();
  }
});
document.getElementById('textSend').addEventListener('click', sendText);

function sendText() {
  const text = textIn.value.trim();
  if (!text || !ws || ws.readyState !== WebSocket.OPEN) return;
  textIn.value = '';
  addMsg('user', text);
  ws.send(JSON.stringify({ type: 'text', text }));
}

// Escape = stop everything
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && sessionActive) {
    stopSession();
    addMsg('system', 'Session arrÃªtÃ©e.');
  }
});

// Init
setStatus('disconnected', 'PrÃªt â€” appuie sur le micro pour commencer');
</script>
</body>
</html>
