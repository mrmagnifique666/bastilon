<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Maitre du Donjon — Kingston</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700;800;900&family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400;1,600&display=swap" rel="stylesheet">
<style>
:root {
  --bg-deep: #080810;
  --bg: #0e0e1a;
  --bg-surface: #141428;
  --bg-card: #1a1a35;
  --bg-elevated: #242450;
  --border: rgba(255,255,255,0.07);
  --border-accent: rgba(212,168,67,0.35);
  --text: #e2e8f0;
  --text-dim: #94a3b8;
  --text-muted: #475569;
  --gold: #d4a843;
  --gold-light: #f0d78c;
  --gold-dark: #9e7b22;
  --purple: #8b5cf6;
  --purple-dim: rgba(139,92,246,0.15);
  --red: #ef4444;
  --green: #22c55e;
  --blue: #3b82f6;
  --radius: 10px;
  --shadow: 0 4px 24px rgba(0,0,0,0.4);
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; }
body {
  font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;
  background: var(--bg-deep);
  color: var(--text);
}
body::after {
  content: '';
  position: fixed;
  inset: 0;
  background: radial-gradient(ellipse at 20% 50%, rgba(139,92,246,0.06) 0%, transparent 60%),
              radial-gradient(ellipse at 80% 20%, rgba(212,168,67,0.04) 0%, transparent 50%);
  pointer-events: none;
  z-index: 0;
}
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.2); }

.cinzel { font-family: 'Cinzel', serif; }
.crimson { font-family: 'Crimson Text', Georgia, serif; }
a { color: var(--gold); text-decoration: none; }

/* === VIEWS === */
.view { display: none; position: relative; z-index: 1; height: 100vh; }
.view.active { display: flex; }
@keyframes fadeSlideIn { from { opacity:0; transform:translateY(16px); } to { opacity:1; transform:translateY(0); } }
.fade-in { animation: fadeSlideIn 0.5s ease-out; }

/* === BUTTONS === */
.btn {
  font-family: 'Cinzel', serif; font-weight: 600; border: none; cursor: pointer;
  transition: all 0.2s; letter-spacing: 0.5px; border-radius: var(--radius);
}
.btn-gold {
  background: linear-gradient(135deg, var(--gold), var(--gold-dark));
  color: #0e0e1a; padding: 12px 28px; font-size: 15px;
  box-shadow: 0 2px 12px rgba(212,168,67,0.25);
}
.btn-gold:hover { box-shadow: 0 4px 24px rgba(212,168,67,0.4); transform: translateY(-1px); }
.btn-gold:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
.btn-ghost {
  background: rgba(255,255,255,0.04); color: var(--text-dim); padding: 10px 20px;
  border: 1px solid var(--border); font-size: 13px;
}
.btn-ghost:hover { background: rgba(255,255,255,0.08); color: var(--text); }
.btn-danger { background: var(--red); color: #fff; padding: 8px 16px; font-size: 12px; }
.btn-small { padding: 6px 14px; font-size: 12px; }

/* === INPUTS === */
.input {
  font-family: inherit; font-size: 15px; padding: 12px 16px;
  background: rgba(255,255,255,0.04); border: 1px solid var(--border);
  border-radius: var(--radius); color: var(--text); outline: none; transition: border-color 0.2s;
}
.input:focus { border-color: var(--gold); }
.input::placeholder { color: var(--text-muted); }
select.input {
  appearance: none; cursor: pointer;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='8'%3E%3Cpath d='M1 1l5 5 5-5' stroke='%23d4a843' stroke-width='1.5' fill='none'/%3E%3C/svg%3E");
  background-repeat: no-repeat; background-position: right 12px center; padding-right: 32px;
}

/* === CARD === */
.card {
  background: var(--bg-card); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 20px; box-shadow: var(--shadow);
}

/* === TOAST === */
#toast {
  position: fixed; bottom: 24px; right: 24px; padding: 14px 24px;
  background: var(--red); color: #fff; border-radius: var(--radius);
  font-size: 14px; z-index: 9999; transform: translateY(100px); opacity: 0;
  transition: all 0.3s; font-family: 'Cinzel', serif;
}
#toast.show { transform: translateY(0); opacity: 1; }

/* === LIGHTBOX === */
#lightbox {
  position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 5000;
  display: flex; align-items: center; justify-content: center;
  opacity: 0; pointer-events: none; transition: opacity 0.3s; cursor: pointer;
}
#lightbox.show { opacity: 1; pointer-events: all; }
#lightbox img { max-width: 92vw; max-height: 92vh; border-radius: 8px; border: 2px solid var(--gold-dark); }

/* =========================================================
   LANDING VIEW
   ========================================================= */
#view-landing {
  flex-direction: column; align-items: center; justify-content: center;
  overflow-y: auto; padding: 40px 20px; gap: 16px;
}
.landing-icon { font-size: 64px; margin-bottom: 8px; }
.landing-title { font-family:'Cinzel',serif; font-size:42px; font-weight:800; letter-spacing:3px; color:var(--gold-light); text-shadow: 0 0 40px rgba(212,168,67,0.2); }
.landing-sub { font-size:16px; color:var(--text-dim); font-style:italic; margin-bottom:20px; font-family:'Crimson Text',serif; }
.campaigns-grid { width:100%; max-width:700px; display:flex; flex-direction:column; gap:10px; margin-bottom:20px; }
.camp-card {
  background:var(--bg-card); border:1px solid var(--border); border-radius:var(--radius);
  padding:16px 20px; cursor:pointer; transition:all 0.2s;
  display:flex; align-items:center; gap:16px;
}
.camp-card:hover { border-color:var(--gold-dark); transform:translateX(4px); }
.camp-card .icon { font-size:28px; }
.camp-card .info { flex:1; }
.camp-card .info h3 { font-family:'Cinzel',serif; font-size:15px; font-weight:700; color:var(--gold-light); }
.camp-card .info .meta { font-size:12px; color:var(--text-dim); margin-top:2px; }
.camp-card .del { background:none; border:none; color:var(--red); cursor:pointer; opacity:0.4; font-size:16px; padding:6px; }
.camp-card .del:hover { opacity:1; }
.empty-msg { color:var(--text-muted); font-style:italic; font-size:15px; padding:24px; text-align:center; }

/* =========================================================
   ONBOARDING WIZARD
   ========================================================= */
#view-onboarding {
  flex-direction:column; align-items:center; justify-content:center;
  overflow-y:auto; padding:40px 20px;
}
.wizard { width:100%; max-width:640px; }
.wizard-progress { display:flex; gap:6px; margin-bottom:28px; justify-content:center; }
.wizard-progress .dot {
  width:10px; height:10px; border-radius:50%; background:var(--border);
  transition: background 0.3s, box-shadow 0.3s;
}
.wizard-progress .dot.active { background:var(--gold); box-shadow:0 0 8px rgba(212,168,67,0.5); }
.wizard-progress .dot.done { background:var(--green); }
.step { display:none; }
.step.active { display:block; animation: fadeSlideIn 0.4s ease-out; }
.step-title { font-family:'Cinzel',serif; font-size:24px; font-weight:700; color:var(--gold-light); margin-bottom:8px; text-align:center; }
.step-desc { color:var(--text-dim); text-align:center; margin-bottom:24px; font-size:15px; }
.step-nav { display:flex; justify-content:space-between; margin-top:28px; }

/* Option cards grid */
.opt-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(140px,1fr)); gap:12px; }
.opt-card {
  background:var(--bg-surface); border:2px solid var(--border); border-radius:var(--radius);
  padding:20px 16px; text-align:center; cursor:pointer; transition:all 0.2s;
}
.opt-card:hover { border-color:var(--gold-dark); background:var(--bg-card); }
.opt-card.selected { border-color:var(--gold); background:rgba(212,168,67,0.08); box-shadow:0 0 16px rgba(212,168,67,0.15); }
.opt-card .opt-icon { font-size:32px; margin-bottom:8px; }
.opt-card .opt-label { font-family:'Cinzel',serif; font-size:14px; font-weight:700; color:var(--text); }
.opt-card .opt-desc { font-size:12px; color:var(--text-dim); margin-top:4px; }

/* Number picker */
.num-picker { display:flex; gap:12px; justify-content:center; flex-wrap:wrap; }
.num-btn {
  width:56px; height:56px; border-radius:50%; font-family:'Cinzel',serif; font-size:22px;
  font-weight:700; background:var(--bg-surface); border:2px solid var(--border); color:var(--text);
  cursor:pointer; transition:all 0.2s; display:flex; align-items:center; justify-content:center;
}
.num-btn:hover { border-color:var(--gold-dark); }
.num-btn.selected { border-color:var(--gold); background:rgba(212,168,67,0.12); color:var(--gold-light); box-shadow:0 0 16px rgba(212,168,67,0.2); }

/* Player name inputs */
.name-inputs { display:flex; flex-direction:column; gap:10px; }
.name-row { display:flex; align-items:center; gap:10px; }
.name-row .num { font-family:'Cinzel',serif; font-weight:700; color:var(--gold); width:24px; text-align:center; }
.name-row input { flex:1; }

/* Consent checkboxes */
.consent-list { display:flex; flex-direction:column; gap:10px; }
.consent-item { display:flex; align-items:center; gap:10px; font-size:14px; cursor:pointer; }
.consent-item input[type=checkbox] { accent-color: var(--gold); width:18px; height:18px; cursor:pointer; }

/* Character cards */
.char-cards { display:flex; flex-direction:column; gap:14px; }
.char-edit-card {
  background:var(--bg-surface); border:1px solid var(--border); border-radius:var(--radius);
  padding:16px; position:relative;
}
.char-edit-card h4 { font-family:'Cinzel',serif; font-size:15px; color:var(--gold-light); margin-bottom:10px; }
.char-field { margin-bottom:8px; }
.char-field label { display:block; font-size:11px; color:var(--text-dim); text-transform:uppercase; letter-spacing:0.5px; margin-bottom:3px; font-family:'Cinzel',serif; }
.char-field input, .char-field textarea {
  width:100%; font-size:14px; padding:8px 12px;
  background:rgba(255,255,255,0.03); border:1px solid var(--border);
  border-radius:6px; color:var(--text); outline:none; font-family:inherit;
}
.char-field textarea { resize:vertical; min-height:40px; }
.char-field input:focus, .char-field textarea:focus { border-color:var(--gold); }

/* Loading state */
.loading-state { text-align:center; padding:60px 20px; }
.loading-state .spinner { width:48px; height:48px; border:3px solid var(--border); border-top-color:var(--gold); border-radius:50%; animation:spin 0.8s linear infinite; margin:0 auto 16px; }
@keyframes spin { to { transform:rotate(360deg); } }
.loading-state p { color:var(--text-dim); font-style:italic; font-size:15px; }

/* =========================================================
   GAME VIEW — 3 PANEL LAYOUT
   ========================================================= */
#view-game { flex-direction:column; overflow:hidden; }
.game-header {
  padding:10px 20px; display:flex; align-items:center; gap:16px;
  border-bottom:1px solid var(--border); background:var(--bg-surface); flex-shrink:0;
}
.game-header h1 { font-family:'Cinzel',serif; font-size:16px; font-weight:700; color:var(--gold-light); white-space:nowrap; }
.game-header .meta { font-size:12px; color:var(--text-dim); display:flex; gap:12px; }
.game-header .spacer { flex:1; }
.game-header .controls { display:flex; gap:6px; }
.game-layout { flex:1; display:flex; overflow:hidden; }

/* Left Panel */
.panel-left {
  width:270px; border-right:1px solid var(--border); background:var(--bg);
  display:flex; flex-direction:column; flex-shrink:0; overflow:hidden;
}
.panel-tabs {
  display:flex; border-bottom:1px solid var(--border); flex-shrink:0;
}
.panel-tab {
  flex:1; padding:10px; text-align:center; font-size:12px; font-family:'Cinzel',serif;
  font-weight:600; color:var(--text-muted); cursor:pointer; border-bottom:2px solid transparent;
  transition:all 0.2s; background:none; border-top:none; border-left:none; border-right:none;
}
.panel-tab.active { color:var(--gold); border-bottom-color:var(--gold); }
.panel-tab:hover { color:var(--text-dim); }
.panel-content { flex:1; overflow-y:auto; padding:12px; }

/* Party cards */
.pc-card {
  background:var(--bg-surface); border:1px solid var(--border); border-radius:8px;
  padding:10px 12px; margin-bottom:8px; transition:border-color 0.2s;
}
.pc-card:hover { border-color:rgba(255,255,255,0.12); }
.pc-name { font-family:'Cinzel',serif; font-size:13px; font-weight:700; color:var(--gold-light); }
.pc-concept { font-size:11px; color:var(--text-dim); font-style:italic; margin:2px 0 6px; }
.pc-role { font-size:11px; color:var(--purple); font-weight:600; margin-bottom:4px; }
.pc-tags { display:flex; flex-wrap:wrap; gap:3px; margin-bottom:6px; }
.pc-tag { font-size:10px; padding:2px 6px; background:rgba(139,92,246,0.12); color:var(--purple); border-radius:3px; }
.pc-equip { font-size:11px; color:var(--text-dim); }
.pc-equip li { margin-left:12px; list-style:disc; }
.pc-detail { margin-top:4px; }
.pc-detail summary { font-size:11px; color:var(--text-muted); cursor:pointer; font-family:'Cinzel',serif; }

/* Journal */
.journal-section { margin-bottom:16px; }
.journal-section h4 { font-family:'Cinzel',serif; font-size:12px; color:var(--gold); margin-bottom:8px; letter-spacing:0.5px; }
.journal-entry { font-size:12px; color:var(--text-dim); padding:4px 0; border-bottom:1px solid var(--border); }
.journal-entry .q-name { color:var(--gold-light); font-weight:600; }
.journal-entry .q-status { font-size:10px; padding:1px 5px; border-radius:3px; margin-left:4px; }
.q-active { background:rgba(34,197,94,0.15); color:var(--green); }
.q-done { background:rgba(100,116,139,0.15); color:var(--text-muted); }
.npc-entry { display:flex; gap:6px; margin-bottom:6px; }
.npc-entry .npc-name { font-weight:600; color:var(--purple); font-size:12px; }
.npc-entry .npc-desc { font-size:11px; color:var(--text-dim); }
.timeline-entry { font-size:11px; color:var(--text-dim); padding:3px 0; }
.timeline-entry .tl-time { color:var(--text-muted); font-size:10px; }

/* Center Panel — Visual Stage */
.panel-stage {
  flex:1; display:flex; flex-direction:column; overflow:hidden; position:relative;
  background:var(--bg-deep); border-left:1px solid var(--border); border-right:1px solid var(--border);
}
.stage-main {
  flex:1; display:flex; align-items:center; justify-content:center; overflow:hidden;
  padding:12px; position:relative;
}
.stage-poster {
  width:100%; height:100%; border-radius:12px; overflow:hidden; position:relative;
  display:flex; align-items:center; justify-content:center;
  background:var(--bg-card); border:1px solid var(--border);
}
.stage-poster img {
  width:100%; height:100%; object-fit:cover; cursor:pointer; transition:transform 0.3s;
}
.stage-poster img:hover { transform:scale(1.02); }
.stage-poster .poster-overlay {
  position:absolute; bottom:0; left:0; right:0;
  background:linear-gradient(transparent, rgba(0,0,0,0.85));
  padding:20px; text-align:center;
}
.stage-poster .poster-title {
  font-family:'Cinzel',serif; font-size:28px; font-weight:800; color:var(--gold-light);
  text-shadow:0 2px 12px rgba(0,0,0,0.8); margin-bottom:6px;
}
.stage-poster .poster-sub {
  font-family:'Crimson Text',serif; font-size:16px; color:var(--text-dim);
  font-style:italic;
}
.poster-loading {
  color:var(--text-muted); font-family:'Cinzel',serif; font-size:14px;
  display:flex; align-items:center; gap:12px;
}
.stage-bar {
  flex-shrink:0; padding:8px 12px; border-top:1px solid var(--border);
  display:flex; align-items:center; gap:8px; background:var(--bg);
}
.stage-thumbs { flex:1; display:flex; gap:6px; overflow-x:auto; }
.stage-thumbs .thumb {
  width:52px; height:52px; border-radius:6px; overflow:hidden; flex-shrink:0;
  border:2px solid var(--border); cursor:pointer; transition:border-color 0.2s;
}
.stage-thumbs .thumb:hover { border-color:var(--gold); }
.stage-thumbs .thumb.active { border-color:var(--gold); box-shadow:0 0 8px rgba(212,168,67,0.3); }
.stage-thumbs .thumb img { width:100%; height:100%; object-fit:cover; }
.stage-actions { display:flex; gap:4px; flex-shrink:0; }
.img-creator {
  position:absolute; bottom:60px; left:50%; transform:translateX(-50%);
  width:340px; background:var(--bg-card); border:1px solid var(--border-accent);
  border-radius:var(--radius); padding:14px; z-index:10; box-shadow:var(--shadow);
}
.img-creator-header {
  display:flex; align-items:center; justify-content:space-between;
  margin-bottom:8px; font-family:'Cinzel',serif; font-size:12px; color:var(--gold);
}

/* Right Panel — Voice Transcript */
.panel-transcript {
  width:340px; flex-shrink:0; display:flex; flex-direction:column; overflow:hidden;
  background:var(--bg);
}
.transcript-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:10px 14px; border-bottom:1px solid var(--border); flex-shrink:0;
}
.transcript-title { font-family:'Cinzel',serif; font-size:13px; color:var(--gold-light); }
.transcript-scroll {
  flex:1; overflow-y:auto; padding:14px;
  font-family:'Crimson Text', Georgia, serif;
}
.transcript-input {
  padding:10px 14px; border-top:1px solid var(--border); flex-shrink:0;
  display:flex; flex-direction:column; gap:8px; background:var(--bg-surface);
}
.transcript-input-row { display:flex; gap:6px; align-items:center; }
.transcript-input-row input { flex:1; font-size:13px; padding:10px 12px; }
.transcript-voice-row { display:flex; align-items:center; gap:10px; }
.msg { margin-bottom:18px; max-width:88%; }
.msg-dm { display:flex; gap:12px; }
.msg-dm .avatar {
  width:36px; height:36px; border-radius:50%; flex-shrink:0;
  background:linear-gradient(135deg,var(--purple),#6d28d9);
  display:flex; align-items:center; justify-content:center; font-size:18px; margin-top:2px;
}
.msg-dm .bubble {
  background:var(--bg-card); border:1px solid var(--border); border-radius:4px 14px 14px 14px;
  padding:14px 18px; font-size:16px; line-height:1.7; color:var(--text);
}
.msg-player { display:flex; justify-content:flex-end; margin-left:auto; }
.msg-player .bubble {
  background:linear-gradient(135deg,var(--gold-dark),var(--gold));
  color:#0e0e1a; border-radius:14px 4px 14px 14px;
  padding:10px 16px; font-size:14px; font-weight:600; font-family:system-ui,sans-serif;
}
.msg .turn-label { font-family:'Cinzel',serif; font-size:10px; color:var(--text-muted); margin-bottom:3px; }
.msg .player-label { font-family:'Cinzel',serif; font-size:10px; color:var(--gold-dark); margin-bottom:3px; text-align:right; }
.msg .inline-img { max-width:100%; border-radius:8px; margin-top:10px; border:1px solid var(--border); cursor:pointer; }
.msg .inline-map { max-width:100%; border-radius:8px; margin-top:10px; border:2px solid var(--purple-dim); cursor:pointer; }
/* Shimmer placeholder for async image generation */
.img-shimmer {
  width:100%; max-width:768px; height:220px; border-radius:8px; margin-top:10px;
  background: linear-gradient(90deg, var(--bg-card) 25%, rgba(255,255,255,0.06) 50%, var(--bg-card) 75%);
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
  display:flex; align-items:center; justify-content:center;
  color:var(--text-muted); font-size:12px; font-style:italic;
}
.img-shimmer.map-shimmer { border:2px solid var(--purple-dim); height:200px; }
@keyframes shimmer { 0%{background-position:200% 0} 100%{background-position:-200% 0} }
.dice-hl { color:var(--gold); font-weight:700; font-family:'Cinzel',serif; font-size:13px; }

/* Party chat (AI→player direct, no DM) */
.msg-party { display:flex; gap:12px; }
.msg-party .bubble {
  background:rgba(0,255,180,0.06); border:1px dashed rgba(0,255,180,0.3); border-radius:4px 14px 14px 14px;
  padding:10px 16px; font-size:14px; line-height:1.6; color:var(--text); font-style:italic;
}
.msg-party .party-tag {
  display:inline-block; background:rgba(0,255,180,0.15); color:#0fb; font-size:10px; font-weight:700;
  padding:1px 6px; border-radius:4px; margin-bottom:4px; font-family:'Cinzel',serif; letter-spacing:0.5px;
}

/* Adventure conclusion banner */
.conclusion-banner {
  text-align:center; padding:40px 24px; margin:24px 0;
  background:linear-gradient(135deg, rgba(212,168,67,0.1), rgba(139,92,246,0.1));
  border:2px solid var(--gold-dark); border-radius:12px;
}
.conclusion-banner h2 { font-family:'Cinzel',serif; color:var(--gold-light); font-size:28px; margin-bottom:12px; }
.conclusion-banner .conclusion-text { font-size:16px; line-height:1.7; color:var(--text); max-width:600px; margin:0 auto 20px; }
.conclusion-banner .btn-restart { margin-top:16px; }

/* Typing indicator */
.typing { display:flex; align-items:center; gap:10px; padding:10px 0; color:var(--text-muted); font-style:italic; font-size:14px; }
.typing-dots span {
  display:inline-block; width:7px; height:7px; background:var(--purple); border-radius:50%;
  animation:bounce 1.4s infinite ease-in-out;
}
.typing-dots span:nth-child(2) { animation-delay:0.2s; }
.typing-dots span:nth-child(3) { animation-delay:0.4s; }
@keyframes bounce { 0%,80%,100%{transform:translateY(0)} 40%{transform:translateY(-8px)} }

/* Action bar (used by transcript panel) */
.voice-row { display:flex; align-items:center; gap:10px; font-size:13px; }

/* Voice button */
.voice-btn {
  width:48px; height:48px; border-radius:50%; border:2px solid var(--border);
  background:var(--bg-surface); color:var(--text-dim); font-size:20px;
  cursor:pointer; transition:all 0.2s; display:flex; align-items:center; justify-content:center;
  position:relative; overflow:hidden;
}
.voice-btn:hover { border-color:var(--gold-dark); color:var(--text); }
.voice-btn.listening {
  border-color:var(--gold); color:var(--gold); background:rgba(212,168,67,0.1);
  animation:pulse-gold 1.5s infinite;
}
.voice-btn.speaking {
  border-color:var(--purple); color:var(--purple); background:rgba(139,92,246,0.1);
  animation:pulse-purple 1.5s infinite;
}
@keyframes pulse-gold { 0%,100%{box-shadow:0 0 0 0 rgba(212,168,67,0.3)} 50%{box-shadow:0 0 0 12px rgba(212,168,67,0)} }
@keyframes pulse-purple { 0%,100%{box-shadow:0 0 0 0 rgba(139,92,246,0.3)} 50%{box-shadow:0 0 0 12px rgba(139,92,246,0)} }
.voice-status { color:var(--text-muted); font-size:12px; font-style:italic; }
.voice-mode-toggle {
  font-size:11px; padding:4px 10px; border-radius:12px; border:1px solid var(--border);
  background:var(--bg-surface); color:var(--text-dim); cursor:pointer; font-family:'Cinzel',serif;
  transition:all 0.2s;
}
.voice-mode-toggle.auto { border-color:var(--green); color:var(--green); }
.player-select { font-size:13px; padding:8px 12px; border-radius:8px; min-width:120px; }

/* Dice roller buttons */
.dice-btn {
  font-family:'Cinzel',serif; font-size:14px; font-weight:700; padding:10px 6px;
  background:var(--bg-card); border:2px solid var(--border); border-radius:8px;
  color:var(--gold-light); cursor:pointer; transition:all 0.2s;
  display:flex; align-items:center; justify-content:center;
}
.dice-btn:hover { border-color:var(--gold); background:rgba(212,168,67,0.08); transform:scale(1.05); }
.dice-btn:active { transform:scale(0.95); }
.dice-btn.rolling { animation:dice-shake 0.3s ease-in-out; }
@keyframes dice-shake {
  0%,100% { transform:rotate(0deg); }
  25% { transform:rotate(-12deg) scale(1.1); }
  50% { transform:rotate(12deg) scale(1.15); }
  75% { transform:rotate(-8deg) scale(1.1); }
}

/* Right Panel */
/* Legacy panel-right — now unused, kept for compat */
.panel-right-legacy {
  width:300px; border-left:1px solid var(--border); background:var(--bg);
  display:flex; flex-direction:column; flex-shrink:0; overflow:hidden;
}
.panel-right-tabs { display:flex; border-bottom:1px solid var(--border); flex-shrink:0; }
.panel-right-tab {
  flex:1; padding:10px; text-align:center; font-size:12px; font-family:'Cinzel',serif;
  font-weight:600; color:var(--text-muted); cursor:pointer; border-bottom:2px solid transparent;
  transition:all 0.2s; background:none; border-top:none; border-left:none; border-right:none;
}
.panel-right-tab.active { color:var(--gold); border-bottom-color:var(--gold); }
.panel-right-body { flex:1; overflow-y:auto; padding:12px; }

.scene-main-box {
  width:100%; border-radius:8px; overflow:hidden; position:relative;
  background:var(--bg-surface); min-height:180px; margin-bottom:10px;
  display:flex; align-items:center; justify-content:center; border:1px solid var(--border);
}
.scene-main-box img { width:100%; display:block; cursor:pointer; }
.scene-main-box .loc-overlay {
  position:absolute; bottom:0; left:0; right:0; padding:6px 10px;
  background:linear-gradient(transparent,rgba(0,0,0,0.7));
  color:var(--gold-light); font-family:'Cinzel',serif; font-size:11px; font-weight:600;
}
.scene-main-box .no-img { color:var(--text-muted); font-size:13px; font-style:italic; }
.scene-gallery { display:grid; grid-template-columns:1fr 1fr; gap:6px; margin-top:8px; }
.scene-thumb {
  border-radius:6px; overflow:hidden; cursor:pointer; border:1px solid var(--border);
  aspect-ratio:3/2; transition:border-color 0.2s;
}
.scene-thumb:hover { border-color:var(--gold-dark); }
.scene-thumb img { width:100%; height:100%; object-fit:cover; }
.gen-btn { width:100%; margin-top:8px; }

/* Map view */
.map-container { width:100%; border-radius:8px; overflow:hidden; border:1px solid var(--border); margin-bottom:8px; background:var(--bg-surface); min-height:180px; display:flex; align-items:center; justify-content:center; }
.map-container img { width:100%; display:block; cursor:pointer; }
.map-container .no-img { color:var(--text-muted); font-size:13px; font-style:italic; }

/* Portrait cards */
.portrait-card {
  background:var(--bg-card); border-radius:var(--radius); border:1px solid var(--border);
  padding:10px; margin-bottom:10px; text-align:center;
}
.portrait-img {
  width:100%; aspect-ratio:1; border-radius:8px; overflow:hidden;
  background:var(--bg-surface); display:flex; align-items:center; justify-content:center;
  margin-bottom:8px; border:1px solid var(--border);
}
.portrait-img img { width:100%; height:100%; object-fit:cover; cursor:pointer; }
.no-portrait { font-size:48px; color:var(--text-muted); }
.portrait-name { font-family:'Cinzel',serif; font-size:14px; font-weight:600; color:var(--gold-light); }
.portrait-desc { font-size:12px; color:var(--text-dim); margin-top:2px; }

/* Custom image creator */
.media-create { padding:8px 0; }

/* === VISUAL SPLASH (Step 8) === */
.visual-splash { text-align:center; padding:10px 0; }
.splash-poster { position:relative; border-radius:var(--radius); overflow:hidden; margin-bottom:24px; }
.splash-poster img { width:100%; max-height:280px; object-fit:cover; border-radius:var(--radius); border:1px solid var(--border-accent); cursor:pointer; }
.splash-overlay { position:absolute; bottom:0; left:0; right:0; background:linear-gradient(transparent,rgba(0,0,0,0.85)); padding:16px; }
.splash-poster h2 { font-family:'Cinzel',serif; font-size:24px; color:var(--gold-light); text-shadow:0 2px 8px rgba(0,0,0,0.8); margin:0; }
.splash-poster p { font-family:'Crimson Text',serif; font-size:14px; color:var(--text-dim); font-style:italic; margin:4px 0 0; }
.splash-characters { display:flex; gap:14px; justify-content:center; flex-wrap:wrap; margin-bottom:24px; }
.splash-char-card { background:var(--bg-card); border:1px solid var(--border); border-radius:var(--radius); padding:12px; width:160px; text-align:center; }
.splash-char-card .char-portrait { width:120px; height:160px; border-radius:8px; overflow:hidden; margin:0 auto 8px; background:var(--bg-surface); display:flex; align-items:center; justify-content:center; border:1px solid var(--border); }
.splash-char-card .char-portrait img { width:100%; height:100%; object-fit:cover; cursor:pointer; }
.splash-char-card h3 { font-family:'Cinzel',serif; font-size:13px; color:var(--gold-light); margin:0 0 2px; }
.splash-char-card .char-meta { font-size:11px; color:var(--text-dim); }
.splash-map { margin-bottom:24px; }
.splash-map img { max-width:100%; max-height:240px; border-radius:var(--radius); border:2px solid var(--purple-dim); cursor:pointer; }
.shimmer { background:linear-gradient(90deg, var(--bg-surface) 25%, var(--bg-elevated) 50%, var(--bg-surface) 75%); background-size:200% 100%; animation:shimmer 1.5s infinite; }
@keyframes shimmer { 0%{background-position:200% 0} 100%{background-position:-200% 0} }

/* === DICE REQUEST BAR === */
.dice-request { padding:8px; text-align:center; }
.dice-request-desc { font-family:'Crimson Text',serif; font-size:15px; color:var(--text); margin-bottom:4px; font-style:italic; }
.dice-request-notation { font-family:'Cinzel',serif; font-size:13px; color:var(--gold); margin-bottom:10px; }
.dice-request-actions { display:flex; align-items:center; gap:10px; justify-content:center; flex-wrap:wrap; }
.dice-manual { display:flex; gap:6px; align-items:center; }
.dice-manual input { width:80px; text-align:center; font-size:14px; padding:8px; }
.dice-anim-container { display:flex; gap:8px; justify-content:center; margin:10px 0; }
.dice-anim {
  display:inline-flex; align-items:center; justify-content:center;
  width:60px; height:60px;
  background:linear-gradient(135deg, var(--gold), var(--gold-dark));
  border-radius:10px; color:#0e0e1a;
  font-family:'Cinzel',serif; font-size:24px; font-weight:900;
  box-shadow:0 2px 12px rgba(212,168,67,0.3);
}
.dice-anim.rolling { animation:dice-spin 0.8s ease-out; }
@keyframes dice-spin {
  0% { transform:rotate(0deg) scale(0.8); opacity:0.5; }
  50% { transform:rotate(360deg) scale(1.2); }
  100% { transform:rotate(720deg) scale(1); opacity:1; }
}
.dice-result-big { font-size:32px; color:var(--gold-light); font-family:'Cinzel',serif; font-weight:900; margin-top:6px; }
.dice-result-detail { font-size:12px; color:var(--text-dim); margin-top:2px; }
.dice-result-crit { color:var(--gold); text-shadow:0 0 12px rgba(212,168,67,0.6); }
.dice-result-fumble { color:var(--red); text-shadow:0 0 12px rgba(239,68,68,0.4); }

/* === AMBIENT SOUND CONTROLS === */
.audio-controls {
  display:flex; align-items:center; gap:6px; margin-right:8px;
}
.audio-controls .amb-label {
  font-size:10px; color:var(--text-muted); font-family:'Cinzel',serif; max-width:80px;
  overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
}
.audio-controls button {
  background:none; border:none; cursor:pointer; font-size:16px; padding:2px 4px;
  color:var(--text-muted); transition:color 0.2s;
}
.audio-controls button:hover { color:var(--gold); }
.audio-controls button.active { color:var(--gold); }
.audio-controls input[type=range] {
  width:60px; height:4px; accent-color:var(--gold); cursor:pointer;
}

/* === 3D DICE === */
.dice3d-overlay {
  position:fixed; inset:0; z-index:5000; pointer-events:none;
  display:flex; align-items:center; justify-content:center;
}
.dice3d-stage {
  perspective:600px; display:flex; gap:20px; pointer-events:none;
}
.dice3d-die {
  width:80px; height:80px; position:relative;
  transform-style:preserve-3d; animation:diceRoll3d 1.2s ease-out forwards;
}
.dice3d-die .face {
  position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
  font-family:'Cinzel',serif; font-weight:900; font-size:28px; color:#0e0e1a;
  border-radius:12px; backface-visibility:hidden;
  background:linear-gradient(135deg, var(--gold), var(--gold-dark));
  box-shadow:inset 0 2px 4px rgba(255,255,255,0.3), 0 4px 20px rgba(212,168,67,0.5);
}
.dice3d-die .face.front  { transform:translateZ(40px); }
.dice3d-die .face.back   { transform:rotateY(180deg) translateZ(40px); }
.dice3d-die .face.left   { transform:rotateY(-90deg) translateZ(40px); }
.dice3d-die .face.right  { transform:rotateY(90deg) translateZ(40px); }
.dice3d-die .face.top    { transform:rotateX(90deg) translateZ(40px); }
.dice3d-die .face.bottom { transform:rotateX(-90deg) translateZ(40px); }
@keyframes diceRoll3d {
  0% { transform:rotateX(0) rotateY(0) rotateZ(0) translateY(-200px) scale(0.5); opacity:0; }
  20% { opacity:1; }
  40% { transform:rotateX(520deg) rotateY(380deg) rotateZ(240deg) translateY(30px) scale(1.1); }
  60% { transform:rotateX(680deg) rotateY(440deg) rotateZ(310deg) translateY(-10px) scale(1); }
  80% { transform:rotateX(710deg) rotateY(358deg) rotateZ(355deg) translateY(5px); }
  100% { transform:rotateX(720deg) rotateY(360deg) rotateZ(360deg) translateY(0) scale(1); }
}
.dice3d-total {
  position:absolute; bottom:-60px; left:50%; transform:translateX(-50%);
  font-family:'Cinzel',serif; font-size:42px; font-weight:900;
  color:var(--gold-light); text-shadow:0 0 20px rgba(212,168,67,0.6);
  white-space:nowrap; pointer-events:none; opacity:0;
  animation:diceTotalReveal 0.4s ease-out 1.2s forwards;
}
.dice3d-total.crit { color:var(--gold); text-shadow:0 0 30px rgba(212,168,67,0.9), 0 0 60px rgba(212,168,67,0.4); }
.dice3d-total.fumble { color:var(--red); text-shadow:0 0 30px rgba(239,68,68,0.7); }
@keyframes diceTotalReveal { 0%{opacity:0;transform:translateX(-50%) scale(0.5);} 100%{opacity:1;transform:translateX(-50%) scale(1);} }
.dice3d-badge {
  position:absolute; bottom:-100px; left:50%; transform:translateX(-50%);
  font-family:'Cinzel',serif; font-size:18px; font-weight:700;
  white-space:nowrap; pointer-events:none; opacity:0;
  animation:diceTotalReveal 0.4s ease-out 1.4s forwards;
}
.dice3d-badge.crit { color:var(--gold); }
.dice3d-badge.fumble { color:var(--red); }

/* === CHARACTER SHEET — CONDITIONS & SPELLS === */
.condition-badge {
  display:inline-flex; align-items:center; gap:3px; padding:2px 6px;
  border-radius:10px; font-size:10px; font-weight:600;
  background:rgba(239,68,68,0.15); color:var(--red); border:1px solid rgba(239,68,68,0.3);
}
.condition-badge.buff { background:rgba(34,197,94,0.15); color:var(--green); border-color:rgba(34,197,94,0.3); }
.spell-slot { display:inline-block; width:10px; height:10px; border-radius:50%; border:1.5px solid var(--purple); margin:1px; }
.spell-slot.used { background:var(--purple); }
.spell-slot.available { background:transparent; }
.xp-bar-outer { height:4px; background:rgba(255,255,255,0.06); border-radius:2px; margin:2px 0; }
.xp-bar-fill { height:100%; background:var(--purple); border-radius:2px; transition:width 0.5s; }

/* Save/Load modal */
.modal-overlay {
  position:fixed; inset:0; background:rgba(0,0,0,0.7); z-index:4000;
  display:flex; align-items:center; justify-content:center;
  opacity:0; pointer-events:none; transition:opacity 0.3s;
}
.modal-overlay.show { opacity:1; pointer-events:all; }
.modal {
  background:var(--bg-card); border:1px solid var(--border); border-radius:12px;
  padding:28px; max-width:500px; width:90%; box-shadow: 0 8px 40px rgba(0,0,0,0.5);
}
.modal h2 { font-family:'Cinzel',serif; font-size:20px; color:var(--gold-light); margin-bottom:16px; }
.modal-actions { display:flex; gap:8px; margin-top:20px; justify-content:flex-end; }

/* === CHAR CREATION CHAT === */
.cc-layout { display:flex; gap:16px; height:420px; }
.cc-chat { flex:1; display:flex; flex-direction:column; background:var(--bg-deep); border:1px solid var(--border); border-radius:var(--radius); overflow:hidden; }
.cc-chat-scroll { flex:1; overflow-y:auto; padding:14px; font-family:'Crimson Text',Georgia,serif; }
.cc-chat-input { display:flex; gap:8px; padding:10px; border-top:1px solid var(--border); background:var(--bg); }
.cc-chat-input input { flex:1; font-size:14px; padding:10px 14px; border-radius:8px; }
.cc-chat-input .voice-btn { width:40px; height:40px; font-size:16px; }
.cc-sheet { width:260px; flex-shrink:0; overflow-y:auto; }
.cc-sheet-card {
  background:var(--bg-surface); border:1px solid var(--border); border-radius:var(--radius);
  padding:14px; font-size:12px; font-family:'Courier New',monospace; white-space:pre-wrap;
  color:var(--gold-light); line-height:1.6;
}
.cc-sheet-card .sheet-title { font-family:'Cinzel',serif; font-size:14px; font-weight:700; color:var(--gold); margin-bottom:8px; }
.cc-sheet-card .stat-row { color:var(--text); }
.cc-sheet-card .stat-label { color:var(--purple); font-weight:700; }
.cc-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:12px; padding:8px 14px; background:var(--bg-card); border-radius:var(--radius); }
.cc-header .player-badge { font-family:'Cinzel',serif; font-size:14px; color:var(--gold-light); font-weight:700; }
.cc-header .progress { font-size:12px; color:var(--text-dim); }
.cc-msg { margin-bottom:12px; max-width:85%; }
.cc-msg.dm { display:flex; gap:8px; }
.cc-msg.dm .bub { background:var(--bg-card); border:1px solid var(--border); border-radius:4px 12px 12px 12px; padding:10px 14px; font-size:14px; line-height:1.6; color:var(--text); }
.cc-msg.player { display:flex; justify-content:flex-end; }
.cc-msg.player .bub { background:linear-gradient(135deg,var(--gold-dark),var(--gold)); color:#0e0e1a; border-radius:12px 4px 12px 12px; padding:8px 14px; font-size:13px; font-weight:600; font-family:system-ui,sans-serif; }
.cc-msg .av { width:28px; height:28px; border-radius:50%; background:linear-gradient(135deg,var(--purple),#6d28d9); display:flex; align-items:center; justify-content:center; font-size:14px; flex-shrink:0; }

/* =========================================================
   ACTION GRID (Landing 2x2)
   ========================================================= */
.action-grid {
  display:grid; grid-template-columns:1fr 1fr;
  gap:16px; max-width:600px; width:100%;
}
.action-card {
  background:var(--bg-card); border:2px solid var(--border);
  border-radius:14px; padding:28px 20px; text-align:center;
  cursor:pointer; transition:all 0.25s;
}
.action-card:hover { transform:translateY(-3px); }
.action-card.dnd:hover { border-color:var(--gold); box-shadow:0 4px 24px rgba(212,168,67,0.2); }
.action-card.sr:hover { border-color:#0ff; box-shadow:0 4px 24px rgba(0,255,255,0.15); }
.action-icon { font-size:48px; margin-bottom:10px; }
.action-label { font-family:'Cinzel',serif; font-size:17px; font-weight:700; color:var(--gold-light); }
.action-card.sr .action-label { color:#0ff; }
.action-sub { font-size:12px; color:var(--text-dim); margin-top:4px; }

/* =========================================================
   PLAYER SETUP (intermediate page)
   ========================================================= */
#view-player-setup { flex-direction:column; align-items:center; padding:40px 20px; overflow-y:auto; }
#view-player-setup .ps-container { max-width:600px; width:100%; }
#view-player-setup h2 { margin-bottom:20px; }
#ps-player-name { width:100%; margin-bottom:20px; font-size:16px; padding:14px 16px; }
.ps-mode-grid { display:grid; grid-template-columns:1fr 1fr; gap:16px; margin-bottom:20px; }
.ps-mode-card {
  background:var(--bg-card); border:2px solid var(--border);
  border-radius:14px; padding:28px 20px; text-align:center;
  cursor:pointer; transition:all 0.25s;
}
.ps-mode-card:hover { transform:translateY(-3px); border-color:var(--gold); box-shadow:0 4px 24px rgba(212,168,67,0.2); }
.ps-mode-card.selected { border-color:var(--gold); background:rgba(212,168,67,0.08); box-shadow:0 0 20px rgba(212,168,67,0.15); }
.ps-mode-icon { font-size:48px; margin-bottom:10px; }
.ps-mode-label { font-family:'Cinzel',serif; font-size:17px; font-weight:700; color:var(--gold-light); }
.ps-mode-sub { font-size:12px; color:var(--text-dim); margin-top:4px; }
#ps-ai-options { margin-bottom:20px; }
#ps-ai-options .input { margin-bottom:8px; }
#ps-start-btn { width:100%; font-size:16px; padding:14px 36px; }
#ps-start-btn:disabled { opacity:0.4; cursor:not-allowed; }

/* =========================================================
   CHAR CREATE STANDALONE VIEW
   ========================================================= */
#view-char-create { flex-direction:column; align-items:center; overflow-y:auto; padding:20px; }
.cc-mode-header { display:flex; align-items:center; gap:16px; margin-bottom:16px; width:100%; }
.cc-mode-header h2 { flex:1; }

/* =========================================================
   ROSTER VIEW
   ========================================================= */
#view-roster { flex-direction:column; align-items:center; overflow-y:auto; padding:40px 20px; }
.roster-section { width:100%; margin-bottom:20px; }
.roster-section h3 { margin-bottom:10px; font-size:16px; }
.roster-card {
  display:flex; align-items:center; gap:12px; padding:14px 16px;
  background:var(--bg-card); border:1px solid var(--border); border-radius:var(--radius);
  cursor:pointer; transition:all 0.2s; margin-bottom:8px;
}
.roster-card:hover { border-color:var(--gold-dark); }
.roster-card.checked { border-color:var(--gold); background:rgba(212,168,67,0.06); }
.roster-check { accent-color:var(--gold); width:20px; height:20px; cursor:pointer; flex-shrink:0; }
.roster-info { flex:1; }
.roster-name { font-family:'Cinzel',serif; font-size:15px; font-weight:700; color:var(--gold-light); }
.roster-meta { font-size:12px; color:var(--text-dim); margin-top:2px; }
.roster-owner { font-size:11px; color:var(--text-muted); margin-top:2px; }
.roster-empty { color:var(--text-muted); font-style:italic; padding:16px; text-align:center; font-size:14px; }

/* =========================================================
   ADVENTURE CONFIG VIEW
   ========================================================= */
#view-adventure-config { flex-direction:column; align-items:center; overflow-y:auto; padding:40px 20px; }
.char-field { width:100%; }
.char-field label { display:block; font-family:'Cinzel',serif; font-size:13px; font-weight:600; color:var(--gold); margin-bottom:6px; }
</style>
</head>
<body>

<!-- ===== LANDING ===== -->
<div class="view active" id="view-landing">
  <div class="landing-icon">&#9876;&#65039;</div>
  <h1 class="landing-title">Maitre du Donjon</h1>
  <p class="landing-sub">Aventures vocales immersives propulsees par l'IA</p>

  <!-- 4 Action Cards Grid -->
  <div class="action-grid">
    <div class="action-card dnd" onclick="startCharCreate('dnd5e')">
      <div class="action-icon">&#128737;</div>
      <div class="action-label">Creer un Personnage</div>
      <div class="action-sub">Donjons &amp; Dragons 5e</div>
    </div>
    <div class="action-card dnd" onclick="startPlayFlow('dnd5e')">
      <div class="action-icon">&#9876;&#65039;</div>
      <div class="action-label">Jouer une Aventure</div>
      <div class="action-sub">Donjons &amp; Dragons 5e</div>
    </div>
    <div class="action-card sr" onclick="startCharCreate('shadowrun')">
      <div class="action-icon">&#128295;</div>
      <div class="action-label">Creer un Runner</div>
      <div class="action-sub">Shadowrun 2080</div>
    </div>
    <div class="action-card sr" onclick="startPlayFlow('shadowrun')">
      <div class="action-icon">&#127748;</div>
      <div class="action-label">Jouer un Run</div>
      <div class="action-sub">Shadowrun 2080</div>
    </div>
  </div>

  <!-- Bottom actions -->
  <div style="margin-top:24px;display:flex;gap:12px;flex-wrap:wrap;justify-content:center;">
    <button class="btn btn-ghost" onclick="showContinue()" id="btn-continue">&#128214; Continuer une Aventure</button>
    <button class="btn btn-ghost btn-small" onclick="document.getElementById('import-modal').classList.add('show')">&#128229; Importer</button>
    <button class="btn btn-ghost btn-small" onclick="showOnboarding()" title="Assistant classique 8 etapes">&#128736; Mode Classique</button>
  </div>
  <div class="campaigns-grid" id="camp-list" style="display:none;"></div>
  <a href="/" class="btn btn-ghost" style="margin-top:16px;font-size:12px;">&larr; Dashboard</a>
</div>

<!-- ===== PLAYER SETUP (Intermediate) ===== -->
<div class="view" id="view-player-setup">
  <div class="ps-container">
    <button class="btn btn-ghost" onclick="showLanding()">&larr; Retour</button>
    <h2 class="cinzel" id="ps-title">Creer un Personnage</h2>

    <input class="input" id="ps-player-name" placeholder="Votre nom..." autofocus>

    <div class="ps-mode-grid">
      <div class="ps-mode-card selected" id="ps-human-card" onclick="psSelectMode('human')">
        <div class="ps-mode-icon">&#129489;</div>
        <div class="ps-mode-label">Joueur Humain</div>
        <div class="ps-mode-sub">Vous creez votre personnage</div>
      </div>
      <div class="ps-mode-card" id="ps-ai-card" onclick="psSelectMode('kingston')">
        <div class="ps-mode-icon">&#129302;</div>
        <div class="ps-mode-label">Kingston (IA)</div>
        <div class="ps-mode-sub">L'IA cree un personnage</div>
      </div>
    </div>

    <!-- AI options (hidden by default) -->
    <div id="ps-ai-options" style="display:none;">
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
        <select class="input" id="ps-ai-personality">
          <option value="tactical">Tactique</option>
          <option value="reckless">Temeraire</option>
          <option value="cautious">Prudent</option>
          <option value="charismatic">Charismatique</option>
          <option value="mysterious">Mysterieux</option>
          <option value="comic">Comique</option>
          <option value="wise">Sage</option>
          <option value="aggressive">Agressif</option>
        </select>
        <select class="input" id="ps-ai-voice">
          <option value="fr-male">Remy (Homme FR)</option>
          <option value="fr-female">Denise (Femme FR)</option>
          <option value="en-male">Guy (Homme EN)</option>
          <option value="en-female">Jenny (Femme EN)</option>
          <option value="fr-vivienne">Vivienne (FR)</option>
          <option value="fr-claude">Claude (Homme FR)</option>
        </select>
      </div>
    </div>

    <button class="btn btn-gold" id="ps-start-btn" onclick="confirmPlayerSetup()">Commencer la Creation</button>
  </div>
</div>

<!-- ===== CHARACTER CREATION (Standalone) ===== -->
<div class="view" id="view-char-create">
  <div style="max-width:900px;width:100%;margin:0 auto;padding:20px;">
    <!-- Header -->
    <div class="cc-mode-header">
      <button class="btn btn-ghost" onclick="showView('player-setup')">&larr; Retour</button>
      <h2 class="cinzel" id="cc-system-title">Creer un Personnage</h2>
    </div>

    <!-- Chat + Sheet layout -->
    <div class="cc-layout" id="cc-create-layout">
      <div class="cc-chat">
        <div class="cc-chat-scroll" id="sa-cc-scroll"></div>
        <div class="cc-chat-input" id="sa-cc-input-area">
          <input class="input" id="sa-cc-input" placeholder="Repondez au Maitre du Donjon..." onkeydown="if(event.key==='Enter'){event.preventDefault();ccSendStandalone();}">
          <button class="voice-btn" id="sa-cc-voice-btn" onclick="toggleMic()" title="Micro">&#127908;</button>
          <button class="btn btn-gold btn-small" onclick="ccSendStandalone()">&#10148;</button>
        </div>
      </div>
      <div class="cc-sheet">
        <div class="cc-sheet-card" id="sa-cc-sheet-display">
          <div class="sheet-title">Fiche de Personnage</div>
          <span style="color:var(--text-muted);font-style:italic;font-family:system-ui;">En attente de creation...</span>
        </div>
        <button class="btn btn-gold" onclick="ccValidateStandalone()" id="sa-cc-validate-btn" style="display:none;width:100%;margin-top:10px;">
          &#10003; Sauvegarder ce personnage
        </button>
      </div>
    </div>
  </div>
</div>

<!-- ===== ROSTER (Who is present?) ===== -->
<div class="view" id="view-roster">
  <div style="max-width:700px;width:100%;margin:0 auto;padding:40px 20px;">
    <button class="btn btn-ghost" onclick="showLanding()" style="margin-bottom:16px;">&larr; Retour</button>
    <h2 class="cinzel step-title" id="roster-title">Qui est present?</h2>
    <p class="step-desc">Cochez les personnages qui participent a cette aventure.</p>

    <!-- Human Characters Section -->
    <div class="roster-section">
      <h3 class="cinzel" style="color:var(--gold);">&#129489; Personnages Joueurs</h3>
      <div id="roster-humans"></div>
    </div>

    <!-- AI Characters Section -->
    <div class="roster-section">
      <h3 class="cinzel" style="color:#0ff;">&#129302; Personnages IA (Kingston)</h3>
      <div id="roster-ais"></div>
    </div>

    <!-- Create new character link -->
    <div style="text-align:center;margin:16px 0;">
      <button class="btn btn-ghost" onclick="startCharCreate(rosterGameSystem)">
        + Creer un nouveau personnage
      </button>
    </div>

    <!-- Continue button -->
    <div style="text-align:center;margin-top:24px;">
      <button class="btn btn-gold" id="roster-next-btn" onclick="rosterNext()" disabled style="font-size:16px;padding:14px 36px;">
        Suivant &rarr;
      </button>
    </div>
  </div>
</div>

<!-- ===== ADVENTURE CONFIG ===== -->
<div class="view" id="view-adventure-config">
  <div style="max-width:640px;width:100%;margin:0 auto;padding:40px 20px;">
    <button class="btn btn-ghost" onclick="showView('roster')" style="margin-bottom:16px;">&larr; Retour</button>
    <h2 class="cinzel step-title">Preparer l'Aventure</h2>

    <!-- Campaign Name -->
    <div class="char-field" style="margin-bottom:16px;">
      <label>Nom de la campagne</label>
      <input class="input" id="adv-name" placeholder="Les Ombres de Neverwinter..." style="width:100%;">
    </div>

    <!-- Tone -->
    <div class="char-field" style="margin-bottom:16px;">
      <label>Ton</label>
      <div class="opt-grid" id="adv-tone-grid"></div>
    </div>

    <!-- Shadowrun options (conditionally shown) -->
    <div id="adv-sr-options" style="display:none;">
      <div class="char-field" style="margin-bottom:16px;">
        <label>Options Shadowrun</label>
        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;">
          <div>
            <label style="font-size:0.8em;color:var(--text-muted);display:block;margin-bottom:4px;">Type de Run</label>
            <select class="input" id="adv-sr-run" style="width:100%;font-size:13px;">
              <option value="extraction">Extraction</option>
              <option value="sabotage">Sabotage</option>
              <option value="datasteal">Vol de Donnees</option>
              <option value="wetwork">Wetwork</option>
              <option value="courier">Courier</option>
              <option value="protection">Protection VIP</option>
              <option value="investigation">Investigation</option>
              <option value="random">Aleatoire</option>
            </select>
          </div>
          <div>
            <label style="font-size:0.8em;color:var(--text-muted);display:block;margin-bottom:4px;">District</label>
            <select class="input" id="adv-sr-district" style="width:100%;font-size:13px;">
              <option value="redmond">Redmond Barrens</option>
              <option value="downtown">Downtown</option>
              <option value="tacoma">Tacoma</option>
              <option value="puyallup">Puyallup</option>
              <option value="renton">Renton</option>
              <option value="bellevue">Bellevue</option>
              <option value="random">Aleatoire</option>
            </select>
          </div>
          <div>
            <label style="font-size:0.8em;color:var(--text-muted);display:block;margin-bottom:4px;">Megacorp</label>
            <select class="input" id="adv-sr-mega" style="width:100%;font-size:13px;">
              <option value="random">Aleatoire</option>
              <option value="aztechnology">Aztechnology</option>
              <option value="saeder-krupp">Saeder-Krupp</option>
              <option value="renraku">Renraku</option>
              <option value="ares">Ares</option>
              <option value="mitsuhama">Mitsuhama</option>
              <option value="shiawase">Shiawase</option>
            </select>
          </div>
        </div>
      </div>
    </div>

    <!-- Consents -->
    <div class="char-field" style="margin-bottom:16px;">
      <label>Consentements</label>
      <div class="consent-list" id="adv-consents">
        <label class="consent-item"><input type="checkbox" id="adv-c-violence" checked> Violence physique (combats, blessures)</label>
        <label class="consent-item"><input type="checkbox" id="adv-c-horror"> Elements d'horreur</label>
        <label class="consent-item"><input type="checkbox" id="adv-c-romance"> Elements romantiques</label>
        <label class="consent-item"><input type="checkbox" id="adv-c-death" checked> Mort de personnages possible</label>
      </div>
    </div>

    <!-- Launch -->
    <div style="text-align:center;margin-top:28px;">
      <button class="btn btn-gold" style="font-size:17px;padding:16px 48px;" onclick="launchAdventure()">
        &#9876;&#65039; Commencer l'Aventure
      </button>
    </div>
  </div>
</div>

<!-- ===== ONBOARDING (Classic Wizard) ===== -->
<div class="view" id="view-onboarding">
  <div class="wizard">
    <div class="wizard-progress" id="wiz-progress"></div>
    <div id="wiz-steps"></div>
  </div>
</div>

<!-- ===== GAME ===== -->
<div class="view" id="view-game">
  <div class="game-header">
    <h1 id="gh-name">Campagne</h1>
    <div class="meta">
      <span id="gh-location">&#128205; ...</span>
      <span id="gh-turn">Tour 0</span>
    </div>
    <div class="spacer"></div>
    <div class="audio-controls" id="audio-controls">
      <button id="amb-toggle" onclick="ambientToggle()" title="Ambiance sonore">&#128264;</button>
      <input type="range" id="amb-volume" min="0" max="100" value="40" oninput="ambientSetVolume(this.value/100)">
      <span class="amb-label" id="amb-label">-</span>
    </div>
    <div class="controls">
      <button class="btn btn-gold btn-small" onclick="saveAndQuit()" style="gap:4px;">&#128190; Sauver &amp; Quitter</button>
      <button class="btn btn-ghost btn-small" onclick="exportGame()" title="Exporter JSON">&#128229;</button>
    </div>
  </div>
  <div class="game-layout">
    <!-- LEFT: Player Tools -->
    <div class="panel-left">
      <div class="panel-tabs">
        <button class="panel-tab active" onclick="switchLeftTab('party',this)">&#9876; Fiches</button>
        <button class="panel-tab" onclick="switchLeftTab('dice',this)">&#127922; Des</button>
        <button class="panel-tab" onclick="switchLeftTab('journal',this)">&#128220; Journal</button>
      </div>
      <div class="panel-content" id="left-party"></div>
      <div class="panel-content" id="left-dice" style="display:none;"></div>
      <div class="panel-content" id="left-journal" style="display:none;"></div>
    </div>
    <!-- CENTER: Visual Stage -->
    <div class="panel-stage">
      <div class="stage-main" id="stage-main">
        <div class="stage-poster" id="stage-poster">
          <div class="poster-loading"><div class="typing-dots"><span></span><span></span><span></span></div> Preparation de l'aventure...</div>
        </div>
      </div>
      <div class="stage-bar">
        <div class="stage-thumbs" id="stage-thumbs"></div>
        <div class="stage-actions">
          <button class="btn btn-ghost btn-small" onclick="manualGenScene()" title="Generer une scene">&#127912; Scene</button>
          <button class="btn btn-ghost btn-small" onclick="manualGenMap()" title="Generer une carte">&#128506; Carte</button>
          <button class="btn btn-ghost btn-small" onclick="showImageCreator()" title="Creer une image">&#10024; Creer</button>
        </div>
      </div>
      <!-- Floating image creator (hidden by default) -->
      <div class="img-creator" id="img-creator" style="display:none;">
        <div class="img-creator-header">
          <span>&#10024; Generateur d'Images</span>
          <button onclick="document.getElementById('img-creator').style.display='none'" style="background:none;border:none;color:var(--text-dim);cursor:pointer;font-size:16px;">&#10005;</button>
        </div>
        <textarea class="input" id="custom-img-prompt" rows="2" placeholder="Decrivez l'image..." style="width:100%;resize:none;font-size:13px;"></textarea>
        <div style="display:flex;gap:6px;margin-top:6px;">
          <select class="input" id="custom-img-style" style="flex:1;font-size:12px;padding:6px;">
            <option value="epic fantasy art">Fantasy</option>
            <option value="dark gothic horror art">Gothique</option>
            <option value="watercolor fantasy illustration">Aquarelle</option>
            <option value="anime fantasy art style">Anime</option>
            <option value="oil painting renaissance style">Peinture</option>
          </select>
          <button class="btn btn-gold btn-small" onclick="generateCustomImage()">&#127912;</button>
        </div>
      </div>
    </div>
    <!-- RIGHT: Voice Transcript -->
    <div class="panel-transcript">
      <div class="transcript-header">
        <span class="transcript-title">&#128220; Recit</span>
        <label style="font-size:11px;color:var(--text-muted);display:flex;align-items:center;gap:4px;cursor:pointer;">
          <input type="checkbox" id="tts-toggle" checked style="accent-color:var(--gold);"> &#128266;
        </label>
      </div>
      <div class="transcript-scroll" id="narrative"></div>
      <div class="transcript-input">
        <div class="transcript-input-row">
          <select class="input" id="player-select" style="width:auto;min-width:70px;padding:8px;font-size:11px;"></select>
          <input class="input" id="action-input" placeholder="Que faites-vous ?" onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();playTurn();}">
          <button class="btn btn-gold btn-small" onclick="playTurn()" id="btn-play">&#10148;</button>
        </div>
        <div class="transcript-voice-row">
          <button class="voice-btn" id="voice-btn" onclick="toggleMic()">&#127908;</button>
          <span class="voice-status" id="voice-status">Micro desactive</span>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Lightbox -->
<div id="lightbox" onclick="this.classList.remove('show')"><img id="lb-img"></div>
<!-- Toast -->
<div id="toast"></div>
<!-- Save modal -->
<div class="modal-overlay" id="save-modal">
  <div class="modal">
    <h2>&#128190; Sauvegarder</h2>
    <p style="color:var(--text-dim);font-size:14px;margin-bottom:16px;">La campagne est sauvegardee localement et sur le serveur.</p>
    <div class="modal-actions">
      <button class="btn btn-ghost" onclick="closeSaveModal()">Fermer</button>
      <button class="btn btn-gold btn-small" onclick="doSave()">Sauvegarder</button>
    </div>
  </div>
</div>
<!-- Import modal -->
<div class="modal-overlay" id="import-modal">
  <div class="modal">
    <h2>&#128229; Importer une campagne</h2>
    <input type="file" accept=".json" id="import-file" style="margin:12px 0;">
    <div class="modal-actions">
      <button class="btn btn-ghost" onclick="closeImportModal()">Annuler</button>
      <button class="btn btn-gold btn-small" onclick="doImport()">Importer</button>
    </div>
  </div>
</div>

<script>
/* =============================================================
   CONFIG & STATE
   ============================================================= */
const AUTH = localStorage.getItem('dashboard_auth_token') || '';
// Edge TTS via /api/tts — no SpeechSynthesis needed

let campaign = null; // active campaign state
let allCampaigns = []; // loaded from server/localStorage

const DEFAULT_CAMPAIGN = () => ({
  id: crypto.randomUUID(),
  name: '',
  tone: 'heroic',
  universe: 'fantasy',
  universeCustom: '',
  coop: false,
  kingstonChar: 'Kingston/Elf/Decker',
  aiPlayerCount: 0,     // 0-4 AI players
  aiPlayers: [],        // [{name, concept, personality, voice, character: null}]
  shadowrunOptions: { runType: 'extraction', district: 'redmond', megacorp: 'random' },
  complexity: 'standard',
  consents: { violence: true, horror: false, romance: false, death: true },
  players: [],     // [{name, character:{name,concept,role,talents:[],equipment:[],flaw,goal}}]
  location: '',
  npcs: [],        // [{name, description, attitude}]
  quests: [],      // [{name, status, detail}]
  timeline: [],    // [{text, turn}]
  turns: [],       // [{player, action, narrative, images:[], maps:[], turn, ts}]
  images: [],      // [{url, desc, turn}]
  maps: [],        // [{url, desc, turn}]
  portraits: [],   // [{url, desc, ts}] — character portraits
  customImages: [], // [{url, desc, style, turn, ts}] — user-created images
  posterUrl: '',
  arcOutline: '',
  blueprint: null,  // Full campaign blueprint (map, beats, ending, factions)
  sceneState: {
    activeThreads: [],      // [{id, description, urgency: "low"|"medium"|"high", turnsActive: 0}]
    npcsPresent: [],        // ["NPC name"] — who is in the scene RIGHT NOW
    environment: "",        // "Dense forest, twilight, north wind"
    mood: "",               // "tension", "calm", "combat", "exploration"
    nextBeat: null,         // Next story beat to aim for (from blueprint)
    pendingConsequences: [] // ["The innkeeper will remember the insult"]
  },
  turnNumber: 0,
  createdAt: Date.now(),
  updatedAt: Date.now()
});

/* =============================================================
   API LAYER
   ============================================================= */
async function api(path, method='GET', body=null) {
  const opts = { method, headers: {'Content-Type':'application/json'} };
  if (AUTH) opts.headers['X-Auth-Token'] = AUTH;
  if (body) opts.body = JSON.stringify(body);
  const res = await fetch(path, opts);
  if (!res.ok) {
    const d = await res.json().catch(()=>({}));
    throw new Error(d.error || `HTTP ${res.status}`);
  }
  return res.json();
}
async function narrateLLM(system, messages) {
  const data = await api('/api/dm/narrate', 'POST', { system, messages });
  return data.response;
}

/** Streaming narrate — calls onDelta(accumulated) as text arrives, returns full text */
async function narrateLLMStream(system, messages, onDelta) {
  const resp = await fetch('/api/dm/narrate-stream', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...(AUTH ? {'X-Auth-Token': AUTH} : {}) },
    body: JSON.stringify({ system, messages })
  });
  if (!resp.ok) {
    const d = await resp.json().catch(() => ({}));
    throw new Error(d.error || `HTTP ${resp.status}`);
  }
  const reader = resp.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  let fullText = '';
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';
    for (const line of lines) {
      if (!line.startsWith('data: ')) continue;
      try {
        const evt = JSON.parse(line.slice(6));
        if (evt.type === 'delta' && evt.text) {
          fullText += evt.text;
          if (onDelta) onDelta(fullText);
        } else if (evt.type === 'done') {
          fullText = evt.text || fullText;
        } else if (evt.type === 'error') {
          throw new Error(evt.error);
        }
      } catch (e) { if (e.message && !e.message.includes('JSON')) throw e; }
    }
  }
  return fullText;
}

/* =============================================================
   NAVIGATION
   ============================================================= */
function showView(id) {
  document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
  const el = document.getElementById('view-' + id);
  if (el) { el.classList.add('active','fade-in'); setTimeout(()=>el.classList.remove('fade-in'),500); }
}
function showLanding() {
  showView('landing');
  document.getElementById('camp-list').style.display = 'none';
}
function showContinue() {
  const el = document.getElementById('camp-list');
  el.style.display = 'flex';
  loadAllCampaigns();
}
function showOnboarding() { campaign = DEFAULT_CAMPAIGN(); wizStep = 0; buildWizard(); showView('onboarding'); if (micAlwaysOn) ensureMicOn(); }
function showGame() { showView('game'); renderGame(); if (micAlwaysOn) ensureMicOn(); }

/* =============================================================
   NEW FLOW — Char Create / Roster / Adventure Config
   ============================================================= */
let ccGameSystem = 'dnd5e';    // current game system for standalone char creation
let ccOwnerMode = 'human';     // 'human' or 'kingston'
let ccPlayerName = '';         // player name from setup page
let rosterGameSystem = 'dnd5e';
let selectedRosterIds = [];

// ── Player Setup (intermediate page) ──
function startCharCreate(gameSystem) {
  ccGameSystem = gameSystem || 'dnd5e';
  ccOwnerMode = 'human';
  ccPlayerName = '';
  // Update title on setup page
  const psTitle = document.getElementById('ps-title');
  if (psTitle) psTitle.textContent = gameSystem === 'shadowrun' ? 'Creer un Runner Shadowrun' : 'Creer un Personnage D&D';
  // Reset setup page state
  const nameInput = document.getElementById('ps-player-name');
  if (nameInput) nameInput.value = '';
  psSelectMode('human');
  showView('player-setup');
}

function psSelectMode(mode) {
  ccOwnerMode = mode;
  const humanCard = document.getElementById('ps-human-card');
  const aiCard = document.getElementById('ps-ai-card');
  const aiOpts = document.getElementById('ps-ai-options');
  if (mode === 'human') {
    humanCard.classList.add('selected'); aiCard.classList.remove('selected');
    if (aiOpts) aiOpts.style.display = 'none';
  } else {
    aiCard.classList.add('selected'); humanCard.classList.remove('selected');
    if (aiOpts) aiOpts.style.display = '';
  }
}

function confirmPlayerSetup() {
  const nameInput = document.getElementById('ps-player-name');
  const name = nameInput ? nameInput.value.trim() : '';
  if (!name && ccOwnerMode === 'human') {
    nameInput.focus();
    nameInput.style.borderColor = '#ff4444';
    setTimeout(() => nameInput.style.borderColor = '', 2000);
    toast('Entrez votre nom avant de continuer!');
    return;
  }
  ccPlayerName = name || 'Kingston';

  // Prepare char-create view
  ccChat = [];
  ccBusy = false;
  ccIsAI = ccOwnerMode === 'kingston';
  window._standaloneSheet = null;
  window._lastSavedSheetName = null;
  // Update title
  const title = document.getElementById('cc-system-title');
  if (title) title.textContent = ccGameSystem === 'shadowrun' ? 'Creer un Runner Shadowrun' : 'Creer un Personnage D&D';
  // Reset sheet display
  const sheetEl = document.getElementById('sa-cc-sheet-display');
  if (sheetEl) sheetEl.innerHTML = '<div class="sheet-title">Fiche de Personnage</div><span style="color:var(--text-muted);font-style:italic;font-family:system-ui;">En attente de creation...</span>';
  const valBtn = document.getElementById('sa-cc-validate-btn');
  if (valBtn) valBtn.style.display = 'none';

  // Show char-create
  showView('char-create');

  // Configure input area visibility
  const inputArea = document.getElementById('sa-cc-input-area');
  if (inputArea) inputArea.style.display = ccOwnerMode === 'human' ? '' : 'none';

  // Start conversation
  if (ccOwnerMode === 'human') {
    ccInitStandalone();
  } else {
    ccStartAIStandalone();
  }

  // Fetch roster (for dedup)
  fetchSavedRoster().catch(() => {});
  // Auto-activate mic
  if (micAlwaysOn) ensureMicOn();
}

// setCCOwner is now handled by player-setup page (psSelectMode + confirmPlayerSetup)

async function ccInitStandalone() {
  ccChat = [];
  ccIsAI = false;
  renderStandaloneCCChat();
  const ownerName = ccPlayerName || 'Joueur';
  const tempUniverse = ccGameSystem === 'shadowrun' ? 'shadowrun' : 'fantasy';
  ccBusy = true;
  saAddTyping();
  try {
    const system = ccBuildSystemStandalone(ownerName, tempUniverse);
    const intro = `Presente-toi comme Maitre du Donjon et commence a creer le personnage du joueur "${ownerName}" pour une campagne ${tempUniverse}. Pose ta PREMIERE question pour comprendre quel type de personnage l'attire. Sois chaleureux et enthousiaste. UNE seule question a la fois.`;
    ccChat.push({role:'user', content: intro, _hidden: true});
    const response = await narrateLLM(system, [{role:'user', content: intro}]);
    saRemoveTyping();
    ccChat.push({role:'assistant', content: response});
    renderStandaloneCCChat();
    speakText(response);
  } catch(err) {
    saRemoveTyping();
    ccChat.push({role:'assistant', content: `Bonjour! Je suis votre Maitre du Donjon. Quel type de personnage vous attire? Un guerrier courageux, un mage mysterieux, un voleur agile? Dites-moi ce qui vous fait rever!`});
    renderStandaloneCCChat();
  }
  ccBusy = false;
}

function ccBuildSystemStandalone(playerName, universe) {
  if (universe === 'shadowrun') {
    return `Tu es un Game Master expert et bienveillant qui aide a creer des personnages Shadowrun.
Tu aides le joueur "${playerName}" a creer son runner pour une campagne Shadowrun (ton: heroic, complexite: standard).

## REGLES
- Pose des questions UNE PAR UNE, pas tout d'un coup
- Sois chaleureux, enthousiaste, suggestif (propose des idees inspirantes cyberpunk)
- Guide le joueur a travers: metatype (Humain/Elf/Nain/Ork/Troll), role (Street Samurai/Decker/Mage/Shaman/Rigger/Face/Adept/Technomancer), cyberware, background, motivations
- Apres 3-5 echanges (quand tu as assez d'info), genere la fiche avec la balise [FICHE]...[/FICHE]
- Apres la fiche, demande "Ca vous convient ou vous voulez modifier quelque chose?"

## FORMAT DE FICHE (entre les balises [FICHE] et [/FICHE])
[FICHE]
NOM: Nom du runner (+ nom de rue)
METATYPE: Metatype
ROLE: Role
HISTORIQUE: Background cyberpunk

BODY: X  AGI: X  REA: X  FOR: X
VOL: X  LOG: X  INT: X  CHA: X
EDGE: X  ESSENCE: X.X

PV_PHYSIQUE: XX  PV_STUN: XX

COMPETENCES: liste (Hacking 6, Armes a Feu 5, etc.)
CYBERWARE: liste (ou "Aucun - mage/adept")
EQUIPEMENT: liste
CONTACTS: 2-3 contacts (nom, description, loyaute 1-6)
TRAITS: personnalite de runner
DEFAUT: defaut/faiblesse
MOTIVATION: ce qui pousse le runner dans les ombres
[/FICHE]

Reponds TOUJOURS en francais. Monde: Seattle 2080, megacorps, Matrix, magie et ombres.`;
  }
  return `Tu es un Maitre du Donjon expert et bienveillant qui aide a creer des personnages D&D 5e.
Tu aides le joueur "${playerName}" a creer son personnage pour une campagne fantasy (ton: heroic, complexite: standard).

## REGLES
- Pose des questions UNE PAR UNE, pas tout d'un coup
- Sois chaleureux, enthousiaste, suggestif (propose des idees inspirantes)
- Guide le joueur a travers: race, classe, historique (background), personnalite, motivations
- Apres 3-5 echanges (quand tu as assez d'info), genere la fiche avec la balise [FICHE]...[/FICHE]
- La fiche est un D&D 5e simplifie: stats calculees par toi selon la classe
- Apres la fiche, demande "Ca vous convient ou vous voulez modifier quelque chose?"
- Si le joueur demande des modifications, regenere la fiche mise a jour

## FORMAT DE FICHE (entre les balises [FICHE] et [/FICHE])
[FICHE]
NOM: Nom du personnage
RACE: Race
CLASSE: Classe (Niveau 1)
HISTORIQUE: Background

FOR: XX (+Y)  DEX: XX (+Y)  CON: XX (+Y)
INT: XX (+Y)  SAG: XX (+Y)  CHA: XX (+Y)

PV: XX   CA: XX   Initiative: +Y

MAITRISES: liste
EQUIPEMENT: liste
TRAITS: personnalite
DEFAUT: defaut/faiblesse
LIEN: ce qui motive le personnage
IDEAL: valeur fondamentale
[/FICHE]

Genere des stats coherentes avec la classe (stat principale haute). Reponds TOUJOURS en francais.`;
}

async function ccStartAIStandalone() {
  ccChat = [];
  ccIsAI = true;
  ccBusy = true;
  renderCCChat();

  const personality = document.getElementById('ps-ai-personality')?.value || 'tactical';
  const voice = document.getElementById('ps-ai-voice')?.value || 'fr-male';
  const universe = ccGameSystem === 'shadowrun' ? 'shadowrun' : 'fantasy';
  const isSR = ccGameSystem === 'shadowrun';
  const personalityLabel = AI_PERSONALITY_LABELS[personality] || personality;
  const color = '#0ff';
  const aiName = 'Kingston';

  const diversityHooks = [
    'un personnage avec un secret honteux', 'quelqu\'un qui a trahi son ancien groupe',
    'un ancien soldat reconverti', 'un artiste/musicien qui a mal tourne',
    'un scientifique obsede par une decouverte', 'un refugie d\'un autre plan/pays',
    'quelqu\'un qui cherche a se racheter', 'un ancien criminel devenu juste',
    'un noble dechu qui a tout perdu', 'un orphelin eleve par des non-humains',
    'un pacifiste force de se battre', 'un menteur compulsif au grand coeur'
  ];
  const hook = diversityHooks[Math.floor(Math.random() * diversityHooks.length)];

  const dmSystem = isSR ?
    `Tu es un Game Master Shadowrun bienveillant et methodique. Tu aides ${aiName} a creer son runner.
IMPORTANT: Tu dois couvrir TOUS ces aspects en posant UNE question a la fois:
1. Quel type de runner (role: Street Sam, Decker, Mage, Shaman, Rigger, Face, Adept, Technomancer)
2. Metatype (Humain, Elf, Nain, Ork, Troll)
3. Background et personnalite — nom de rue, d'ou il vient
4. Competences et cyberware preferes
5. Motivations et contacts
Sois chaleureux, enthousiaste, en francais. UNE question a la fois, 2-3 phrases max. Ne propose PAS de fiche avant d'avoir couvert tous les points.` :
    `Tu es un Dungeon Master D&D 5e bienveillant et methodique. Tu aides ${aiName} a creer son personnage.
IMPORTANT: Tu dois couvrir TOUS ces aspects en posant UNE question a la fois:
1. Race (Humain, Elfe, Nain, Halfelin, Tieflin, Demi-Orc, etc.)
2. Classe (Guerrier, Mage, Voleur, Clerc, Ranger, Paladin, Barde, etc.)
3. Nom du personnage et background/historique
4. Personnalite, traits, ideal et defaut
5. Equipement prefere et style de combat
Sois chaleureux, en francais. UNE question a la fois, 2-3 phrases max. Ne propose PAS de fiche avant d'avoir couvert tous les points.`;

  const aiSystem = isSR ?
    `Tu es ${aiName}. Personnalite: ${personalityLabel}. Tu es un joueur passionne qui cree son runner Shadowrun.
Inspiration secrete: ${hook}. Tu reponds au Maitre du Donjon avec enthousiasme et en restant IN CHARACTER.
IMPORTANT: Donne des reponses CONCRETES et SPECIFIQUES (noms, lieux, details precis). Reponds en 2-4 phrases max, en francais, a la premiere personne.` :
    `Tu es ${aiName}. Personnalite: ${personalityLabel}. Tu es un joueur passionne qui cree son personnage D&D 5e pour une campagne fantasy.
Inspiration secrete: ${hook}. Tu reponds au Maitre du Donjon avec enthousiasme et en restant IN CHARACTER.
IMPORTANT: Donne des reponses CONCRETES et SPECIFIQUES (noms, lieux, details precis). Reponds en 2-4 phrases max, en francais, a la premiere personne.`;

  const sheetFormat = isSR ?
    `CHAQUE champ doit etre rempli avec des valeurs concretes, PAS de placeholder.
Format EXACT entre [FICHE] et [/FICHE]:
NOM: (nom complet + nom de rue)
METATYPE: (un metatype precis)
ROLE: (un role precis)
HISTORIQUE: (2-3 phrases)
BODY: X  AGI: X  REA: X  FOR: X
VOL: X  LOG: X  INT: X  CHA: X
EDGE: X  ESSENCE: X.X
PV_PHYSIQUE: XX  PV_STUN: XX
COMPETENCES: (liste de 5-8 competences avec scores, ex: Hacking 6, Armes a Feu 5)
CYBERWARE: (liste ou "Aucun")
EQUIPEMENT: (liste de 4-6 items)
CONTACTS: (2-3 contacts avec nom et loyaute)
TRAITS: (2-3 traits de personnalite)
DEFAUT: (un defaut concret)
MOTIVATION: (ce qui pousse le runner)` :
    `CHAQUE champ doit etre rempli avec des valeurs concretes, PAS de placeholder.
Format EXACT entre [FICHE] et [/FICHE]:
NOM: (un nom complet de personnage)
RACE: (une race precis)
CLASSE: (une classe precis, Niveau 1)
HISTORIQUE: (2-3 phrases de background)
FOR: XX (+Y)  DEX: XX (+Y)  CON: XX (+Y)
INT: XX (+Y)  SAG: XX (+Y)  CHA: XX (+Y)
PV: XX   CA: XX   Initiative: +Y
MAITRISES: (liste de 4-6 maitrises)
EQUIPEMENT: (liste de 4-6 items concrets)
TRAITS: (2-3 traits de personnalite)
DEFAUT: (un defaut concret)
LIEN: (ce qui motive le personnage)
IDEAL: (une valeur fondamentale)`;

  // DM question prompts — guide the conversation through all aspects
  const dmQuestionPrompts = isSR ? [
    `Accueille ${aiName} chaleureusement et demande-lui quel TYPE de runner il aimerait jouer (Street Samurai, Decker, Mage, Shaman, Rigger, Face, Adept, Technomancer). Propose des descriptions inspirantes.`,
    `${aiName} a choisi son role. Reagis avec enthousiasme! Maintenant demande-lui quel METATYPE il veut (Humain, Elf, Nain, Ork, Troll) et comment il imagine son apparence.`,
    `Super choix! Demande a ${aiName} son NOM DE RUE et d'ou vient son runner — quel est son PASSE, comment il est arrive dans les ombres?`,
    `Fascinant! Demande maintenant quelles COMPETENCES et quel CYBERWARE (ou magie) il voudrait — quel est son style de combat et ses outils preferes?`,
    `Excellent! Derniere question: quels sont ses CONTACTS dans les ombres et quelle est sa MOTIVATION profonde — pourquoi court-il les ombres?`
  ] : [
    `Accueille ${aiName} chaleureusement et demande-lui quelle RACE il aimerait jouer (Humain, Elfe, Nain, Halfelin, Tieflin, Demi-Orc, Gnome, Draconien...). Propose des descriptions inspirantes.`,
    `${aiName} a choisi sa race. Reagis avec enthousiasme! Maintenant demande-lui quelle CLASSE il veut jouer (Guerrier, Mage, Voleur, Clerc, Ranger, Paladin, Barde, Druide, Sorcier, Barbare, Moine, Artificier...).`,
    `Super choix! Demande a ${aiName} le NOM de son personnage et son HISTORIQUE — d'ou vient-il, quel est son passe avant l'aventure?`,
    `Fascinant! Demande maintenant ses TRAITS de personnalite, son IDEAL et son plus grand DEFAUT — qu'est-ce qui le rend unique?`,
    `Excellent! Derniere question: quel EQUIPEMENT prefere-t-il et quel est son STYLE de combat? Epee et bouclier? Magie a distance? Furtivite?`
  ];

  const aiResponsePrompts = [
    `Le DM dit: "DMTEXT"\nReponds avec passion. Ton inspiration secrete: ${hook}. Fais un choix CONCRET et explique pourquoi.`,
    `Le DM dit: "DMTEXT"\nFais ton choix avec enthousiasme! Donne des DETAILS PRECIS sur ton personnage.`,
    `Le DM dit: "DMTEXT"\nInvente un NOM original et un PASSE detaille et specifique pour ton personnage.`,
    `Le DM dit: "DMTEXT"\nDecris ta PERSONNALITE avec des details concrets — donne des exemples de comportement.`,
    `Le DM dit: "DMTEXT"\nDecris ton EQUIPEMENT reve et ton style de combat prefere avec precision.`
  ];

  // Use aiCCMessages for rendering in the standalone view
  aiCCMessages = [];
  const dmHistory = [];
  const aiHistory = [];
  const convoLog = [];

  try {
    // Run 5 rounds of DM question → AI answer
    for (let round = 0; round < 5; round++) {
      // DM asks
      dmHistory.push({role:'user', content: round === 0 ? dmQuestionPrompts[0] : `${aiName} repond: "${convoLog[convoLog.length-1].text}"\n${dmQuestionPrompts[round]}`});
      const dmMsg = await narrateLLM(dmSystem, dmHistory);
      dmHistory.push({role:'assistant', content: dmMsg});
      aiCCMessages.push({role:'dm', content: dmMsg});
      convoLog.push({who: 'DM', text: dmMsg});
      renderStandaloneAIChat(aiName, color);
      await speakText(dmMsg);

      // AI responds
      const aiPrompt = aiResponsePrompts[round].replace('DMTEXT', dmMsg);
      aiHistory.push({role:'user', content: aiPrompt});
      const aiMsg = await narrateLLM(aiSystem, aiHistory);
      aiHistory.push({role:'assistant', content: aiMsg});
      aiCCMessages.push({role:'ai', content: aiMsg});
      convoLog.push({who: aiName, text: aiMsg});
      renderStandaloneAIChat(aiName, color);
      await speakTextWithVoice(aiMsg, voice);
    }

    // DM wraps up
    dmHistory.push({role:'user', content: `${aiName} a fini de decrire son personnage. Resume TOUT ce qu'il a choisi (race/metatype, classe/role, nom, background, traits, equipement) et dis que tu vas finaliser sa fiche. Sois enthousiaste!`});
    const dmWrapup = await narrateLLM(dmSystem, dmHistory);
    aiCCMessages.push({role:'dm', content: dmWrapup});
    convoLog.push({who: 'DM', text: dmWrapup});
    renderStandaloneAIChat(aiName, color);
    await speakText(dmWrapup);

    // Generate sheet with full conversation context
    const fullConvo = convoLog.map((c, i) => `Tour ${i+1} — ${c.who}: ${c.text}`).join('\n');
    const sheetSystem = `Tu es un expert en creation de fiches ${isSR ? 'Shadowrun' : 'D&D 5e'}. Voici la conversation COMPLETE entre le DM et ${aiName}:\n\n${fullConvo}\n\nA partir de TOUTES les informations donnees par ${aiName}, genere une fiche COMPLETE et DETAILLEE.\n${sheetFormat}\n\nIMPORTANT: CHAQUE champ doit contenir une valeur concrete basee sur la conversation. Les stats doivent etre des NOMBRES coherents avec la classe/role choisi. Ajoute un court commentaire enthousiaste (1-2 phrases) de ${aiName} AVANT la fiche. Reponds en francais.`;
    const sheetResponse = await narrateLLM(sheetSystem, [{role:'user', content: `Genere la fiche complete de ${aiName} maintenant, avec TOUS les champs remplis.`}]);

    const sheet = parseSheet(sheetResponse);
    if (sheet) {
      sheet._standaloneAI = true;
      sheet._aiPersonality = personality;
      sheet._aiVoice = voice;
      renderStandaloneSheet(sheet);
      const cleanComment = sheetResponse.replace(/\[FICHE\][\s\S]*?\[\/FICHE\]/gi, '').trim();
      if (cleanComment) {
        aiCCMessages.push({role:'ai', content: cleanComment});
        renderStandaloneAIChat(aiName, color);
        await speakTextWithVoice(cleanComment, voice);
      }
      // Store sheet and auto-save
      window._standaloneSheet = sheet;
      window._lastSavedSheetName = null; // reset for new sheet
      await ccAutoSaveSheet(sheet);
      const valBtn = document.getElementById('sa-cc-validate-btn');
      if (valBtn) { valBtn.style.display = 'block'; valBtn.textContent = '\u2713 Sauvegarder les modifications'; }
    } else {
      toast('Fiche non detectee, reessayez.');
    }
  } catch (err) {
    toast('Erreur creation IA: ' + err.message);
  }
  ccBusy = false;
}

function renderStandaloneAIChat(aiName, color) {
  const scroll = document.getElementById('sa-cc-scroll');
  if (!scroll) return;
  scroll.innerHTML = aiCCMessages.filter(m => !m._hidden).map(m => {
    if (m.role === 'dm') {
      return `<div class="cc-msg dm"><div class="av">&#128009;</div><div class="bub">${fmtNarrative(m.content)}</div></div>`;
    } else {
      return `<div class="cc-msg dm"><div class="av" style="background:linear-gradient(135deg,${color},${color}88);">&#129302;</div><div class="bub" style="border-left:3px solid ${color};">${fmtNarrative(m.content)}</div></div>`;
    }
  }).join('');
  scroll.scrollTop = scroll.scrollHeight;
}

function renderStandaloneCCChat() {
  const el = document.getElementById('sa-cc-scroll');
  if (!el) return;
  el.innerHTML = ccChat.filter(m => !m._hidden).map(m => {
    if (m.role === 'assistant') {
      const clean = m.content.replace(/\[FICHE\][\s\S]*?\[\/FICHE\]/gi, '<em style="color:var(--green);font-size:12px;">[Fiche generee &#10003;]</em>');
      return `<div class="cc-msg dm"><div class="av">&#128009;</div><div class="bub">${fmtNarrative(clean)}</div></div>`;
    }
    return `<div class="cc-msg player"><div class="bub">${esc(m.content)}</div></div>`;
  }).join('');
  el.scrollTop = el.scrollHeight;
}

function saAddTyping() {
  const el = document.getElementById('sa-cc-scroll');
  if (!el) return;
  el.innerHTML += `<div class="cc-msg dm" id="sa-cc-typing"><div class="av">&#128009;</div><div class="bub"><div class="typing"><div class="typing-dots"><span></span><span></span><span></span></div> Le MdD reflechit...</div></div></div>`;
  el.scrollTop = el.scrollHeight;
}
function saRemoveTyping() { const t = document.getElementById('sa-cc-typing'); if (t) t.remove(); }

function renderStandaloneSheet(c) {
  const el = document.getElementById('sa-cc-sheet-display');
  if (!el || !c) return;
  // Reuse the same rendering logic as renderCCSheet but target sa- element
  if (c.isShadowrun) {
    const s = c.stats || {};
    el.innerHTML = `<div class="sheet-title" style="color:#0ff;">${esc(c.name||'?')}</div>
<span class="stat-label">Metatype:</span> <span class="stat-row">${esc(c.race)}</span>
<span class="stat-label">Role:</span> <span class="stat-row">${esc(c.class)}</span>
<span class="stat-label">Historique:</span> <span class="stat-row">${esc(c.background)}</span>
${'─'.repeat(28)}
<span class="stat-label">BOD</span> ${s.body||3}  <span class="stat-label">AGI</span> ${s.agility||3}  <span class="stat-label">REA</span> ${s.reaction||3}  <span class="stat-label">FOR</span> ${s.strength||3}
<span class="stat-label">VOL</span> ${s.willpower||3}  <span class="stat-label">LOG</span> ${s.logic||3}  <span class="stat-label">INT</span> ${s.intuition||3}  <span class="stat-label">CHA</span> ${s.charisma||3}
<span class="stat-label" style="color:#0ff;">EDGE</span> ${s.edge||2}  <span class="stat-label" style="color:#f0f;">ESSENCE</span> ${s.essence||6.0}
${'─'.repeat(28)}
<span class="stat-label">PV Physique:</span> ${c.hp}  <span class="stat-label">PV Stun:</span> ${c.stunMax||10}
${'─'.repeat(28)}
<span class="stat-label">Competences:</span>
${esc(c.proficiencies)}
${c.cyberware ? `<span class="stat-label">Cyberware:</span>\n${esc(c.cyberware)}` : ''}
<span class="stat-label">Equipement:</span>
${esc(c.equipment)}
${c.contacts ? `<span class="stat-label">Contacts:</span>\n${esc(c.contacts)}` : ''}
${'─'.repeat(28)}
<span class="stat-label">Traits:</span> ${esc(c.traits)}
<span class="stat-label">Defaut:</span> ${esc(c.flaw)}
<span class="stat-label">Motivation:</span> ${esc(c.bond)}`;
    return;
  }
  const mod = (v) => { const m = Math.floor((v-10)/2); return m >= 0 ? `+${m}` : `${m}`; };
  el.innerHTML = `<div class="sheet-title">${esc(c.name||'?')}</div>
<span class="stat-label">Race:</span> <span class="stat-row">${esc(c.race)}</span>
<span class="stat-label">Classe:</span> <span class="stat-row">${esc(c.class)}</span>
<span class="stat-label">Historique:</span> <span class="stat-row">${esc(c.background)}</span>
${'─'.repeat(28)}
<span class="stat-label">FOR</span> ${c.stats.str} (${mod(c.stats.str)})  <span class="stat-label">DEX</span> ${c.stats.dex} (${mod(c.stats.dex)})
<span class="stat-label">CON</span> ${c.stats.con} (${mod(c.stats.con)})  <span class="stat-label">INT</span> ${c.stats.int} (${mod(c.stats.int)})
<span class="stat-label">SAG</span> ${c.stats.wis} (${mod(c.stats.wis)})  <span class="stat-label">CHA</span> ${c.stats.cha} (${mod(c.stats.cha)})
${'─'.repeat(28)}
<span class="stat-label">PV:</span> ${c.hp}  <span class="stat-label">CA:</span> ${c.ac}
${'─'.repeat(28)}
<span class="stat-label">Maitrises:</span>
${esc(c.proficiencies)}
<span class="stat-label">Equipement:</span>
${esc(c.equipment)}
${'─'.repeat(28)}
<span class="stat-label">Traits:</span> ${esc(c.traits)}
<span class="stat-label">Defaut:</span> ${esc(c.flaw)}
<span class="stat-label">Lien:</span> ${esc(c.bond)}
<span class="stat-label">Ideal:</span> ${esc(c.ideal)}`;
}

async function ccSendStandalone(textOverride) {
  if (ccBusy) return;
  const input = document.getElementById('sa-cc-input');
  const text = textOverride || (input ? input.value.trim() : '');
  if (!text) return;
  if (input) input.value = '';
  stopTTS();
  ccChat.push({role:'user', content: text});
  renderStandaloneCCChat();
  ccBusy = true;
  saAddTyping();
  try {
    const playerName = ccPlayerName || 'Joueur';
    const universe = ccGameSystem === 'shadowrun' ? 'shadowrun' : 'fantasy';
    const system = ccBuildSystemStandalone(playerName, universe);
    const messages = ccChat.map(m => ({role: m.role === 'assistant' ? 'assistant' : 'user', content: m.content}));
    const response = await narrateLLM(system, messages);
    saRemoveTyping();
    ccChat.push({role:'assistant', content: response});
    renderStandaloneCCChat();
    const sheet = parseSheet(response);
    if (sheet) {
      window._standaloneSheet = sheet;
      window._lastSavedSheetName = null; // reset for new/updated sheet
      renderStandaloneSheet(sheet);
      await ccAutoSaveSheet(sheet);
      const btn = document.getElementById('sa-cc-validate-btn');
      if (btn) { btn.style.display = 'block'; btn.textContent = '\u2713 Sauvegarder les modifications'; }
    }
    const cleanResponse = response.replace(/\[FICHE\][\s\S]*?\[\/FICHE\]/gi, '').trim();
    if (cleanResponse) speakText(cleanResponse);
  } catch(err) {
    saRemoveTyping();
    ccChat.push({role:'assistant', content: 'Desole, une erreur est survenue. Reessayez!'});
    renderStandaloneCCChat();
    toast('Erreur: ' + err.message);
  }
  ccBusy = false;
}

/** Build save payload from a parsed sheet */
function ccBuildSavePayload(sheet, ownerName, isAI) {
  return {
    owner: ownerName,
    game_system: ccGameSystem,
    name: sheet.name,
    race: sheet.race || 'Humain',
    class: sheet.class || 'Guerrier',
    level: sheet.level || 1,
    xp: sheet.xp || 0,
    hp: sheet.hp || sheet.hpMax || 10,
    hp_max: sheet.hpMax || sheet.hp || 10,
    ac: sheet.ac || null,
    stats: sheet.stats || {},
    inventory: (sheet.equipment || '').split(',').map(s => s.trim()).filter(Boolean),
    backstory: sheet.background || null,
    traits: sheet.traits || null,
    flaw: sheet.flaw || null,
    bond: sheet.bond || null,
    ideal: sheet.ideal || null,
    proficiencies: sheet.proficiencies || null,
    equipment: sheet.equipment || null,
    portrait_url: sheet.portraitUrl || null,
    personality: isAI ? (sheet._aiPersonality || null) : null,
    is_ai: isAI,
    extra: sheet.isShadowrun ? { cyberware: sheet.cyberware, contacts: sheet.contacts, stun_max: sheet.stunMax } : null,
  };
}

/** Auto-save sheet right after generation (both AI and human flows) */
async function ccAutoSaveSheet(sheet) {
  if (!sheet || !sheet.name) return;
  // Don't double-save if already saved with same name
  if (window._lastSavedSheetName === sheet.name) return;
  const isAI = ccOwnerMode === 'kingston';
  const ownerName = isAI ? 'Kingston' : (ccPlayerName || 'Joueur');
  try {
    const payload = ccBuildSavePayload(sheet, ownerName, isAI);
    await api('/api/dm/characters', 'POST', payload);
    await fetchSavedRoster();
    window._lastSavedSheetName = sheet.name;
    toast('Personnage sauvegarde automatiquement!');
  } catch (err) {
    console.error('Auto-save failed:', err);
    toast('Erreur sauvegarde auto: ' + err.message);
  }
}

async function ccValidateStandalone() {
  let sheet, ownerName, isAI;
  if (ccOwnerMode === 'kingston') {
    sheet = window._standaloneSheet;
    ownerName = 'Kingston';
    isAI = true;
  } else {
    sheet = window._standaloneSheet || (campaign.players[ccIndex] && campaign.players[ccIndex].character);
    ownerName = ccPlayerName || 'Joueur';
    isAI = false;
  }
  if (!sheet || !sheet.name) {
    toast('Pas de fiche a sauvegarder!');
    return;
  }
  try {
    const payload = ccBuildSavePayload(sheet, ownerName, isAI);
    // If already auto-saved, update instead of creating duplicate
    const existing = savedRoster.find(c => c.name === sheet.name && c.game_system === ccGameSystem);
    if (existing) {
      await api(`/api/dm/characters/${existing.id}`, 'PUT', payload);
    } else {
      await api('/api/dm/characters', 'POST', payload);
    }
    await fetchSavedRoster();
    toast('Personnage sauvegarde!');
    // Return to landing after short delay
    setTimeout(() => showLanding(), 800);
  } catch (err) {
    toast('Erreur: ' + err.message);
  }
}

// ── Roster Selection Flow ──
function startPlayFlow(gameSystem) {
  rosterGameSystem = gameSystem || 'dnd5e';
  selectedRosterIds = [];
  const title = document.getElementById('roster-title');
  if (title) title.textContent = gameSystem === 'shadowrun' ? 'Qui participe au run?' : 'Qui est present?';
  showView('roster');
  renderRoster();
}

async function renderRoster() {
  await fetchSavedRoster();
  const humans = savedRoster.filter(c => c.game_system === rosterGameSystem && !c.is_ai);
  const ais = savedRoster.filter(c => c.game_system === rosterGameSystem && c.is_ai);

  const humanEl = document.getElementById('roster-humans');
  const aiEl = document.getElementById('roster-ais');

  if (humans.length === 0) {
    humanEl.innerHTML = '<div class="roster-empty">Aucun personnage joueur. Creez-en un d\'abord!</div>';
  } else {
    humanEl.innerHTML = humans.map(c => `
      <label class="roster-card" id="roster-card-${c.id}">
        <input type="checkbox" class="roster-check" data-id="${c.id}" onchange="updateRosterSelection()">
        <div class="roster-info">
          <div class="roster-name">${esc(c.name)}</div>
          <div class="roster-meta">${esc(c.race)} ${esc(c.class)} Niv.${c.level || 1} — PV ${c.hp || '?'}/${c.hp_max || '?'}</div>
          <div class="roster-owner">Joueur: ${esc(c.owner)}</div>
        </div>
        <button class="del" onclick="event.preventDefault();event.stopPropagation();deleteRosterChar(${c.id})" title="Supprimer">&#10006;</button>
      </label>
    `).join('');
  }

  if (ais.length === 0) {
    aiEl.innerHTML = '<div class="roster-empty">Aucun personnage IA. Creez-en un avec Kingston!</div>';
  } else {
    aiEl.innerHTML = ais.map(c => `
      <label class="roster-card" id="roster-card-${c.id}">
        <input type="checkbox" class="roster-check" data-id="${c.id}" onchange="updateRosterSelection()">
        <div class="roster-info">
          <div class="roster-name" style="color:#0ff;">${esc(c.name)}</div>
          <div class="roster-meta">${esc(c.race)} ${esc(c.class)} Niv.${c.level || 1} — PV ${c.hp || '?'}/${c.hp_max || '?'}</div>
          <div class="roster-owner">IA: Kingston (${esc(c.personality || 'tactical')})</div>
        </div>
        <button class="del" onclick="event.preventDefault();event.stopPropagation();deleteRosterChar(${c.id})" title="Supprimer">&#10006;</button>
      </label>
    `).join('');
  }

  updateRosterSelection();
}

function updateRosterSelection() {
  const checks = document.querySelectorAll('.roster-check');
  selectedRosterIds = [];
  checks.forEach(cb => {
    const card = cb.closest('.roster-card');
    if (cb.checked) {
      selectedRosterIds.push(Number(cb.dataset.id));
      if (card) card.classList.add('checked');
    } else {
      if (card) card.classList.remove('checked');
    }
  });
  const nextBtn = document.getElementById('roster-next-btn');
  if (nextBtn) nextBtn.disabled = selectedRosterIds.length === 0;
}

async function deleteRosterChar(id) {
  if (!confirm('Supprimer ce personnage?')) return;
  try {
    await api(`/api/dm/characters/${id}`, 'DELETE');
    await renderRoster();
    toast('Personnage supprime.');
  } catch(err) { toast('Erreur: ' + err.message); }
}

function rosterNext() {
  if (selectedRosterIds.length === 0) return;
  showAdventureConfig();
}

// ── Adventure Config ──
function showAdventureConfig() {
  showView('adventure-config');
  // Show/hide Shadowrun options
  const srOpts = document.getElementById('adv-sr-options');
  if (srOpts) srOpts.style.display = rosterGameSystem === 'shadowrun' ? '' : 'none';
  // Render tone grid
  const toneGrid = document.getElementById('adv-tone-grid');
  if (toneGrid) {
    const tones = [{k:'heroic',i:'&#9876;&#65039;',l:'Heroique',d:'Epique, heros courageux'},{k:'dark',i:'&#128128;',l:'Sombre',d:'Gritty, moralement ambigu'},{k:'horror',i:'&#128367;&#65039;',l:'Horreur',d:'Tension et peur'},{k:'comedy',i:'&#127917;',l:'Comedie',d:'Humour et fun'}];
    toneGrid.innerHTML = tones.map(t =>
      `<div class="opt-card ${t.k==='heroic'?'selected':''}" onclick="selectAdvTone(this,'${t.k}')">
        <div class="opt-icon">${t.i}</div><div class="opt-label">${t.l}</div><div class="opt-desc">${t.d}</div>
      </div>`
    ).join('');
  }
}

let advTone = 'heroic';
function selectAdvTone(el, tone) {
  advTone = tone;
  el.parentElement.querySelectorAll('.opt-card').forEach(c => c.classList.remove('selected'));
  el.classList.add('selected');
}

async function launchAdventure() {
  const name = document.getElementById('adv-name')?.value?.trim() || '';
  const universe = rosterGameSystem === 'shadowrun' ? 'shadowrun' : 'fantasy';

  // Collect consents
  const consents = {
    violence: document.getElementById('adv-c-violence')?.checked ?? true,
    horror: document.getElementById('adv-c-horror')?.checked ?? false,
    romance: document.getElementById('adv-c-romance')?.checked ?? false,
    death: document.getElementById('adv-c-death')?.checked ?? true,
  };

  // Build campaign from selected roster characters
  campaign = DEFAULT_CAMPAIGN();
  campaign.name = name;
  campaign.tone = advTone;
  campaign.universe = universe;
  campaign.consents = consents;

  // Shadowrun options
  if (rosterGameSystem === 'shadowrun') {
    campaign.shadowrunOptions = {
      runType: document.getElementById('adv-sr-run')?.value || 'extraction',
      district: document.getElementById('adv-sr-district')?.value || 'redmond',
      megacorp: document.getElementById('adv-sr-mega')?.value || 'random',
    };
  }

  // Load selected characters from roster into campaign
  const rosterChars = savedRoster.filter(c => selectedRosterIds.includes(c.id));
  const humanChars = rosterChars.filter(c => !c.is_ai);
  const aiChars = rosterChars.filter(c => c.is_ai);

  // Setup human players
  campaign.players = humanChars.map(sc => {
    const isSR = sc.game_system === 'shadowrun';
    return {
      name: sc.owner || 'Joueur',
      character: {
        name: sc.name, race: sc.race, class: sc.class, level: sc.level || 1,
        xp: sc.xp || 0, hp: sc.hp, hpMax: sc.hp_max, ac: sc.ac || (isSR ? 0 : 10),
        stats: sc.stats || {}, proficiencies: sc.proficiencies || '',
        equipment: sc.equipment || (sc.inventory || []).join(', '),
        traits: sc.traits || '', flaw: sc.flaw || '', bond: sc.bond || '',
        ideal: sc.ideal || '', background: sc.backstory || '',
        portraitUrl: sc.portrait_url || '', isShadowrun: isSR,
        concept: `${sc.race} ${sc.class}`, role: sc.class,
        talents: (sc.proficiencies || '').split(',').slice(0, 5).map(s => s.trim()),
        goal: sc.bond || '', _savedId: sc.id, _fromRoster: true,
        ...(isSR && sc.extra ? { cyberware: sc.extra.cyberware, contacts: sc.extra.contacts, stunMax: sc.extra.stun_max } : {}),
      }
    };
  });

  // Setup AI players
  campaign.aiPlayerCount = aiChars.length;
  campaign.coop = aiChars.length > 0;
  campaign.aiPlayers = aiChars.map(sc => {
    const isSR = sc.game_system === 'shadowrun';
    return {
      name: sc.owner || 'Kingston',
      concept: `${sc.race} ${sc.class}`,
      personality: sc.personality || 'tactical',
      voice: 'fr-male',
      character: {
        name: sc.name, race: sc.race, class: sc.class, level: sc.level || 1,
        xp: sc.xp || 0, hp: sc.hp, hpMax: sc.hp_max, ac: sc.ac || (isSR ? 0 : 10),
        stats: sc.stats || {}, proficiencies: sc.proficiencies || '',
        equipment: sc.equipment || (sc.inventory || []).join(', '),
        traits: sc.traits || '', flaw: sc.flaw || '', bond: sc.bond || '',
        ideal: sc.ideal || '', background: sc.backstory || '',
        isShadowrun: isSR, concept: `${sc.race} ${sc.class}`, role: sc.class,
        talents: (sc.proficiencies || '').split(',').slice(0, 5).map(s => s.trim()),
        goal: sc.bond || '',
        ...(isSR && sc.extra ? { cyberware: sc.extra.cyberware, contacts: sc.extra.contacts, stunMax: sc.extra.stun_max } : {}),
      }
    };
  });

  // Create session on server with roster_ids
  try {
    const charDesc = campaign.players.map(p => `${p.character.name}/${p.character.race}/${p.character.class}`).join(';');
    const payload = {
      name: name || 'Aventure',
      setting: `${advTone} ${universe}`,
      characters: charDesc || 'Aventurier/Humain/Guerrier',
      ruleset: rosterGameSystem === 'shadowrun' ? 'shadowrun' : 'dnd5e',
      coop: campaign.coop,
      roster_ids: selectedRosterIds,
    };
    if (rosterGameSystem === 'shadowrun') {
      payload.shadowrun_options = campaign.shadowrunOptions;
    }
    if (aiChars.length > 0) {
      payload.ai_players = campaign.aiPlayers.map(a => ({name: a.name, personality: a.personality, voice: a.voice}));
    }
    const result = await api('/api/dungeon/create', 'POST', payload);
    if (result.session) {
      campaign.sessionId = result.session.id;
    }
  } catch(err) {
    console.warn('Server session creation failed, continuing client-side:', err);
  }

  // Switch to onboarding view for the visual splash (step 8)
  // Build wizard DOM so step 8 can render
  wizStep = 8;
  buildWizard();
  showView('onboarding');
  // Generate campaign blueprint, poster, portraits, then show splash
  await ccGenerateCampaign();
}

/* =============================================================
   LANDING VIEW — CONTINUE ADVENTURE
   ============================================================= */
async function loadAllCampaigns() {
  const el = document.getElementById('camp-list');
  el.innerHTML = '<div class="loading-state"><div class="spinner"></div></div>';
  // Load saved character roster in parallel
  fetchSavedRoster().catch(() => {});
  // Load from localStorage
  const local = JSON.parse(localStorage.getItem('dm_campaigns') || '[]');
  // Try server
  try {
    const srv = await api('/api/dm/campaigns');
    const merged = mergeCampaigns(local, srv.campaigns || []);
    allCampaigns = merged;
    localStorage.setItem('dm_campaigns', JSON.stringify(merged));
  } catch(e) {
    allCampaigns = local;
  }
  renderCampaignList();
}
function mergeCampaigns(a, b) {
  const map = new Map();
  [...a, ...b].forEach(c => {
    const existing = map.get(c.id);
    if (!existing || c.updatedAt > existing.updatedAt) map.set(c.id, c);
  });
  return Array.from(map.values()).sort((x,y) => y.updatedAt - x.updatedAt);
}
function renderCampaignList() {
  const el = document.getElementById('camp-list');
  if (!allCampaigns.length) {
    el.innerHTML = '<div class="empty-msg">Aucune campagne sauvegardee. Créez votre premiere aventure!</div>';
    return;
  }
  el.innerHTML = allCampaigns.map(c => `
    <div class="camp-card" onclick="loadCampaign('${c.id}')">
      <div class="icon">&#9876;&#65039;</div>
      <div class="info">
        <h3>${esc(c.name || 'Sans nom')}</h3>
        <div class="meta">${esc(c.universe||'fantasy')} &middot; ${c.players?.length||0} joueur(s) &middot; Tour ${c.turnNumber||0} &middot; ${new Date(c.updatedAt).toLocaleDateString('fr-FR')}</div>
      </div>
      <button class="del" onclick="event.stopPropagation();deleteCampaign('${c.id}')" title="Supprimer">&#10006;</button>
    </div>
  `).join('');
}
function loadCampaign(id) {
  campaign = allCampaigns.find(c => c.id === id);
  if (!campaign) return toast('Campagne introuvable');
  showGame();
  // Auto-enable ambient for loaded campaigns
  if (!AmbientEngine.isEnabled()) AmbientEngine.toggle();
  if (campaign.location) AmbientEngine.onLocationChange(campaign.location);
}
async function deleteCampaign(id) {
  if (!confirm('Supprimer cette campagne?')) return;
  allCampaigns = allCampaigns.filter(c => c.id !== id);
  localStorage.setItem('dm_campaigns', JSON.stringify(allCampaigns));
  try { await api(`/api/dm/campaign/${id}`, 'DELETE'); } catch(e) {}
  showLanding();
}

/* =============================================================
   ONBOARDING WIZARD
   ============================================================= */
let wizStep = 0;
const WIZ_STEPS = [
  { title:'Bienvenue, Aventurier', desc:'Preparez-vous a vivre une aventure epique orchestree par l\'IA.' },
  { title:'Combien de Joueurs?', desc:'Vous pouvez jouer seul ou avec des amis autour de l\'ordinateur.' },
  { title:'Noms des Joueurs', desc:'Nommez vos joueurs humains et configurez les joueurs IA.' },
  { title:'Ton de l\'Aventure', desc:'Quelle atmosphere souhaitez-vous?' },
  { title:'Univers', desc:'Dans quel monde se deroule votre histoire?' },
  { title:'Complexite', desc:'A quel point voulez-vous un systeme detaille?' },
  { title:'Consentements', desc:'Definissez vos limites de contenu.' },
  { title:'Vos Personnages', desc:'L\'IA forge des heros sur mesure pour chaque joueur.' },
  { title:'Pret a Partir!', desc:'Votre aventure est prete. Il est temps de commencer.' }
];

function buildWizard() {
  // Progress dots
  document.getElementById('wiz-progress').innerHTML = WIZ_STEPS.map((_,i) =>
    `<div class="dot ${i<wizStep?'done':''} ${i===wizStep?'active':''}"></div>`
  ).join('');
  // Steps
  document.getElementById('wiz-steps').innerHTML = WIZ_STEPS.map((_,i) => `<div class="step ${i===wizStep?'active':''}" id="step-${i}"></div>`).join('');
  renderStep();
}
function renderStep() {
  // Update dots
  document.querySelectorAll('.wizard-progress .dot').forEach((d,i) => {
    d.className = 'dot' + (i < wizStep ? ' done' : '') + (i === wizStep ? ' active' : '');
  });
  document.querySelectorAll('.step').forEach((s,i) => s.classList.toggle('active', i===wizStep));
  const el = document.getElementById(`step-${wizStep}`);
  if (!el) return;
  const s = WIZ_STEPS[wizStep];
  let html = `<div class="step-title">${s.title}</div><div class="step-desc">${s.desc}</div>`;

  switch(wizStep) {
    case 0: // Welcome
      html += `<div style="text-align:center;margin-top:20px;">
        <div style="font-size:80px;margin-bottom:16px;">&#128009;</div>
        <div class="step-nav"><div></div><button class="btn btn-gold" onclick="wizNext()">Commencer &rarr;</button></div>
      </div>`;
      break;
    case 1: // Player count (Human + AI)
      html += `
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-top:8px;">
        <!-- Human Players -->
        <div style="padding:16px;background:rgba(212,168,67,0.06);border:1px solid rgba(212,168,67,0.2);border-radius:12px;">
          <div style="font-family:'Cinzel',serif;font-weight:600;color:var(--gold);margin-bottom:8px;font-size:1.05em;">&#9876; Joueurs Humains</div>
          <div style="font-size:0.82em;color:var(--text-muted);margin-bottom:12px;">Combien de joueurs reels a la table?</div>
          <div class="num-picker" style="justify-content:center;">
            ${[1,2,3,4,5,6].map(n => `<button class="num-btn ${campaign.players.length===n?'selected':''}" onclick="setPlayerCount(${n})">${n}</button>`).join('')}
          </div>
        </div>
        <!-- AI Players -->
        <div style="padding:16px;background:rgba(0,255,255,0.04);border:1px solid rgba(0,255,255,0.18);border-radius:12px;">
          <div style="font-family:'Cinzel',serif;font-weight:600;color:#0ff;margin-bottom:8px;font-size:1.05em;">&#129302; Joueurs IA</div>
          <div style="font-size:0.82em;color:var(--text-muted);margin-bottom:12px;">Des IA qui creent leur propre personnage et jouent automatiquement.</div>
          <div style="display:flex;gap:8px;justify-content:center;">
            ${[0,1,2,3,4].map(n => `<button class="btn ${campaign.aiPlayerCount===n?'btn-gold':'btn-ghost'} btn-small" style="min-width:40px;padding:6px 14px;font-size:1em;" onclick="setAIPlayerCount(${n})">${n}</button>`).join('')}
          </div>
        </div>
      </div>
      <div class="step-nav"><button class="btn btn-ghost" onclick="wizBack()">&larr; Retour</button><button class="btn btn-gold" onclick="wizNext()" ${campaign.players.length===0?'disabled':''}>Suivant &rarr;</button></div>`;
      break;
    case 2: // Player names (Human + AI config)
      { const rosterChars = savedRoster; // Show ALL saved characters (both D&D and Shadowrun)
      html += `
      <!-- Human Player Names -->
      <div style="margin-bottom:16px;">
        <div style="font-family:'Cinzel',serif;font-weight:600;color:var(--gold);margin-bottom:8px;">&#9876; Joueurs Humains</div>
        <div class="name-inputs">
          ${campaign.players.map((p,i) => {
            const loaded = p.character && p.character._fromRoster;
            return `<div class="name-row" style="flex-wrap:wrap;gap:6px;">
              <span class="num">${i+1}</span>
              <input class="input" style="flex:1;min-width:120px;" placeholder="Nom du joueur ${i+1}" value="${esc(p.name)}" oninput="campaign.players[${i}].name=this.value">
              ${rosterChars.length > 0 ? `
              <select class="input" style="flex:1;min-width:140px;font-size:12px;padding:6px 8px;${loaded ? 'border-color:var(--gold);color:var(--gold);' : ''}" onchange="if(this.value){loadRosterChar(${i},Number(this.value))}else{clearRosterChar(${i})}">
                <option value="">Nouveau personnage</option>
                ${rosterChars.map(sc => `<option value="${sc.id}" ${loaded && p.character._savedId === sc.id ? 'selected' : ''}>${sc.game_system === 'shadowrun' ? '[SR]' : '[D&D]'} ${esc(sc.name)} (${esc(sc.race)} ${esc(sc.class)} Niv.${sc.level}) — ${esc(sc.owner)}</option>`).join('')}
              </select>` : ''}
              ${loaded ? `<span style="font-size:0.75em;color:var(--gold);" title="${esc(p.character.name)}">&#9989; ${esc(p.character.name)}</span>` : ''}
            </div>`;
          }).join('')}
        </div>
        ${rosterChars.length === 0 ? `<div style="font-size:0.78em;color:var(--text-muted);margin-top:6px;">&#128161; Apres votre premiere partie, vos personnages seront sauvegardes ici automatiquement.</div>` : ''}
      </div>
      ${campaign.aiPlayerCount > 0 ? `
      <!-- AI Player Config -->
      <div style="padding:14px;background:rgba(0,255,255,0.04);border:1px solid rgba(0,255,255,0.18);border-radius:10px;">
        <div style="font-family:'Cinzel',serif;font-weight:600;color:#0ff;margin-bottom:10px;">&#129302; Joueurs IA (${campaign.aiPlayerCount})</div>
        <div style="display:flex;flex-direction:column;gap:8px;">
          ${campaign.aiPlayers.map((ai, i) => `
          <div style="padding:10px 12px;background:rgba(0,255,255,0.03);border:1px solid rgba(0,255,255,0.1);border-radius:8px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;align-items:center;">
            <div>
              <label style="font-size:0.75em;color:var(--text-muted);display:block;">Nom</label>
              <input class="input" style="width:100%;font-size:13px;padding:6px 10px;" placeholder="Nom de l'IA..." value="${esc(ai.name)}" oninput="campaign.aiPlayers[${i}].name=this.value">
            </div>
            <div>
              <label style="font-size:0.75em;color:var(--text-muted);display:block;">Personnalite</label>
              <select class="input" style="width:100%;font-size:13px;padding:6px 10px;" onchange="campaign.aiPlayers[${i}].personality=this.value">
                ${[{v:'tactical',l:'Tactique'},{v:'reckless',l:'Temeraire'},{v:'cautious',l:'Prudent'},{v:'charismatic',l:'Charismatique'},{v:'mysterious',l:'Mysterieux'},{v:'comic',l:'Comique'},{v:'wise',l:'Sage'},{v:'aggressive',l:'Agressif'}].map(p =>
                  `<option value="${p.v}" ${ai.personality===p.v?'selected':''}>${p.l}</option>`
                ).join('')}
              </select>
            </div>
            <div>
              <label style="font-size:0.75em;color:var(--text-muted);display:block;">Voix</label>
              <select class="input" style="width:100%;font-size:13px;padding:6px 10px;" onchange="campaign.aiPlayers[${i}].voice=this.value">
                ${[{v:'fr-male',l:'Remy (Homme FR)'},{v:'fr-female',l:'Denise (Femme FR)'},{v:'en-male',l:'Guy (Homme EN)'},{v:'en-female',l:'Jenny (Femme EN)'},{v:'fr-vivienne',l:'Vivienne (FR)'},{v:'fr-claude',l:'Claude (Homme FR)'}].map(v =>
                  `<option value="${v.v}" ${ai.voice===v.v?'selected':''}>${v.l}</option>`
                ).join('')}
              </select>
            </div>
          </div>`).join('')}
        </div>
        <div style="margin-top:8px;font-size:0.78em;color:var(--text-muted);">&#128161; Chaque IA creera son personnage automatiquement pendant la phase de creation.</div>
      </div>` : ''}
      <div class="step-nav"><button class="btn btn-ghost" onclick="wizBack()">&larr; Retour</button><button class="btn btn-gold" onclick="wizNext()">Suivant &rarr;</button></div>`; }
      break;
    case 3: // Tone
      html += `<div class="opt-grid">
        ${[{k:'heroic',i:'&#9876;&#65039;',l:'Heroique',d:'Aventure epique, heros courageux'},{k:'dark',i:'&#128128;',l:'Sombre',d:'Gritty, moralement ambigu'},{k:'horror',i:'&#128367;&#65039;',l:'Horreur',d:'Tension, peur, l\'inconnu'},{k:'comedy',i:'&#127917;',l:'Comedie',d:'Humour, absurde, fun'}].map(t =>
          `<div class="opt-card ${campaign.tone===t.k?'selected':''}" onclick="campaign.tone='${t.k}';renderStep()">
            <div class="opt-icon">${t.i}</div><div class="opt-label">${t.l}</div><div class="opt-desc">${t.d}</div>
          </div>`
        ).join('')}
      </div>
      <div class="step-nav"><button class="btn btn-ghost" onclick="wizBack()">&larr; Retour</button><button class="btn btn-gold" onclick="wizNext()">Suivant &rarr;</button></div>`;
      break;
    case 4: // Universe
      html += `<div class="opt-grid">
        ${[{k:'fantasy',i:'&#128009;',l:'Fantasy',d:'Donjons, dragons, magie'},{k:'shadowrun',i:'&#127747;',l:'Shadowrun',d:'Cyberpunk 2080, magie & Matrix'},{k:'sci-fi',i:'&#128640;',l:'Sci-Fi',d:'Espace, technologie'},{k:'western',i:'&#129312;',l:'Western',d:'Frontiere, duels'},{k:'post-apo',i:'&#9762;&#65039;',l:'Post-Apo',d:'Survie, ruines'},{k:'custom',i:'&#9999;&#65039;',l:'Personnalise',d:'Decrivez votre monde'}].map(u =>
          `<div class="opt-card ${campaign.universe===u.k?'selected':''}" onclick="campaign.universe='${u.k}';renderStep()">
            <div class="opt-icon">${u.i}</div><div class="opt-label">${u.l}</div><div class="opt-desc">${u.d}</div>
          </div>`
        ).join('')}
      </div>
      ${campaign.universe==='custom'?'<input class="input" style="width:100%;margin-top:12px;" placeholder="Decrivez votre univers..." value="'+esc(campaign.universeCustom)+'" oninput="campaign.universeCustom=this.value">':''}
      ${campaign.universe==='shadowrun'?`
      <div style="margin-top:16px;padding:16px;background:rgba(0,255,255,0.04);border:1px solid rgba(0,255,255,0.15);border-radius:10px;">
        <div style="font-family:'Cinzel',serif;font-weight:600;color:#0ff;margin-bottom:12px;">&#127747; Configuration Shadowrun</div>
        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;">
          <div>
            <label style="font-size:0.8em;color:var(--text-muted);display:block;margin-bottom:4px;">Type de Run</label>
            <select class="input" style="width:100%;font-size:13px;" onchange="campaign.shadowrunOptions.runType=this.value">
              ${[{v:'extraction',l:'Extraction'},{v:'sabotage',l:'Sabotage'},{v:'datasteal',l:'Vol de Donnees'},{v:'wetwork',l:'Wetwork (Assassinat)'},{v:'courier',l:'Courier'},{v:'protection',l:'Protection VIP'},{v:'investigation',l:'Investigation'},{v:'random',l:'Aleatoire'}].map(r =>
                `<option value="${r.v}" ${campaign.shadowrunOptions.runType===r.v?'selected':''}>${r.l}</option>`
              ).join('')}
            </select>
          </div>
          <div>
            <label style="font-size:0.8em;color:var(--text-muted);display:block;margin-bottom:4px;">District de depart</label>
            <select class="input" style="width:100%;font-size:13px;" onchange="campaign.shadowrunOptions.district=this.value">
              ${[{v:'redmond',l:'Redmond Barrens'},{v:'downtown',l:'Downtown'},{v:'tacoma',l:'Tacoma'},{v:'puyallup',l:'Puyallup'},{v:'renton',l:'Renton'},{v:'bellevue',l:'Bellevue'},{v:'everett',l:'Everett'},{v:'auburn',l:'Auburn'},{v:'random',l:'Aleatoire'}].map(d =>
                `<option value="${d.v}" ${campaign.shadowrunOptions.district===d.v?'selected':''}>${d.l}</option>`
              ).join('')}
            </select>
          </div>
          <div>
            <label style="font-size:0.8em;color:var(--text-muted);display:block;margin-bottom:4px;">Megacorp opposee</label>
            <select class="input" style="width:100%;font-size:13px;" onchange="campaign.shadowrunOptions.megacorp=this.value">
              ${[{v:'random',l:'Aleatoire'},{v:'aztechnology',l:'Aztechnology'},{v:'saeder-krupp',l:'Saeder-Krupp'},{v:'renraku',l:'Renraku'},{v:'ares',l:'Ares Macrotechnology'},{v:'mitsuhama',l:'Mitsuhama (MCT)'},{v:'shiawase',l:'Shiawase'},{v:'evo',l:'EVO'},{v:'horizon',l:'Horizon'},{v:'neonet',l:'NeoNET'},{v:'wuxing',l:'Wuxing Inc.'}].map(m =>
                `<option value="${m.v}" ${campaign.shadowrunOptions.megacorp===m.v?'selected':''}>${m.l}</option>`
              ).join('')}
            </select>
          </div>
        </div>
        <div style="margin-top:8px;font-size:0.78em;color:var(--text-muted);">Seattle 2080 — Les ombres n'attendent pas. Megacorps, Matrix, magie et chrome.</div>
      </div>`:''}
      <div class="step-nav"><button class="btn btn-ghost" onclick="wizBack()">&larr; Retour</button><button class="btn btn-gold" onclick="wizNext()">Suivant &rarr;</button></div>`;
      break;
    case 5: // Complexity
      html += `<div class="opt-grid" style="grid-template-columns:1fr 1fr;">
        <div class="opt-card ${campaign.complexity==='simple'?'selected':''}" onclick="campaign.complexity='simple';renderStep()">
          <div class="opt-icon">&#9889;</div><div class="opt-label">Simple</div><div class="opt-desc">Narratif pur, zero regles, fun immediat</div>
        </div>
        <div class="opt-card ${campaign.complexity==='standard'?'selected':''}" onclick="campaign.complexity='standard';renderStep()">
          <div class="opt-icon">&#128218;</div><div class="opt-label">Standard</div><div class="opt-desc">Talents, inventaire, consequences</div>
        </div>
      </div>
      <div class="step-nav"><button class="btn btn-ghost" onclick="wizBack()">&larr; Retour</button><button class="btn btn-gold" onclick="wizNext()">Suivant &rarr;</button></div>`;
      break;
    case 6: // Consent
      html += `<div class="consent-list">
        ${[{k:'violence',l:'Violence physique (combats, blessures)'},{k:'horror',l:'Elements d\'horreur (monstres, atmosphere terrifiante)'},{k:'romance',l:'Elements romantiques'},{k:'death',l:'Mort de personnages joueurs possible'}].map(c =>
          `<label class="consent-item"><input type="checkbox" ${campaign.consents[c.k]?'checked':''} onchange="campaign.consents['${c.k}']=this.checked"> ${c.l}</label>`
        ).join('')}
      </div>
      ${campaign.aiPlayerCount > 0 ? `
      <div style="margin-top:14px;padding:12px;background:rgba(0,255,255,0.03);border:1px solid rgba(0,255,255,0.12);border-radius:8px;font-size:0.85em;color:#0ff;">
        &#129302; ${campaign.aiPlayerCount} joueur(s) IA configuré(s) — ils créeront leur personnage après vous.
      </div>` : ''}
      <div class="step-nav"><button class="btn btn-ghost" onclick="wizBack()">&larr; Retour</button><button class="btn btn-gold" onclick="startCharCreation()">Creer les Personnages &rarr;</button></div>`;
      break;
    case 7: // Character creation CHAT
      { const cp = campaign.players[ccIndex] || {};
      html += `
      <div class="cc-header">
        <div class="player-badge">&#9876; ${esc(cp.name||'Joueur')}</div>
        <div class="progress">Personnage ${ccIndex+1} / ${campaign.players.length}</div>
      </div>
      <div class="cc-layout">
        <div class="cc-chat">
          <div class="cc-chat-scroll" id="cc-scroll"></div>
          <div class="cc-chat-input">
            <input class="input" id="cc-input" placeholder="Repondez au Maitre du Donjon..." onkeydown="if(event.key==='Enter'){event.preventDefault();ccSend();}">
            <button class="voice-btn" id="cc-voice-btn" onclick="toggleMic()" title="Activer/desactiver le micro">&#127908;</button>
            <button class="btn btn-gold btn-small" onclick="ccSend()">&#10148;</button>
          </div>
        </div>
        <div class="cc-sheet">
          <div class="cc-sheet-card" id="cc-sheet-display">
            <div class="sheet-title">Fiche de Personnage</div>
            <span style="color:var(--text-muted);font-style:italic;font-family:system-ui;">En attente de creation...</span>
          </div>
          <div style="margin-top:10px;display:flex;flex-direction:column;gap:6px;">
            <button class="btn btn-gold btn-small" onclick="ccValidate()" id="cc-validate-btn" style="display:none;width:100%;">&#10003; Valider ce personnage</button>
            <button class="btn btn-ghost btn-small" onclick="wizStep=6;renderStep();" style="width:100%;">&larr; Retour</button>
          </div>
        </div>
      </div>`; }
      break;
    case 8: // Visual Splash — poster, portraits, map
      if (!campaign.blueprint && !campaign.name) {
        // Still generating blueprint
        html += `<div class="loading-state"><div class="spinner"></div><p>Le Maitre du Donjon prepare votre aventure...</p></div>`;
      } else {
        const hook = campaign.blueprint?.hook || campaign.arcOutline?.split('\n')[0] || '';
        html += `<div class="visual-splash">
          <div class="splash-poster" id="campaign-poster">
            ${campaign.posterUrl ?
              `<img src="${esc(campaign.posterUrl)}" onclick="openLB('${esc(campaign.posterUrl)}')" loading="lazy">` :
              `<div class="img-shimmer" style="height:200px;">Poster en cours...</div>`}
            <div class="splash-overlay">
              <h2 class="cinzel">${esc(campaign.name || 'Aventure')}</h2>
              <p class="crimson">${esc(hook)}</p>
            </div>
          </div>
          <div class="splash-characters">
            ${campaign.players.map((p, i) => {
              const c = p.character || {};
              return `<div class="splash-char-card">
                <div class="char-portrait" id="portrait-img-${i}">
                  ${c.portraitUrl ?
                    `<img src="${esc(c.portraitUrl)}" onclick="openLB('${esc(c.portraitUrl)}')" loading="lazy">` :
                    `<div class="shimmer" style="width:100%;height:100%;border-radius:8px;"></div>`}
                </div>
                <h3>${esc(c.name || p.name)}</h3>
                <div class="char-meta">${esc(c.race || '?')}, ${esc(c.class || '?')}</div>
              </div>`;
            }).join('')}
            ${(campaign.aiPlayers || []).map((ai, i) => {
              const c = ai.character || {};
              const aiColors = ['#0ff','#f0f','#0f0','#ff0'];
              const color = aiColors[i % aiColors.length];
              return `<div class="splash-char-card" style="border-color:${color};">
                <div class="char-portrait" style="background:linear-gradient(135deg,${color}22,${color}08);display:flex;align-items:center;justify-content:center;font-size:48px;">&#129302;</div>
                <h3 style="color:${color};">${esc(c.name || ai.name)} <span style="font-size:0.6em;opacity:0.7;">(IA)</span></h3>
                <div class="char-meta">${esc(c.race || '?')}, ${esc(c.class || '?')}</div>
              </div>`;
            }).join('')}
          </div>
          <div class="splash-map" id="blueprint-map">${campaign.blueprintMapUrl ? `<img src="${esc(campaign.blueprintMapUrl)}" onclick="openLB('${esc(campaign.blueprintMapUrl)}')" loading="lazy">` : `<div class="img-shimmer map-shimmer">Carte en cours...</div>`}</div>
          <div style="margin-top:16px;">
            <button class="btn btn-gold" onclick="startAdventure()" style="font-size:18px;padding:16px 48px;">&#9876; Commencer l'Aventure</button>
          </div>
        </div>`;
      }
      html += `<div class="step-nav"><button class="btn btn-ghost" onclick="wizStep=7;ccIndex=0;ccChat=[];startCharCreation();">&larr; Refaire les personnages</button><div></div></div>`;
      break;
  }
  el.innerHTML = html;
}
function wizNext() { if (wizStep < WIZ_STEPS.length - 1) { wizStep++; renderStep(); } }
function wizBack() { if (wizStep > 0) { wizStep--; renderStep(); } }
function setPlayerCount(n) {
  while (campaign.players.length < n) campaign.players.push({ name: '', character: null });
  while (campaign.players.length > n) campaign.players.pop();
  renderStep();
}

// AI Voice mapping for Edge TTS
const AI_VOICE_MAP = {
  'fr-male': 'fr-FR-RemyMultilingualNeural',
  'fr-female': 'fr-FR-DeniseNeural',
  'en-male': 'en-US-GuyNeural',
  'en-female': 'en-US-JennyNeural',
  'fr-vivienne': 'fr-FR-VivienneMultilingualNeural',
  'fr-claude': 'fr-FR-HenriNeural'
};

const AI_PERSONALITY_LABELS = {
  tactical: 'Tactique et methodique — analyse avant d\'agir',
  reckless: 'Temeraire et impulsif — fonce d\'abord, reflechit apres',
  cautious: 'Prudent et calcule — evite les risques inutiles',
  charismatic: 'Charismatique et social — parle d\'abord, combat en dernier',
  mysterious: 'Mysterieux et enigmatique — peu de mots, beaucoup de secrets',
  comic: 'Comique et leger — tout est pretexte a une blague',
  wise: 'Sage et reflechi — cite des proverbes, conseille le groupe',
  aggressive: 'Agressif et direct — aucune patience pour la diplomatie'
};

const AI_DEFAULT_NAMES = ['Kingston', 'Nyx', 'Vex', 'Zara'];
const AI_DEFAULT_VOICES = ['fr-male', 'fr-female', 'en-male', 'fr-vivienne'];
const AI_DEFAULT_PERSONALITIES = ['tactical', 'reckless', 'cautious', 'charismatic'];

function setAIPlayerCount(n) {
  campaign.aiPlayerCount = n;
  campaign.coop = n > 0;
  // Ensure array is correct length
  while (campaign.aiPlayers.length < n) {
    const idx = campaign.aiPlayers.length;
    campaign.aiPlayers.push({
      name: AI_DEFAULT_NAMES[idx] || `IA-${idx+1}`,
      concept: '',
      personality: AI_DEFAULT_PERSONALITIES[idx] || 'tactical',
      voice: AI_DEFAULT_VOICES[idx] || 'fr-male',
      character: null
    });
  }
  while (campaign.aiPlayers.length > n) campaign.aiPlayers.pop();
  // Back-compat: set kingstonChar from first AI
  if (n > 0) {
    const first = campaign.aiPlayers[0];
    campaign.kingstonChar = `${first.name}/Elf/Decker`;
  }
  renderStep();
}

/* =============================================================
   PERSISTENT CHARACTER ROSTER
   ============================================================= */
let savedRoster = []; // cached from server

async function fetchSavedRoster() {
  try {
    const data = await api('/api/dm/characters');
    savedRoster = data.characters || [];
  } catch { savedRoster = []; }
  return savedRoster;
}

async function saveCharToRoster(owner, character, gameSystem) {
  if (!character || !character.name) return null;
  const isSR = gameSystem === 'shadowrun';
  const payload = {
    owner,
    game_system: gameSystem || 'dnd5e',
    name: character.name,
    race: character.race || 'Humain',
    class: character.class || 'Guerrier',
    level: character.level || 1,
    xp: character.xp || 0,
    hp: character.hp || character.hpMax || 10,
    hp_max: character.hpMax || character.hp || 10,
    ac: character.ac || null,
    stats: character.stats || {},
    inventory: (character.equipment || '').split(',').map(s => s.trim()).filter(Boolean),
    backstory: character.background || null,
    traits: character.traits || null,
    flaw: character.flaw || null,
    bond: character.bond || null,
    ideal: character.ideal || null,
    proficiencies: character.proficiencies || null,
    equipment: character.equipment || null,
    portrait_url: character.portraitUrl || null,
    personality: character.personality || null,
    is_ai: false,
    extra: isSR ? { cyberware: character.cyberware, contacts: character.contacts, stun_max: character.stunMax } : null,
  };
  // Check if already exists
  const existing = savedRoster.find(sc =>
    sc.owner === owner && sc.name.toLowerCase() === character.name.toLowerCase() && sc.game_system === (gameSystem || 'dnd5e')
  );
  if (existing) {
    await api(`/api/dm/characters/${existing.id}`, 'PUT', payload);
    await fetchSavedRoster();
    return existing.id;
  }
  const result = await api('/api/dm/characters', 'POST', payload);
  await fetchSavedRoster();
  return result.character?.id;
}

function rosterCharsForSystem(gameSystem) {
  return savedRoster.filter(c => c.game_system === (gameSystem || 'dnd5e'));
}

function loadRosterChar(playerIndex, savedId) {
  const sc = savedRoster.find(c => c.id === savedId);
  if (!sc) return;
  const isSR = sc.game_system === 'shadowrun';
  const character = {
    name: sc.name,
    race: sc.race,
    class: sc.class,
    level: sc.level || 1,
    xp: sc.xp || 0,
    hp: sc.hp,
    hpMax: sc.hp_max,
    ac: sc.ac || (isSR ? undefined : 10),
    stats: sc.stats || {},
    proficiencies: sc.proficiencies || '',
    equipment: sc.equipment || (sc.inventory || []).join(', '),
    traits: sc.traits || '',
    flaw: sc.flaw || '',
    bond: sc.bond || '',
    ideal: sc.ideal || '',
    background: sc.backstory || '',
    portraitUrl: sc.portrait_url || '',
    isShadowrun: isSR,
    concept: `${sc.race} ${sc.class}`,
    role: sc.class,
    talents: (sc.proficiencies || '').split(',').slice(0, 5).map(s => s.trim()),
    goal: sc.bond || '',
    _savedId: sc.id,
    _fromRoster: true,
  };
  if (isSR && sc.extra) {
    character.cyberware = sc.extra.cyberware || '';
    character.contacts = sc.extra.contacts || '';
    character.stunMax = sc.extra.stun_max || 10;
  }
  campaign.players[playerIndex].character = character;
  campaign.players[playerIndex].name = campaign.players[playerIndex].name || sc.owner;
  renderStep();
}

function clearRosterChar(playerIndex) {
  campaign.players[playerIndex].character = null;
  renderStep();
}

/* =============================================================
   CHARACTER CREATION — INTERACTIVE CHAT
   ============================================================= */
let ccIndex = 0;    // current player index
let ccChat = [];    // [{role:'user'|'assistant', content}]
let ccBusy = false;
let ccIsAI = false; // true when current char creation is for an AI

function startCharCreation() {
  campaign.players.forEach((p,i) => { if (!p.name.trim()) p.name = `Joueur ${i+1}`; });
  ccIndex = 0;
  ccIsAI = false;
  ccChat = [];
  wizStep = 7;
  // Skip players who already have a character from the roster
  while (ccIndex < campaign.players.length && campaign.players[ccIndex].character && campaign.players[ccIndex].character._fromRoster) {
    ccIndex++;
  }
  if (ccIndex >= campaign.players.length) {
    // All players have roster characters — skip to AI creation or campaign gen
    if (campaign.aiPlayerCount > 0) { ccStartAICreation(); }
    else { ccGenerateCampaign(); }
    return;
  }
  renderStep();
  ccInitPlayer();
}

async function ccInitPlayer() {
  ccChat = [];
  renderCCChat();
  const p = campaign.players[ccIndex];
  const universe = campaign.universe === 'custom' ? campaign.universeCustom : campaign.universe;
  // DM sends first message
  ccBusy = true;
  ccAddTyping();
  try {
    const system = ccBuildSystem();
    const intro = `Presente-toi comme Maitre du Donjon et commence a creer le personnage du joueur "${p.name}" pour une campagne ${universe} (ton: ${campaign.tone}). Pose ta PREMIERE question pour comprendre quel type de personnage l'attire. Sois chaleureux et enthousiaste. UNE seule question a la fois.`;
    ccChat.push({role:'user', content: intro, _hidden: true}); // hidden from UI, but kept in history for Gemini
    const response = await narrateLLM(system, [{role:'user', content: intro}]);
    ccRemoveTyping();
    ccChat.push({role:'assistant', content: response});
    renderCCChat();
    speakText(response);
  } catch(err) {
    ccRemoveTyping();
    // Ensure intro is in history even on fallback
    if (!ccChat.some(m => m._hidden)) ccChat.unshift({role:'user', content: `Cree le personnage de ${p.name}`, _hidden: true});
    ccChat.push({role:'assistant', content: `Bonjour ${p.name}! Je suis votre Maitre du Donjon. Quel type de personnage vous attire? Un guerrier courageux, un mage mysterieux, un voleur agile, un pretre devot? Ou autre chose entierement? Dites-moi ce qui vous fait rever!`});
    renderCCChat();
  }
  ccBusy = false;
}

function ccBuildSystem() {
  const universe = campaign.universe === 'custom' ? campaign.universeCustom : campaign.universe;
  const p = campaign.players[ccIndex];
  if (universe === 'shadowrun') {
    return `Tu es un Game Master expert et bienveillant qui aide a creer des personnages Shadowrun.
Tu aides le joueur "${p.name}" a creer son runner pour une campagne Shadowrun (ton: ${campaign.tone}, complexite: ${campaign.complexity}).

## REGLES
- Pose des questions UNE PAR UNE, pas tout d'un coup
- Sois chaleureux, enthousiaste, suggestif (propose des idees inspirantes cyberpunk)
- Guide le joueur a travers: metatype (Humain/Elf/Nain/Ork/Troll), role (Street Samurai/Decker/Mage/Shaman/Rigger/Face/Adept/Technomancer), cyberware, background, motivations
- Apres 3-5 echanges (quand tu as assez d'info), genere la fiche avec la balise [FICHE]...[/FICHE]
- Apres la fiche, demande "Ca vous convient ou vous voulez modifier quelque chose?"

## FORMAT DE FICHE (entre les balises [FICHE] et [/FICHE])
[FICHE]
NOM: Nom du runner (+ nom de rue)
METATYPE: Metatype
ROLE: Role
HISTORIQUE: Background cyberpunk

BODY: X  AGI: X  REA: X  FOR: X
VOL: X  LOG: X  INT: X  CHA: X
EDGE: X  ESSENCE: X.X

PV_PHYSIQUE: XX  PV_STUN: XX

COMPETENCES: liste (Hacking 6, Armes a Feu 5, etc.)
CYBERWARE: liste (ou "Aucun - mage/adept")
EQUIPEMENT: liste
CONTACTS: 2-3 contacts (nom, description, loyaute 1-6)
TRAITS: personnalite de runner
DEFAUT: defaut/faiblesse
MOTIVATION: ce qui pousse le runner dans les ombres
[/FICHE]

Reponds TOUJOURS en francais. Monde: Seattle 2080, megacorps, Matrix, magie et ombres.`;
  }
  return `Tu es un Maitre du Donjon expert et bienveillant qui aide a creer des personnages D&D 5e.
Tu aides le joueur "${p.name}" a creer son personnage pour une campagne ${universe} (ton: ${campaign.tone}, complexite: ${campaign.complexity}).

## REGLES
- Pose des questions UNE PAR UNE, pas tout d'un coup
- Sois chaleureux, enthousiaste, suggestif (propose des idees inspirantes)
- Guide le joueur a travers: race, classe, historique (background), personnalite, motivations
- Apres 3-5 echanges (quand tu as assez d'info), genere la fiche avec la balise [FICHE]...[/FICHE]
- La fiche est un D&D 5e simplifie: stats calculees par toi selon la classe
- Apres la fiche, demande "Ca vous convient ou vous voulez modifier quelque chose?"
- Si le joueur demande des modifications, regenere la fiche mise a jour

## FORMAT DE FICHE (entre les balises [FICHE] et [/FICHE])
[FICHE]
NOM: Nom du personnage
RACE: Race
CLASSE: Classe (Niveau 1)
HISTORIQUE: Background

FOR: XX (+Y)  DEX: XX (+Y)  CON: XX (+Y)
INT: XX (+Y)  SAG: XX (+Y)  CHA: XX (+Y)

PV: XX   CA: XX   Initiative: +Y

MAITRISES: liste
EQUIPEMENT: liste
TRAITS: personnalite
DEFAUT: defaut/faiblesse
LIEN: ce qui motive le personnage
IDEAL: valeur fondamentale
[/FICHE]

Genere des stats coherentes avec la classe (stat principale haute). Reponds TOUJOURS en francais.`;
}

async function ccSend(textOverride) {
  if (ccBusy) return;
  const input = document.getElementById('cc-input');
  const text = textOverride || (input ? input.value.trim() : '');
  if (!text) return;
  if (input) input.value = '';

  // User is responding — cut any ongoing DM speech
  stopTTS();

  ccChat.push({role:'user', content: text});
  renderCCChat();
  ccBusy = true;
  ccAddTyping();

  try {
    const system = ccBuildSystem();
    const messages = ccChat.map(m => ({role: m.role === 'assistant' ? 'assistant' : 'user', content: m.content}));
    const response = await narrateLLM(system, messages);
    ccRemoveTyping();
    ccChat.push({role:'assistant', content: response});
    renderCCChat();
    // Check for character sheet
    const sheet = parseSheet(response);
    if (sheet) {
      campaign.players[ccIndex].character = sheet;
      renderCCSheet(sheet);
      const btn = document.getElementById('cc-validate-btn');
      if (btn) btn.style.display = 'block';
    }
    // Speak (strip [FICHE] tags)
    const cleanResponse = response.replace(/\[FICHE\][\s\S]*?\[\/FICHE\]/gi, '').trim();
    if (cleanResponse) speakText(cleanResponse);
  } catch(err) {
    ccRemoveTyping();
    ccChat.push({role:'assistant', content: 'Desole, une erreur est survenue. Reessayez!'});
    renderCCChat();
    toast('Erreur: ' + err.message);
  }
  ccBusy = false;
}

function parseSheet(text) {
  const match = text.match(/\[FICHE\]([\s\S]*?)\[\/FICHE\]/i);
  if (!match) return null;
  const raw = match[1].trim();
  const get = (key) => { const m = raw.match(new RegExp(`^${key}:\\s*(.+)`, 'mi')); return m ? m[1].trim() : ''; };
  const getStat = (key) => { const m = raw.match(new RegExp(`${key}:\\s*(\\d+)`, 'i')); return m ? parseInt(m[1]) : 10; };

  // Detect Shadowrun sheet (has METATYPE/ROLE/BODY/EDGE/ESSENCE)
  const isSR = raw.match(/METATYPE|BODY:\s*\d|ESSENCE:\s*\d/i);
  if (isSR) {
    const body=getStat('BODY'), agi=getStat('AGI'), rea=getStat('REA'), str=getStat('FOR');
    const wil=getStat('VOL'), log_=getStat('LOG'), int_=getStat('INT'), cha=getStat('CHA');
    const edge=getStat('EDGE'); const essM = raw.match(/ESSENCE:\s*([\d.]+)/i); const essence = essM ? parseFloat(essM[1]) : 6.0;
    const pvPhysM = raw.match(/PV_PHYSIQUE:\s*(\d+)/i); const pvStunM = raw.match(/PV_STUN:\s*(\d+)/i);
    return {
      name: get('NOM'), race: get('METATYPE') || get('RACE'), class: get('ROLE') || get('CLASSE'), background: get('HISTORIQUE'),
      stats: { body, agility: agi, reaction: rea, strength: str, willpower: wil, logic: log_, intuition: int_, charisma: cha, edge, essence },
      hp: pvPhysM ? parseInt(pvPhysM[1]) : Math.ceil(body/2)+8, hpMax: pvPhysM ? parseInt(pvPhysM[1]) : Math.ceil(body/2)+8,
      stunMax: pvStunM ? parseInt(pvStunM[1]) : Math.ceil(wil/2)+8,
      ac: 0, isShadowrun: true,
      proficiencies: get('COMPETENCES'), equipment: get('EQUIPEMENT'), cyberware: get('CYBERWARE'),
      contacts: get('CONTACTS'),
      traits: get('TRAITS'), flaw: get('DEFAUT'), bond: get('MOTIVATION'), ideal: '',
      _raw: raw,
      concept: `${get('METATYPE')||get('RACE')} ${get('ROLE')||get('CLASSE')}`,
      role: get('ROLE') || get('CLASSE'),
      talents: (get('COMPETENCES')||'').split(',').map(s=>s.trim()).filter(Boolean).slice(0,5),
      goal: get('MOTIVATION')
    };
  }

  const str=getStat('FOR'), dex=getStat('DEX'), con=getStat('CON'), int_=getStat('INT'), wis=getStat('SAG'), cha=getStat('CHA');
  const pvM = raw.match(/PV:\s*(\d+)/i); const caM = raw.match(/CA:\s*(\d+)/i);

  return {
    name: get('NOM'), race: get('RACE'), class: get('CLASSE'), background: get('HISTORIQUE'),
    stats: {str, dex, con, int: int_, wis, cha},
    hp: pvM ? parseInt(pvM[1]) : 10, hpMax: pvM ? parseInt(pvM[1]) : 10,
    ac: caM ? parseInt(caM[1]) : 10,
    proficiencies: get('MAITRISES'), equipment: get('EQUIPEMENT'),
    traits: get('TRAITS'), flaw: get('DEFAUT'), bond: get('LIEN'), ideal: get('IDEAL'),
    _raw: raw,
    concept: `${get('RACE')} ${get('CLASSE')}`,
    role: get('CLASSE'),
    talents: (get('MAITRISES')||'').split(',').map(s=>s.trim()).filter(Boolean).slice(0,5),
    goal: get('LIEN')
  };
}

function renderCCSheet(c) {
  const el = document.getElementById('cc-sheet-display');
  if (!el || !c) return;
  if (c.isShadowrun) {
    const s = c.stats || {};
    el.innerHTML = `<div class="sheet-title" style="color:#0ff;">${esc(c.name||'?')}</div>
<span class="stat-label">Metatype:</span> <span class="stat-row">${esc(c.race)}</span>
<span class="stat-label">Role:</span> <span class="stat-row">${esc(c.class)}</span>
<span class="stat-label">Historique:</span> <span class="stat-row">${esc(c.background)}</span>
${'─'.repeat(28)}
<span class="stat-label">BOD</span> ${s.body||3}  <span class="stat-label">AGI</span> ${s.agility||3}  <span class="stat-label">REA</span> ${s.reaction||3}  <span class="stat-label">FOR</span> ${s.strength||3}
<span class="stat-label">VOL</span> ${s.willpower||3}  <span class="stat-label">LOG</span> ${s.logic||3}  <span class="stat-label">INT</span> ${s.intuition||3}  <span class="stat-label">CHA</span> ${s.charisma||3}
<span class="stat-label" style="color:#0ff;">EDGE</span> ${s.edge||2}  <span class="stat-label" style="color:#f0f;">ESSENCE</span> ${s.essence||6.0}
${'─'.repeat(28)}
<span class="stat-label">PV Physique:</span> ${c.hp}  <span class="stat-label">PV Stun:</span> ${c.stunMax||10}
${'─'.repeat(28)}
<span class="stat-label">Competences:</span>
${esc(c.proficiencies)}
${c.cyberware ? `<span class="stat-label">Cyberware:</span>\n${esc(c.cyberware)}` : ''}
<span class="stat-label">Equipement:</span>
${esc(c.equipment)}
${c.contacts ? `<span class="stat-label">Contacts:</span>\n${esc(c.contacts)}` : ''}
${'─'.repeat(28)}
<span class="stat-label">Traits:</span> ${esc(c.traits)}
<span class="stat-label">Defaut:</span> ${esc(c.flaw)}
<span class="stat-label">Motivation:</span> ${esc(c.bond)}`;
    return;
  }
  const mod = (v) => { const m = Math.floor((v-10)/2); return m >= 0 ? `+${m}` : `${m}`; };
  el.innerHTML = `<div class="sheet-title">${esc(c.name||'?')}</div>
<span class="stat-label">Race:</span> <span class="stat-row">${esc(c.race)}</span>
<span class="stat-label">Classe:</span> <span class="stat-row">${esc(c.class)}</span>
<span class="stat-label">Historique:</span> <span class="stat-row">${esc(c.background)}</span>
${'─'.repeat(28)}
<span class="stat-label">FOR</span> ${c.stats.str} (${mod(c.stats.str)})  <span class="stat-label">DEX</span> ${c.stats.dex} (${mod(c.stats.dex)})
<span class="stat-label">CON</span> ${c.stats.con} (${mod(c.stats.con)})  <span class="stat-label">INT</span> ${c.stats.int} (${mod(c.stats.int)})
<span class="stat-label">SAG</span> ${c.stats.wis} (${mod(c.stats.wis)})  <span class="stat-label">CHA</span> ${c.stats.cha} (${mod(c.stats.cha)})
${'─'.repeat(28)}
<span class="stat-label">PV:</span> ${c.hp}  <span class="stat-label">CA:</span> ${c.ac}
${'─'.repeat(28)}
<span class="stat-label">Maitrises:</span>
${esc(c.proficiencies)}
<span class="stat-label">Equipement:</span>
${esc(c.equipment)}
${'─'.repeat(28)}
<span class="stat-label">Traits:</span> ${esc(c.traits)}
<span class="stat-label">Defaut:</span> ${esc(c.flaw)}
<span class="stat-label">Lien:</span> ${esc(c.bond)}
<span class="stat-label">Ideal:</span> ${esc(c.ideal)}`;
}

function formatSheetPreview(c) {
  if (!c || !c.name) return 'Pas de fiche';
  return c._raw || `${c.name} — ${c.race||''} ${c.class||''}\nPV:${c.hp||'?'} CA:${c.ac||'?'}`;
}

function ccValidate() {
  ccBusy = true;   // Block further messages immediately
  // Auto-save newly created character to persistent roster
  const currentPlayer = campaign.players[ccIndex];
  if (currentPlayer && currentPlayer.character && !currentPlayer.character._fromRoster) {
    const gameSystem = campaign.universe === 'shadowrun' ? 'shadowrun' : 'dnd5e';
    saveCharToRoster(currentPlayer.name, currentPlayer.character, gameSystem).catch(() => {});
  }
  ccChat = [];     // Clear chat history
  ccIndex++;
  // Skip players who already have roster characters
  while (ccIndex < campaign.players.length && campaign.players[ccIndex].character && campaign.players[ccIndex].character._fromRoster) {
    ccIndex++;
  }
  if (ccIndex < campaign.players.length) {
    // Next human player
    ccIsAI = false;
    renderStep();
    ccInitPlayer();
  } else if (campaign.aiPlayerCount > 0) {
    // Human players done — start AI character creation
    ccStartAICreation();
  } else {
    // All done — generate campaign outline then go to review
    ccGenerateCampaign();
  }
}

// ── AI Conversational Character Creation ──
let aiCreateIndex = 0;
let aiCCMessages = []; // conversation history for current AI char creation

async function ccStartAICreation() {
  aiCreateIndex = 0;
  ccIsAI = true;
  wizStep = 7; // Stay in char creation view
  await ccCreateNextAI();
}

function aiCCRenderChat(aiName, color) {
  const scroll = document.getElementById('cc-scroll');
  if (!scroll) return;
  scroll.innerHTML = aiCCMessages.filter(m => !m._hidden).map(m => {
    if (m.role === 'dm') {
      return `<div class="msg msg-dm fade-in"><div class="avatar">&#128009;</div><div><div class="turn-label">Maitre du Donjon</div><div class="bubble">${fmtNarrative(m.content)}</div></div></div>`;
    } else {
      return `<div class="msg msg-ai fade-in"><div class="avatar" style="background:linear-gradient(135deg,${color},${color}88);color:#000;">&#129302;</div><div><div class="turn-label" style="color:${color};">${esc(aiName)}</div><div class="bubble" style="border-left:3px solid ${color};">${fmtNarrative(m.content)}</div></div></div>`;
    }
  }).join('');
  scroll.scrollTop = scroll.scrollHeight;
}

async function ccCreateNextAI() {
  if (aiCreateIndex >= campaign.aiPlayerCount) {
    ccIsAI = false;
    ccGenerateCampaign();
    return;
  }

  const ai = campaign.aiPlayers[aiCreateIndex];
  const universe = campaign.universe === 'custom' ? campaign.universeCustom : campaign.universe;
  const isSR = universe === 'shadowrun';
  const personality = AI_PERSONALITY_LABELS[ai.personality] || ai.personality;
  const existingChars = campaign.players.map(p => p.character?.name ? `${p.character.name} (${p.character.class||''})` : p.name).join(', ');
  const aiOtherChars = campaign.aiPlayers.filter((_,j) => j < aiCreateIndex).map(a => a.character?.name ? `${a.character.name} (${a.character.class||''})` : a.name).join(', ');
  const allChars = [existingChars, aiOtherChars].filter(Boolean).join(', ');
  const color = ['#0ff','#f0f','#0f0','#ff0'][aiCreateIndex % 4];

  // Setup UI
  const el = document.querySelector('.wiz-content');
  if (el) {
    el.innerHTML = `
    <div class="cc-header">
      <div class="player-badge" style="color:${color};">&#129302; ${esc(ai.name)} cree son personnage...</div>
      <div class="progress">IA ${aiCreateIndex+1} / ${campaign.aiPlayerCount}</div>
    </div>
    <div class="cc-layout">
      <div class="cc-chat">
        <div class="cc-chat-scroll" id="cc-scroll"></div>
      </div>
      <div class="cc-sheet">
        <div class="cc-sheet-card" id="cc-sheet-display">
          <div class="sheet-title" style="color:${color};">${esc(ai.name)}</div>
          <span style="color:var(--text-muted);font-style:italic;">En conversation avec le DM...</span>
        </div>
        <div style="margin-top:10px;">
          <div style="background:${color}15;border-radius:6px;padding:8px;font-size:0.8em;color:${color};">
            Personnalite: ${esc(personality)}<br>
            Voix: ${esc(ai.voice)}
          </div>
        </div>
      </div>
    </div>`;
  }

  aiCCMessages = [];
  const srOptions = campaign.shadowrunOptions || {};

  // Diversity seed: random hooks to push unique character concepts
  const diversityHooks = [
    'un personnage avec un secret honteux', 'quelqu\'un qui a trahi son ancien groupe',
    'un ancien soldat reconverti', 'un artiste/musicien qui a mal tourne',
    'un scientifique obsede par une decouverte', 'un refugie d\'un autre plan/pays',
    'quelqu\'un qui cherche a se racheter', 'un ancien criminel devenu juste',
    'un noble dechu qui a tout perdu', 'un orphelin eleve par des non-humains',
    'un pacifiste force de se battre', 'un menteur compulsif au grand coeur',
    'un excentrique collectionneur d\'objets bizarres', 'un ancien prisonnier evade',
    'un mystique qui entend des voix', 'quelqu\'un qui a peur du noir',
    'un gourmet qui juge tout le monde par sa cuisine', 'un joueur de cartes professionnel',
    'un ex-garde du corps d\'une celebrite', 'un inventeur rate mais optimiste'
  ];
  const hook = diversityHooks[Math.floor(Math.random() * diversityHooks.length)];

  // List existing characters to enforce uniqueness
  const existingConcepts = [...campaign.players.map(p => p.character ? `${p.character.name} (${p.character.race} ${p.character.class})` : ''),
    ...campaign.aiPlayers.filter((_,j) => j < aiCreateIndex && _.character).map(a => `${a.character.name} (${a.character.race} ${a.character.class})`)
  ].filter(Boolean).join(', ');
  const uniqueRule = existingConcepts ? `\nPERSONNAGES DEJA CREES: ${existingConcepts}. Tu DOIS etre TOTALEMENT DIFFERENT — autre race, autre classe, autre style de jeu. Pas de doublon!` : '';

  // System prompts with full context
  const dmSystem = isSR ?
    `Tu es un Game Master Shadowrun bienveillant. Tu aides ${ai.name} a creer son runner. Le groupe actuel: ${allChars || 'aucun encore'}.${uniqueRule} ${srOptions.runType && srOptions.runType !== 'random' ? 'Type de run: '+srOptions.runType+'.' : ''} Pose des questions pour comprendre les motivations et le style du joueur. Sois chaleureux, enthousiaste, en francais. UNE question a la fois, 2-3 phrases max. Ne repete JAMAIS une question deja posee.` :
    `Tu es un Dungeon Master D&D 5e bienveillant. Tu aides ${ai.name} a creer son personnage pour une campagne ${universe} (ton: ${campaign.tone}). Le groupe actuel: ${allChars || 'aucun encore'}.${uniqueRule} Pose des questions pour comprendre les motivations et le style du joueur. Sois chaleureux, en francais. UNE question a la fois, 2-3 phrases max. Ne repete JAMAIS une question deja posee.`;

  const aiSystem = isSR ?
    `Tu es ${ai.name}. Personnalite: ${personality}. Tu es un joueur qui cree son runner Shadowrun. Le groupe actuel: ${allChars || 'aucun encore'}.${uniqueRule}
Inspiration secrete (base-toi la-dessus pour ton concept): ${hook}.
Tu reponds au Maitre du Donjon avec enthousiasme et en restant IN CHARACTER selon ta personnalite. Reponds en 2-4 phrases max, en francais, a la premiere personne. Sois ORIGINAL — ne repete jamais ce que tu as deja dit.` :
    `Tu es ${ai.name}. Personnalite: ${personality}. Tu es un joueur qui cree son personnage D&D 5e pour une campagne ${universe}. Le groupe actuel: ${allChars || 'aucun encore'}.${uniqueRule}
Inspiration secrete (base-toi la-dessus pour ton concept): ${hook}.
Tu reponds au Maitre du Donjon avec enthousiasme et en restant IN CHARACTER selon ta personnalite. Reponds en 2-4 phrases max, en francais, a la premiere personne. Sois ORIGINAL — ne repete jamais ce que tu as deja dit.`;

  const sheetFormat = isSR ?
    'Format: NOM, METATYPE, ROLE, HISTORIQUE, BODY/AGI/REA/FOR/VOL/LOG/INT/CHA, EDGE, ESSENCE, PV_PHYSIQUE, PV_STUN, COMPETENCES, CYBERWARE, EQUIPEMENT, CONTACTS, TRAITS, DEFAUT, MOTIVATION.' :
    'Format: NOM, RACE, CLASSE, HISTORIQUE, FOR/DEX/CON/INT/SAG/CHA, PV, CA, MAITRISES, EQUIPEMENT, TRAITS, DEFAUT, LIEN, IDEAL.';

  try {
    // Full conversation history for DM and AI (context is accumulated)
    const dmHistory = [];
    const aiHistory = [];

    // === TURN 1: DM greets the AI and asks first question ===
    dmHistory.push({role:'user', content: `Accueille ${ai.name} et pose ta premiere question pour comprendre quel type de personnage l'attire. Sois chaleureux et original.`});
    const dmGreet = await narrateLLM(dmSystem, dmHistory);
    dmHistory.push({role:'assistant', content: dmGreet});
    aiCCMessages.push({role:'dm', content: dmGreet});
    aiCCRenderChat(ai.name, color);
    await speakText(dmGreet);

    // === TURN 2: AI responds with motivations ===
    aiHistory.push({role:'user', content: `Le Maitre du Donjon dit: "${dmGreet}"\nReponds avec passion. Ton inspiration secrete: ${hook}. Explique quel type de personnage te fait rever et POURQUOI. Quelles sont tes motivations profondes?`});
    const aiResp1 = await narrateLLM(aiSystem, aiHistory);
    aiHistory.push({role:'assistant', content: aiResp1});
    aiCCMessages.push({role:'ai', content: aiResp1});
    aiCCRenderChat(ai.name, color);
    await speakTextWithVoice(aiResp1, ai.voice);

    // === TURN 3: DM reacts and digs deeper ===
    dmHistory.push({role:'user', content: `${ai.name} repond: "${aiResp1}"\nReagis a ses choix specifiques. Pose une question DIFFERENTE — sur son passe personnel, un evenement marquant, ou une relation importante. Pas de question sur la classe/race, creuse l'HISTOIRE.`});
    const dmResp2 = await narrateLLM(dmSystem, dmHistory);
    dmHistory.push({role:'assistant', content: dmResp2});
    aiCCMessages.push({role:'dm', content: dmResp2});
    aiCCRenderChat(ai.name, color);
    await speakText(dmResp2);

    // === TURN 4: AI elaborates on backstory ===
    aiHistory.push({role:'user', content: `Le DM repond: "${dmResp2}"\nApprofondi un aspect NOUVEAU de ton personnage — un souvenir precis, un trauma, un reve, une peur. Ne repete pas ce que tu as deja dit. Ajoute de la profondeur.`});
    const aiResp2 = await narrateLLM(aiSystem, aiHistory);
    aiHistory.push({role:'assistant', content: aiResp2});
    aiCCMessages.push({role:'ai', content: aiResp2});
    aiCCRenderChat(ai.name, color);
    await speakTextWithVoice(aiResp2, ai.voice);

    // === TURN 5: DM wraps up ===
    dmHistory.push({role:'user', content: `${ai.name} ajoute: "${aiResp2}"\nResume son personnage unique en 2 phrases enthousiastes. Mentionne ce qui le rend SPECIAL. Dis-lui que tu vas finaliser sa fiche.`});
    const dmWrapup = await narrateLLM(dmSystem, dmHistory);
    aiCCMessages.push({role:'dm', content: dmWrapup});
    aiCCRenderChat(ai.name, color);
    await speakText(dmWrapup);

    // === FINAL: AI generates the character sheet ===
    const fullConvo = `Tour 1 — DM: ${dmGreet}\nTour 2 — ${ai.name}: ${aiResp1}\nTour 3 — DM: ${dmResp2}\nTour 4 — ${ai.name}: ${aiResp2}\nTour 5 — DM: ${dmWrapup}`;
    const sheetSystem = isSR ?
      `Tu es ${ai.name}. Voici ta conversation COMPLETE avec le DM:\n${fullConvo}\n\nGenere ta fiche COMPLETE entre [FICHE] et [/FICHE]. ${sheetFormat} Monde: Seattle 2080.${uniqueRule} Ajoute un court commentaire (1-2 phrases) avant la fiche. Reponds en francais.` :
      `Tu es ${ai.name}. Voici ta conversation COMPLETE avec le DM:\n${fullConvo}\n\nGenere ta fiche COMPLETE entre [FICHE] et [/FICHE]. ${sheetFormat}${uniqueRule} Ajoute un court commentaire (1-2 phrases) avant la fiche. Reponds en francais.`;
    const sheetResponse = await narrateLLM(sheetSystem, [{role:'user', content: `Genere ta fiche maintenant, ${ai.name}. Base-la sur TOUT ce que tu as dit au DM — chaque detail compte.`}]);

    // Parse sheet
    const sheet = parseSheet(sheetResponse);
    if (sheet) {
      ai.character = sheet;
      renderCCSheet(sheet);
      const cleanComment = sheetResponse.replace(/\[FICHE\][\s\S]*?\[\/FICHE\]/gi, '').trim();
      if (cleanComment) {
        aiCCMessages.push({role:'ai', content: cleanComment});
        aiCCRenderChat(ai.name, color);
        await speakTextWithVoice(cleanComment, ai.voice);
      }
    } else {
      // Fallback: retry with explicit instructions
      toast(`${ai.name}: fiche non detectee, nouvelle tentative...`);
      const retry = await narrateLLM(sheetSystem, [{role:'user', content: `IMPORTANT: Genere ta fiche MAINTENANT entre [FICHE] et [/FICHE]. Pas de questions.`}]);
      const retrySheet = parseSheet(retry);
      if (retrySheet) {
        ai.character = retrySheet;
        renderCCSheet(retrySheet);
      }
    }

    await new Promise(r => setTimeout(r, 1000));
    aiCreateIndex++;
    await ccCreateNextAI();
  } catch (err) {
    toast(`Erreur creation IA ${ai.name}: ${err.message}`);
    aiCreateIndex++;
    await ccCreateNextAI();
  }
}

async function ccGenerateCampaign() {
  wizStep = 8;
  renderStep();
  const universe = campaign.universe === 'custom' ? campaign.universeCustom : campaign.universe;
  const humanChars = campaign.players.map(p => `${p.character?.name||p.name} (${p.character?.class||'?'})`).join(', ');
  const aiChars = (campaign.aiPlayers || []).filter(a => a.character).map(a => `${a.character.name} (${a.character.class||'?'}, IA)`).join(', ');
  const chars = [humanChars, aiChars].filter(Boolean).join(', ');
  const srOpts = campaign.shadowrunOptions || {};
  try {
    const ruleLabel = universe === 'shadowrun' ? 'Shadowrun' : 'D&D';
    const system = `Tu es un concepteur de campagnes ${ruleLabel} expert. Reponds UNIQUEMENT en JSON valide sans backticks ni markdown.`;
    const srExtra = universe === 'shadowrun' && srOpts.runType ? `\nType de run: ${srOpts.runType}. District: ${srOpts.district}. Megacorp: ${srOpts.megacorp}.` : '';
    const prompt = `Genere un blueprint COMPLET de campagne pour: univers=${universe}, ton=${campaign.tone}, complexite=${campaign.complexity}, personnages=[${chars}].${srExtra}

Le JSON doit contenir:
- campaign_name: nom evocateur
- hook: accroche en 2 phrases
- ending: description de la resolution finale (boss, twist, comment gagner)
- story_beats: 4-5 etapes narratives avec id (1-5), title, description, trigger (quand ca se declenche), completed (false)
- map: 5-8 lieux connectes avec id, name, description courte, connections (ids des lieux adjacents)
- key_npcs: 3-5 PNJ importants avec name, description, attitude (allie/neutre/hostile), location (id du lieu)
- starting_location: id du lieu de depart (doit correspondre a un id de map)
- factions: 2-3 factions avec name, goal, attitude (allie/neutre/hostile)

JSON: {"campaign_name":"","hook":"","ending":"","story_beats":[{"id":1,"title":"","description":"","trigger":"","completed":false}],"map":[{"id":"","name":"","description":"","connections":[]}],"key_npcs":[{"name":"","description":"","attitude":"","location":""}],"starting_location":"","factions":[{"name":"","goal":"","attitude":""}]}`;
    const raw = await narrateLLM(system, [{role:'user', content: prompt}]);
    let json = raw.trim();
    if (json.startsWith('```')) json = json.replace(/^```json?\n?/,'').replace(/\n?```$/,'');
    const data = JSON.parse(json);
    // Store the full blueprint
    campaign.blueprint = data;
    campaign.name = data.campaign_name || 'Aventure';
    // Build arc outline from beats for backward compat
    const beatsSummary = (data.story_beats||[]).map(b => `${b.id}. ${b.title}: ${b.description}`).join('\n');
    campaign.arcOutline = `Hook: ${data.hook}\nFin: ${data.ending}\n\nEtapes:\n${beatsSummary}`;
    // Find starting location name from map
    const startLoc = (data.map||[]).find(m => m.id === data.starting_location);
    campaign.location = startLoc?.name || data.starting_location || 'Lieu de depart';
    campaign.npcs = (data.key_npcs||[]).map(n => ({ name: n.name, description: n.description, attitude: n.attitude || 'neutre' }));
    // Initialize sceneState with first beat
    if (data.story_beats?.length) {
      campaign.sceneState.nextBeat = data.story_beats[0];
    }
  } catch(e) {
    console.warn('Blueprint generation failed, using fallback:', e);
    campaign.name = campaign.name || 'Aventure ' + universe;
    campaign.location = campaign.location || 'Taverne du Dragon';
  }

  // Generate poster via Gemini (fire-and-forget, update DOM when ready)
  const posterChars = campaign.players.map(p => p.character?.concept || p.character?.class || 'adventurer').join(', ');
  campaign.posterUrl = ''; // will be set async
  genImg(`epic ${campaign.tone} ${universe} adventure movie poster, ${posterChars}, dramatic composition, cinematic, title card, professional book cover art`).then(url => {
    campaign.posterUrl = url;
    const posterEl = document.getElementById('campaign-poster');
    if (posterEl) posterEl.innerHTML = `<img src="${esc(url)}" onclick="openLB('${esc(url)}')" style="width:100%;border-radius:8px;cursor:pointer;">`;
    autoSave();
  });

  // Generate map from blueprint locations via Gemini
  if (campaign.blueprint?.map?.length) {
    const mapNames = campaign.blueprint.map.map(l => l.name).join(', ');
    campaign.blueprintMapUrl = ''; // will be set async
    genMap(`${campaign.name} world map, locations: ${mapNames}, fantasy RPG cartography`).then(url => {
      campaign.blueprintMapUrl = url;
      const mapEl = document.getElementById('blueprint-map');
      if (mapEl) mapEl.innerHTML = `<img src="${esc(url)}" onclick="openLB('${esc(url)}')" style="width:100%;border-radius:8px;cursor:pointer;">`;
      autoSave();
    });
  }

  // Generate character portraits via Gemini (fire-and-forget)
  generatePortraits();

  renderStep(); // re-render step 8 with campaign name + visuals
}

async function generatePortraits() {
  const promises = campaign.players.map(async (p, i) => {
    const c = p.character;
    if (!c) return;
    // Show shimmer immediately
    const imgEl = document.getElementById(`portrait-img-${i}`);
    if (imgEl) imgEl.innerHTML = `<div class="img-shimmer" style="height:180px;">Portrait...</div>`;
    try {
      const system = 'Generate a concise visual portrait description in English for a fantasy RPG character illustration. Return ONLY the description (1-2 sentences), no preamble.';
      const prompt = `Character: ${c.name}, ${c.race}, ${c.class}\nEquipment: ${c.equipment || 'standard gear'}\nTraits: ${c.traits || 'determined'}\nFlaw: ${c.flaw || 'none'}`;
      const desc = await narrateLLM(system, [{role:'user', content: prompt}]);
      c.portraitUrl = await genImg(desc.substring(0, 300) + ', fantasy RPG character portrait, detailed, painterly, dramatic lighting');
    } catch(e) {
      // Fallback: generate directly from character data
      c.portraitUrl = await genImg(`${c.race || 'human'} ${c.class || 'adventurer'} RPG character portrait, ${(c.traits || 'determined').substring(0,60)}, fantasy art, painterly, detailed, dramatic lighting`);
    }
    // Update DOM if step 8 is visible
    if (imgEl && c.portraitUrl) {
      imgEl.innerHTML = `<img src="${esc(c.portraitUrl)}" onclick="openLB('${esc(c.portraitUrl)}')" loading="lazy" style="width:100%;height:100%;object-fit:cover;">`;
    }
  });
  await Promise.all(promises);
}

function renderCCChat() {
  const el = document.getElementById('cc-scroll');
  if (!el) return;
  el.innerHTML = ccChat.filter(m => !m._hidden).map(m => {
    if (m.role === 'assistant') {
      const clean = m.content.replace(/\[FICHE\][\s\S]*?\[\/FICHE\]/gi, '<em style="color:var(--green);font-size:12px;">[Fiche generee &#10003;]</em>');
      return `<div class="cc-msg dm"><div class="av">&#128009;</div><div class="bub">${fmtNarrative(clean)}</div></div>`;
    }
    return `<div class="cc-msg player"><div class="bub">${esc(m.content)}</div></div>`;
  }).join('');
  el.scrollTop = el.scrollHeight;
}
function ccAddTyping() {
  const el = document.getElementById('cc-scroll');
  if (!el) return;
  el.innerHTML += `<div class="cc-msg dm" id="cc-typing"><div class="av">&#128009;</div><div class="bub"><div class="typing"><div class="typing-dots"><span></span><span></span><span></span></div> Le MdD reflechit...</div></div></div>`;
  el.scrollTop = el.scrollHeight;
}
function ccRemoveTyping() { const t = document.getElementById('cc-typing'); if (t) t.remove(); }

// Voice for char creation is handled by the global toggle mic + silence detection
// The recognition.onresult handler auto-detects which view is active (cc-input vs action-input)

/* =============================================================
   START ADVENTURE
   ============================================================= */
async function startAdventure() {
  campaign.createdAt = Date.now();
  campaign.updatedAt = Date.now();
  showGame();
  // Auto-enable ambient sound on adventure start (user interaction = can start audio)
  if (!AmbientEngine.isEnabled()) AmbientEngine.toggle();
  // Generate campaign poster image (Gemini, async, no-wait)
  generateCampaignPoster();
  // Generate opening scene via LLM
  addTypingIndicator();
  try {
    const system = buildDMPrompt();
    const openingPrompt = `Commence l'aventure. Decris la scene d'ouverture de maniere atmospherique et immersive. Presente le lieu de depart, l'ambiance, et donne aux joueurs leur premiere accroche narrative. Termine par un moment qui demande une action ou un choix. Inclus [IMAGE: description en anglais] et [LOCATION: nom du lieu].`;
    let streamStarted = false;
    const narrative = await narrateLLMStream(system, [{ role:'user', content: openingPrompt }], (accumulated) => {
      if (!streamStarted) {
        removeTypingIndicator();
        const el = document.getElementById('narrative');
        el.innerHTML += `<div class="msg msg-dm fade-in" id="opening-stream"><div class="avatar">&#128009;</div><div><div class="turn-label">Ouverture</div><div class="bubble" id="opening-stream-text"></div></div></div>`;
        streamStarted = true;
      }
      const bubbleEl = document.getElementById('opening-stream-text');
      if (bubbleEl) {
        const clean = accumulated.replace(/\[(IMAGE|MAP|NPC|QUEST|LOCATION|ITEM|THREAD|ROLL|HP|CONDITION|XP|SPELL|LEVEL):[^\]]*\]/gi, '').trim();
        bubbleEl.innerHTML = fmtNarrative(clean);
        const narEl = document.getElementById('narrative');
        narEl.scrollTop = narEl.scrollHeight;
      }
    });
    if (!streamStarted) removeTypingIndicator();
    const openStream = document.getElementById('opening-stream');
    if (openStream) openStream.remove();
    const parsed = parseDMResponse(narrative);
    campaign.turnNumber = 1;
    const turn = { player: 'DM', action: '', narrative: parsed.narrative, images: [], maps: [], turn: 0, ts: Date.now() };
    // Process tags (pass raw narrative for character tag parsing)
    processResponseTags(parsed.tags, turn, narrative);

    // Auto-image fallback for opening scene
    if (!parsed.tags.images.length) {
      const sceneDesc = (campaign.location || 'fantasy tavern') + ', opening scene, ' + parsed.narrative.substring(0, 120).replace(/['"]/g, '');
      fireImg(sceneDesc, turn);
    }

    campaign.turns.push(turn);
    campaign.updatedAt = Date.now();

    // Initialize sceneState with opening narrative (fire-and-forget)
    if (campaign.blueprint?.story_beats?.length && !campaign.sceneState.nextBeat) {
      campaign.sceneState.nextBeat = campaign.blueprint.story_beats[0];
    }
    updateSceneState('', parsed.narrative);

    renderGame();
    await speakText(parsed.narrative);
    autoSave();
  } catch(err) {
    removeTypingIndicator();
    toast('Erreur: ' + err.message);
  }
}

/* =============================================================
   SCENE STATE & MAP HELPERS
   ============================================================= */
function buildSceneStateSection() {
  const ss = campaign.sceneState;
  if (!ss || (!ss.activeThreads.length && !ss.environment && !ss.npcsPresent.length)) return '';
  let section = '\n## ETAT DE SCENE (CRITIQUE — TU DOIS RESPECTER)\n';
  if (ss.activeThreads.length) {
    section += '-- Fils actifs:\n';
    ss.activeThreads.forEach(t => {
      const urgLabel = t.urgency === 'high' ? ' ← NE PAS OUBLIER' : t.urgency === 'medium' ? ' ← IMPORTANT' : '';
      section += `   * ${t.description} (urgence: ${t.urgency}, depuis ${t.turnsActive} tour${t.turnsActive > 1 ? 's' : ''})${urgLabel}\n`;
    });
  }
  if (ss.npcsPresent.length) section += `-- PNJs presents: ${ss.npcsPresent.join(', ')}\n`;
  if (ss.environment) section += `-- Environnement: ${ss.environment}\n`;
  if (ss.mood) section += `-- Ambiance: ${ss.mood}\n`;
  if (ss.nextBeat) section += `-- Prochaine etape narrative: "${ss.nextBeat.title}" — guide les joueurs vers: ${ss.nextBeat.description}\n`;
  if (ss.pendingConsequences.length) {
    section += '-- Consequences en attente:\n';
    ss.pendingConsequences.forEach(c => { section += `   * ${c}\n`; });
  }
  section += '\nREGLE ABSOLUE: Chaque fil actif DOIT etre mentionne ou avance dans ta reponse.\n';
  section += 'Si un fil est marque "urgence haute", il DOIT avoir un impact concret CE TOUR.\n';
  return section;
}

function buildMapSection() {
  const bp = campaign.blueprint;
  if (!bp?.map?.length) return '';
  let section = '\n## MAP DU MONDE\n';
  bp.map.forEach(loc => {
    const conns = loc.connections.map(cid => {
      const target = bp.map.find(m => m.id === cid);
      return target?.name || cid;
    }).join(', ');
    section += `${loc.name} (${loc.id}) ↔ [${conns}]\n`;
  });
  section += `Position actuelle: ${campaign.location || 'Inconnu'}\n`;
  if (bp.factions?.length) {
    section += '\n## FACTIONS\n';
    bp.factions.forEach(f => { section += `- ${f.name}: ${f.goal} (${f.attitude})\n`; });
  }
  return section;
}

/* =============================================================
   DM SYSTEM PROMPT BUILDER
   ============================================================= */
function buildDMPrompt() {
  const universe = campaign.universe === 'custom' ? campaign.universeCustom : campaign.universe;
  const charDesc = campaign.players.map(p => {
    const c = p.character || {};
    const s = c.stats || {};
    const condStr = (c.conditions||[]).map(x => `${x.name}${x.duration?'('+x.duration+'t)':''}`).join(', ') || 'aucune';
    const spellStr = Object.entries(c.spellSlots||{}).map(([lvl,s]) => `niv${lvl}:${s.max-s.used}/${s.max}`).join(', ') || 'N/A';
    return `**${c.name || p.name}** (Joueur: ${p.name})
${c.race||'?'}, ${c.class||'?'}${c.level ? ' Niv.'+c.level : ''}, Historique: ${c.background||'?'}
FOR ${s.str||10} DEX ${s.dex||10} CON ${s.con||10} INT ${s.int||10} SAG ${s.wis||10} CHA ${s.cha||10}
PV: ${c.hp||10}/${c.hpMax||10}, CA: ${c.ac||10}${c.xp ? ', XP: '+c.xp : ''}
Conditions: ${condStr}
Emplacements sorts: ${spellStr}
Maitrises: ${c.proficiencies||'?'}
Equipement: ${c.equipment||'?'}
Traits: ${c.traits||'?'} | Defaut: ${c.flaw||'?'} | Lien: ${c.bond||'?'} | Ideal: ${c.ideal||'?'}`;
  }).join('\n\n');

  // Add AI player characters
  const aiCharDesc = (campaign.aiPlayers || []).filter(a => a.character).map(ai => {
    const c = ai.character;
    const s = c.stats || {};
    if (c.isShadowrun) {
      return `**${c.name}** (IA: ${ai.name}, personnalite: ${ai.personality})
${c.race||'?'}, ${c.class||'?'}, Historique: ${c.background||'?'}
BOD ${s.body||3} AGI ${s.agility||3} REA ${s.reaction||3} LOG ${s.logic||3} CHA ${s.charisma||3} EDGE ${s.edge||2} ESS ${s.essence||6}
PV Physique: ${c.hp||10}/${c.hpMax||10}, PV Stun: ${c.stunMax||10}
Equipement: ${c.equipment||'?'}`;
    }
    return `**${c.name}** (IA: ${ai.name}, personnalite: ${ai.personality})
${c.race||'?'}, ${c.class||'?'}${c.level ? ' Niv.'+c.level : ''}, Historique: ${c.background||'?'}
FOR ${s.str||10} DEX ${s.dex||10} CON ${s.con||10} INT ${s.int||10} SAG ${s.wis||10} CHA ${s.cha||10}
PV: ${c.hp||10}/${c.hpMax||10}, CA: ${c.ac||10}
Equipement: ${c.equipment||'?'}`;
  }).join('\n\n');

  const consentRules = [];
  if (!campaign.consents.violence) consentRules.push('Evite la violence explicite');
  if (!campaign.consents.horror) consentRules.push('Evite les elements horrifiques');
  if (!campaign.consents.romance) consentRules.push('Evite les elements romantiques');
  if (!campaign.consents.death) consentRules.push('Les personnages joueurs ne peuvent pas mourir definitivement');

  const questSummary = campaign.quests.length ? campaign.quests.map(q => `- ${q.name} (${q.status}): ${q.detail}`).join('\n') : 'Aucune quete active';
  const npcSummary = campaign.npcs.length ? campaign.npcs.map(n => `- ${n.name}: ${n.description} (${n.attitude || '?'})`).join('\n') : 'Aucun PNJ notable';
  const recentTurns = campaign.turns.slice(-8).map(t => {
    let s = '';
    if (t.action) s += `[${t.player}]: ${t.action}\n`;
    if (t.narrative) s += `[MdD]: ${t.narrative.substring(0,300)}`;
    return s;
  }).join('\n---\n');

  const isShadowrun = universe === 'shadowrun';
  const dmTitle = isShadowrun ? 'Game Master (GM)' : 'Maitre du Donjon (MdD)';
  const diceInstruction = isShadowrun
    ? 'Utilise des dice pools Shadowrun pour les moments critiques via la balise [ROLL:] — indique le pool (ex: Agilite+Armes a Feu = 10d6)'
    : 'Utilise des jets de des pour les moments critiques (combat, pieges, perception, persuasion) via la balise [ROLL:]';
  const shadowrunExtra = isShadowrun ? `
- Monde: Seattle 2080, megacorps, Matrix, magie coexistent
- Dice pools d6: succes sur 5-6, glitch si >moitie sont des 1
- Combat: initiative, jets opposes, pistes physique/stun
- Utilise le jargon shadowrun: run, fixer, johnson, nuyen, SIN, IC, drek
- Matrix et magie sont aussi dangereuses que les balles` : '';

  return `Tu es le ${dmTitle}, un narrateur expert qui orchestre une aventure immersive de jeu de role.

## TON STYLE
- Ton: ${campaign.tone}
- Univers: ${universe}${isShadowrun ? ' (Cyberpunk 2080, ombres, megacorps, Matrix, magie)' : ''}
- Complexite: ${campaign.complexity}
- Tu parles TOUJOURS en francais
- Tu es descriptif, atmospherique, tu engages les sens (vue, ouie, odeur, toucher)
- Tes reponses font 2-4 paragraphes (concis pour le vocal)
- Tu proposes toujours 2-3 options d'action a la fin
- ${diceInstruction}
- Apres un jet de des, le joueur te donnera son resultat et tu continues la narration en consequence
- Tu t'adresses aux joueurs par le nom de leur personnage${shadowrunExtra}
${consentRules.length ? '\n## LIMITES DE CONTENU\n' + consentRules.join('\n') : ''}

## PERSONNAGES JOUEURS
${charDesc}
${aiCharDesc ? `\n## PERSONNAGES IA (jouent automatiquement)\n${aiCharDesc}` : ''}

## ARC NARRATIF
${campaign.arcOutline || 'A definir'}

## ETAT ACTUEL
- Lieu: ${campaign.location || 'Inconnu'}
- Tour: ${campaign.turnNumber}
- PNJ connus: ${npcSummary}
- Quetes: ${questSummary}
${buildSceneStateSection()}
${buildMapSection()}
## HISTORIQUE RECENT
${recentTurns || 'Debut de l\'aventure'}

## BALISES SPECIALES (inclus dans ta reponse)
[IMAGE: description detaillee en anglais pour generation d'image, style ${isShadowrun ? 'cyberpunk neon rain' : 'fantaisie'}] — OBLIGATOIRE a CHAQUE reponse!
[MAP: description en anglais pour carte top-down du lieu]
[NPC: Nom | description physique et personnalite]
[QUEST: Nom | nouveau/en_cours/complete | detail]
[LOCATION: Nouveau nom du lieu]
[ITEM: Nom du personnage | +Objet ou -Objet]
[THREAD: description du fil narratif | low/medium/high]
[ROLL: Description du jet requis | notation (ex: d20, d20+3, 2d6+1)]
[HP: Nom du personnage | +N ou -N ou =N] — changement de PV (degats: -5, soin: +3, set: =20)
[CONDITION: Nom du personnage | condition | duree_tours] — ajouter une condition (poisoned, stunned, frightened, blessed, hasted, invisible, etc.)
[CONDITION: Nom du personnage | -condition] — retirer une condition
[XP: Nom du personnage | +N] — gagner des points d'experience
[SPELL: Nom du personnage | niveau_sort | -1] — consommer un emplacement de sort

REGLES CRITIQUES:
1. Tu DOIS inclure [IMAGE:] dans CHAQUE reponse — decris la scene en anglais detaille.
2. Utilise [HP:] a CHAQUE combat ou soin — indique les degats/soins exacts pour chaque personnage affecte.
3. Utilise [CONDITION:] quand un personnage gagne ou perd un etat (empoisonne, etourdi, beni, etc.)
4. Utilise [XP:] apres chaque combat gagne ou quete completee.
5. Les autres balises sont optionnelles (changement de scene, nouveau PNJ, evolution de quete, etc.)`;
}

/* =============================================================
   RESPONSE PARSER
   ============================================================= */
function parseDMResponse(text) {
  const tags = { images:[], maps:[], npcs:[], quests:[], location:null, items:[], threads:[], roll:null };
  let narrative = text;
  narrative = narrative.replace(/\[IMAGE:\s*(.+?)\]/gi, (_,d) => { tags.images.push(d.trim()); return ''; });
  narrative = narrative.replace(/\[MAP:\s*(.+?)\]/gi, (_,d) => { tags.maps.push(d.trim()); return ''; });
  narrative = narrative.replace(/\[NPC:\s*(.+?)\]/gi, (_,d) => {
    const [name,...rest] = d.split('|');
    tags.npcs.push({ name:name.trim(), description:rest.join('|').trim(), attitude:'neutre' });
    return '';
  });
  narrative = narrative.replace(/\[QUEST:\s*(.+?)\]/gi, (_,d) => {
    const parts = d.split('|');
    tags.quests.push({ name:(parts[0]||'').trim(), status:(parts[1]||'').trim(), detail:(parts[2]||'').trim() });
    return '';
  });
  narrative = narrative.replace(/\[LOCATION:\s*(.+?)\]/gi, (_,d) => { tags.location = d.trim(); return ''; });
  narrative = narrative.replace(/\[ITEM:\s*(.+?)\]/gi, (_,d) => { tags.items.push(d.trim()); return ''; });
  narrative = narrative.replace(/\[THREAD:\s*(.+?)\]/gi, (_,d) => {
    const parts = d.split('|');
    const desc = (parts[0]||'').trim();
    const urgency = (parts[1]||'medium').trim().toLowerCase();
    tags.threads.push({ description: desc, urgency: ['low','medium','high'].includes(urgency) ? urgency : 'medium' });
    return '';
  });
  // Dice roll request: [ROLL: description | notation]
  narrative = narrative.replace(/\[ROLL:\s*(.+?)\]/gi, (_,d) => {
    const parts = d.split('|');
    tags.roll = { description: (parts[0]||'').trim(), notation: (parts[1]||'d20').trim() };
    return '';
  });
  // Character tags — strip from narrative (processed separately)
  narrative = narrative.replace(/\[HP:\s*[^\]]+\]/gi, '');
  narrative = narrative.replace(/\[CONDITION:\s*[^\]]+\]/gi, '');
  narrative = narrative.replace(/\[XP:\s*[^\]]+\]/gi, '');
  narrative = narrative.replace(/\[SPELL:\s*[^\]]+\]/gi, '');
  narrative = narrative.replace(/\[LEVEL:\s*[^\]]+\]/gi, '');
  return { narrative: narrative.trim(), tags };
}
function processResponseTags(tags, turn, rawText) {
  // Location update + ambient sound
  if (tags.location) { campaign.location = tags.location; AmbientEngine.onLocationChange(tags.location); }
  // NPCs
  tags.npcs.forEach(n => {
    if (!campaign.npcs.find(x => x.name === n.name)) campaign.npcs.push(n);
  });
  // Quests
  tags.quests.forEach(q => {
    const existing = campaign.quests.find(x => x.name === q.name);
    if (existing) { existing.status = q.status; existing.detail = q.detail; }
    else campaign.quests.push(q);
  });
  // Images — async Gemini with shimmer placeholders
  tags.images.forEach(desc => {
    fireImg(desc, turn);
  });
  // Maps — async Gemini with shimmer placeholders
  tags.maps.forEach(desc => {
    fireMap(desc, turn);
  });
  // Items - add to timeline
  tags.items.forEach(item => {
    campaign.timeline.push({ text: `Inventaire: ${item}`, turn: campaign.turnNumber });
  });
  // Threads — add to sceneState activeThreads
  if (tags.threads?.length && campaign.sceneState) {
    tags.threads.forEach(t => {
      const exists = campaign.sceneState.activeThreads.find(at => at.description === t.description);
      if (!exists) {
        campaign.sceneState.activeThreads.push({
          id: crypto.randomUUID(),
          description: t.description,
          urgency: t.urgency,
          turnsActive: 0
        });
      }
    });
  }
  // Timeline
  if (tags.location) campaign.timeline.push({ text: `Arrive a: ${tags.location}`, turn: campaign.turnNumber });

  // Character tags (HP, conditions, XP, spells)
  if (rawText) {
    const charTags = parseCharacterTags(rawText);
    applyCharacterTags(charTags);
    // Tick condition durations each turn
    tickConditions();
  }

  // Ambient: detect combat or other scenes from narrative
  if (turn?.narrative) AmbientEngine.onNarrative(turn.narrative);
}

/* =============================================================
   SCENE STATE AUTO-UPDATER (fire-and-forget after each turn)
   ============================================================= */
async function updateSceneState(playerAction, dmNarrative) {
  if (!campaign?.sceneState) return;
  try {
    // Increment turnsActive for existing threads
    campaign.sceneState.activeThreads.forEach(t => { t.turnsActive++; });

    const beatsRemaining = campaign.blueprint?.story_beats?.filter(b => !b.completed) || [];
    const prompt = `Analyse ce tour de jeu de role et mets a jour l'etat de la scene.

ACTION JOUEUR: ${playerAction || '(ouverture)'}
REPONSE DM: ${dmNarrative.substring(0, 800)}

ETAT PRECEDENT:
${JSON.stringify(campaign.sceneState, null, 2)}

${beatsRemaining.length ? 'BEATS RESTANTS:\n' + beatsRemaining.map(b => b.id + '. ' + b.title + ': ' + b.description).join('\n') : ''}

Reponds en JSON STRICT (pas de backticks, pas de markdown):
{
  "activeThreads": [{"id":"uuid","description":"...","urgency":"low|medium|high","turnsActive":0}],
  "npcsPresent": ["Nom"],
  "environment": "description courte",
  "mood": "tension|calme|combat|exploration|mystere",
  "beatCompleted": null,
  "nextBeatId": null,
  "pendingConsequences": ["..."]
}

REGLES:
- GARDER les fils anciens non resolus (incrementer turnsActive)
- AJOUTER les nouveaux fils narratifs
- SUPPRIMER les fils resolus
- beatCompleted = id du beat complete ce tour (ou null)
- nextBeatId = id du prochain beat a viser (ou null si inchange)`;

    const raw = await narrateLLM(
      'Tu es un analyseur de scenes de JdR. Reponds UNIQUEMENT en JSON valide, sans backticks.',
      [{ role: 'user', content: prompt }]
    );
    let json = raw.trim();
    if (json.startsWith('```')) json = json.replace(/^```json?\n?/, '').replace(/\n?```$/, '');
    const data = JSON.parse(json);

    // Merge results into sceneState
    if (data.activeThreads) campaign.sceneState.activeThreads = data.activeThreads;
    if (data.npcsPresent) campaign.sceneState.npcsPresent = data.npcsPresent;
    if (data.environment) campaign.sceneState.environment = data.environment;
    if (data.mood) campaign.sceneState.mood = data.mood;
    if (data.pendingConsequences) campaign.sceneState.pendingConsequences = data.pendingConsequences;

    // Mark beat as completed if indicated
    if (data.beatCompleted && campaign.blueprint?.story_beats) {
      const beat = campaign.blueprint.story_beats.find(b => b.id === data.beatCompleted);
      if (beat) beat.completed = true;
    }
    // Update next beat pointer
    if (data.nextBeatId && campaign.blueprint?.story_beats) {
      const next = campaign.blueprint.story_beats.find(b => b.id === data.nextBeatId);
      if (next) campaign.sceneState.nextBeat = next;
    } else if (data.beatCompleted && campaign.blueprint?.story_beats) {
      // Auto-advance to next uncompleted beat
      const nextUncompleted = campaign.blueprint.story_beats.find(b => !b.completed);
      campaign.sceneState.nextBeat = nextUncompleted || null;
    }

    autoSave();
    console.log('[SceneState] Updated:', campaign.sceneState);
  } catch (e) {
    console.warn('[SceneState] Update failed (non-blocking):', e.message);
  }
}

/* =============================================================
   IMAGE & MAP GENERATION (Gemini + Pollinations fallback)
   ============================================================= */
function pollImg(desc, w=768, h=512) {
  const full = `${desc}, detailed digital illustration, dramatic cinematic lighting, epic fantasy art`;
  return `https://image.pollinations.ai/prompt/${encodeURIComponent(full)}?width=${w}&height=${h}&model=flux&nologo=true`;
}
function pollMap(desc) {
  const full = `top-down fantasy RPG map, ${desc}, hand-drawn cartography style, parchment texture, detailed labels`;
  return `https://image.pollinations.ai/prompt/${encodeURIComponent(full)}?width=768&height=768&model=flux&nologo=true`;
}

/* Gemini (NanoBanana) async image generation — high quality, 5-15s */
async function genImg(prompt) {
  try {
    const data = await api('/api/dm/generate-image', 'POST', {
      prompt: `${prompt}, detailed digital illustration, dramatic cinematic lighting, epic fantasy art`
    });
    return data.url;
  } catch(e) {
    console.warn('[genImg] Gemini failed, falling back to Pollinations:', e.message);
    return pollImg(prompt);
  }
}
async function genMap(prompt) {
  try {
    const data = await api('/api/dm/generate-image', 'POST', {
      prompt: `top-down fantasy RPG map, ${prompt}, hand-drawn cartography style, parchment texture, detailed labels`
    });
    return data.url;
  } catch(e) {
    console.warn('[genMap] Gemini failed, falling back to Pollinations:', e.message);
    return pollMap(prompt);
  }
}

/** Fire-and-forget image gen: returns placeholder ID, replaces in DOM when ready */
function fireImg(desc, turn) {
  const pid = 'dimg-' + Date.now() + '-' + Math.random().toString(36).slice(2,6);
  turn.images.push(pid);
  campaign.images.push({ url: pid, desc, turn: campaign.turnNumber });
  genImg(desc).then(url => {
    // Replace placeholder in turn data
    const idx = turn.images.indexOf(pid);
    if (idx !== -1) turn.images[idx] = url;
    const cIdx = campaign.images.findIndex(i => i.url === pid);
    if (cIdx !== -1) campaign.images[cIdx].url = url;
    // Replace shimmer in DOM
    const el = document.getElementById(pid);
    if (el) {
      el.outerHTML = `<img class="inline-img" src="${esc(url)}" onclick="openLB('${esc(url)}')" loading="lazy">`;
    }
    // Update stage panel if visible (shows latest image)
    try { renderStage(); } catch {}
    autoSave();
  });
  return pid;
}
function fireMap(desc, turn) {
  const pid = 'dmap-' + Date.now() + '-' + Math.random().toString(36).slice(2,6);
  turn.maps.push(pid);
  campaign.maps.push({ url: pid, desc, turn: campaign.turnNumber });
  genMap(desc).then(url => {
    const idx = turn.maps.indexOf(pid);
    if (idx !== -1) turn.maps[idx] = url;
    const cIdx = campaign.maps.findIndex(m => m.url === pid);
    if (cIdx !== -1) campaign.maps[cIdx].url = url;
    const el = document.getElementById(pid);
    if (el) {
      el.outerHTML = `<img class="inline-map" src="${esc(url)}" onclick="openLB('${esc(url)}')" loading="lazy">`;
    }
    try { renderStage(); } catch {}
    autoSave();
  });
  return pid;
}

/* =============================================================
   PLAY TURN
   ============================================================= */
let isPlaying = false;
let pendingRoll = null; // {description, notation} — active dice request from DM
async function playTurn(textOverride) {
  if (isPlaying || !campaign || campaign.concluded) return;
  const input = document.getElementById('action-input');
  const action = textOverride || input.value.trim();
  if (!action) return;
  isPlaying = true;
  input.value = '';
  const btn = document.getElementById('btn-play');
  btn.disabled = true;

  // Player is acting — cut any ongoing DM/AI speech
  stopTTS();

  const playerSelect = document.getElementById('player-select');
  const playerName = playerSelect.value || campaign.players[0]?.name || 'Joueur';
  const charName = campaign.players.find(p => p.name === playerName)?.character?.name || playerName;

  // Add player bubble
  appendPlayerMsg(charName, action);
  addTypingIndicator();

  try {
    const system = buildDMPrompt();
    const messages = buildConversationHistory();
    messages.push({ role: 'user', content: `[${charName} (${playerName})]: ${action}` });

    // Stream response — show text progressively
    const turnNum = campaign.turnNumber + 1;
    let streamBubbleId = 'dm-stream-' + turnNum;
    let streamStarted = false;

    const response = await narrateLLMStream(system, messages, (accumulated) => {
      if (!streamStarted) {
        // Replace typing indicator with live DM bubble
        removeTypingIndicator();
        const el = document.getElementById('narrative');
        el.innerHTML += `<div class="msg msg-dm fade-in" id="${streamBubbleId}"><div class="avatar">&#128009;</div><div><div class="turn-label">Tour ${turnNum}</div><div class="bubble" id="${streamBubbleId}-text"></div></div></div>`;
        streamStarted = true;
      }
      const bubbleEl = document.getElementById(streamBubbleId + '-text');
      if (bubbleEl) {
        // Show raw text during streaming (strip tags for display)
        const clean = accumulated.replace(/\[(IMAGE|MAP|NPC|QUEST|LOCATION|ITEM|THREAD|ROLL|HP|CONDITION|XP|SPELL|LEVEL):[^\]]*\]/gi, '').trim();
        bubbleEl.innerHTML = fmtNarrative(clean);
        const narEl = document.getElementById('narrative');
        narEl.scrollTop = narEl.scrollHeight;
      }
    });

    // Stream complete — parse tags and finalize
    if (!streamStarted) removeTypingIndicator();
    const parsed = parseDMResponse(response);
    campaign.turnNumber = turnNum;
    const turn = { player: playerName, action, narrative: parsed.narrative, images: [], maps: [], turn: campaign.turnNumber, ts: Date.now() };
    processResponseTags(parsed.tags, turn, response);

    // Auto-image fallback: if DM didn't include [IMAGE:], generate one from context
    if (!parsed.tags.images.length) {
      const sceneDesc = (campaign.location || 'fantasy scene') + ', ' + parsed.narrative.substring(0, 120).replace(/['"]/g, '');
      fireImg(sceneDesc, turn);
    }

    campaign.turns.push(turn);
    campaign.updatedAt = Date.now();

    // Fire-and-forget scene state update (does NOT block the player)
    updateSceneState(action, parsed.narrative);

    // Replace stream bubble with final rendered version (includes images)
    const streamEl = document.getElementById(streamBubbleId);
    if (streamEl) streamEl.remove();
    appendDMMsg(parsed.narrative, turn);

    updateGameHeader();
    renderLeftPanel();
    renderRightPanel();
    // Wait for DM to finish speaking before AI turns start
    await speakText(parsed.narrative);
    autoSave();

    // Check if adventure is complete (all story beats done)
    const adventureEnded = await checkAdventureConclusion();
    if (adventureEnded) return;

    // === Multi-AI Co-op Turns ===
    if (campaign.aiPlayerCount > 0 && campaign.aiPlayers?.length > 0) {
      const aiColors = ['#0ff','#f0f','#0f0','#ff0'];
      const aiIcons = ['&#129302;','&#128126;','&#128125;','&#9889;'];
      for (let aiIdx = 0; aiIdx < campaign.aiPlayers.length; aiIdx++) {
        const ai = campaign.aiPlayers[aiIdx];
        if (!ai) continue;
        const aiChar = ai.character || {};
        const aiCharName = aiChar.name || ai.name;
        const aiRole = aiChar.class || aiChar.role || 'Aventurier';
        const isSR = campaign.universe === 'shadowrun';
        const personalityDesc = AI_PERSONALITY_LABELS[ai.personality] || '';
        const color = aiColors[aiIdx % aiColors.length];
        const icon = aiIcons[aiIdx % aiIcons.length];
        // Build party context (other chars)
        const partyContext = campaign.players.map(p => p.character?.name || p.name).join(', ');
        const otherAIs = campaign.aiPlayers.filter((_,j) => j !== aiIdx && j < aiIdx).map(a => a.character?.name || a.name).join(', ');

        try {
          // Recall AI character's memories before deciding action
          let memoryBlock = '';
          try {
            const recallRes = await fetch(`/api/dm/recall?character=${encodeURIComponent(aiCharName)}`);
            if (recallRes.ok) {
              const recallData = await recallRes.json();
              if (recallData.contextText && recallData.contextText !== 'Premiere aventure — aucun souvenir.') {
                memoryBlock = `\nSOUVENIRS & RELATIONS:\n${recallData.contextText}\nUtilise tes souvenirs dans ta decision.\n`;
              }
            }
          } catch(memErr) { console.debug('Memory recall failed:', memErr); }

          const aiPrompt = `Tu es ${aiCharName}, un ${aiRole} ${isSR?'runner dans les ombres de Seattle 2080':'dans cette aventure'}.
Personnalite: ${personalityDesc}.
Tu joues en co-op avec: ${partyContext}${otherAIs ? ', ' + otherAIs : ''}.
${memoryBlock}Derniere action du DM: "${parsed.narrative.substring(0,250)}".
${aiIdx > 0 && campaign.aiPlayers[aiIdx-1] ? `Action precedente de ${campaign.aiPlayers[aiIdx-1].character?.name || campaign.aiPlayers[aiIdx-1].name}: deja joue ce tour.` : ''}

Tu as DEUX options:
1. AGIR: Decris ton action en 1-2 phrases (le DM reagira).
2. PARLER au groupe: Prefixe avec [PARTY] pour parler directement aux autres joueurs sans que le DM intervienne. Ex: [PARTY] Hey ${partyContext.split(',')[0]?.trim() || 'chummer'}, je pense qu'on devrait...

Sois ${ai.personality || 'tactique'} et complementaire. Ne repete pas les actions des autres. Reponds en francais.`;

          const aiAction = await narrateLLM(buildDMPrompt(), [{role:'user', content: aiPrompt}]);
          if (aiAction) {
            const narEl = document.getElementById('narrative');
            const partyChat = parsePartyChat(aiAction);

            if (partyChat.isParty) {
              // Party chat — render as direct speech bubble, no DM involvement
              const targetLabel = partyChat.target ? ` → ${esc(partyChat.target)}` : '';
              narEl.innerHTML += `<div class="msg msg-party fade-in"><div class="avatar" style="background:linear-gradient(135deg,${color},${color}88);color:#000;">${icon}</div><div><div class="party-tag">&#128172; GROUPE${targetLabel}</div><div class="turn-label" style="color:${color};">${esc(aiCharName)}</div><div class="bubble">${fmtNarrative(partyChat.message)}</div></div></div>`;
              campaign.turns.push({ player: aiCharName + ' (IA)', action: '[PARTY] ' + partyChat.message, narrative: '', images: [], maps: [], turn: campaign.turnNumber, ts: Date.now(), isPartyChat: true });
            } else {
              // Normal action — DM will react on next turn
              narEl.innerHTML += `<div class="msg msg-ai fade-in"><div class="avatar" style="background:linear-gradient(135deg,${color},${color}88);color:#000;">${icon}</div><div><div class="turn-label" style="color:${color};">${esc(aiCharName)} (IA)</div><div class="bubble" style="border-left:3px solid ${color};">${fmtNarrative(aiAction)}</div></div></div>`;
              campaign.turns.push({ player: aiCharName + ' (IA)', action: aiAction, narrative: '', images: [], maps: [], turn: campaign.turnNumber, ts: Date.now() });
            }
            narEl.scrollTop = narEl.scrollHeight;
            campaign.updatedAt = Date.now();

            // Log memory: KG + episodic for this AI turn
            try {
              const allNames = [...campaign.players.map(p => p.character?.name || p.name), ...campaign.aiPlayers.map(a => a.character?.name || a.name)];
              const npcMatches = (parsed.narrative + ' ' + aiAction).match(/\b[A-Z\u00C0-\u00FF][a-z\u00E0-\u00FF]{2,}/g) || [];
              const skipWords = new Set(['Tour','DM','IA','Joueur','Vous','Elle','Une','Des','Les','Par','Dans','Sur','Avec','Pour','Mais','Run','Matrix','Edge','Combat','Action']);
              const npcs = [...new Set(npcMatches.filter(m => !allNames.some(n => n.toLowerCase() === m.toLowerCase()) && !skipWords.has(m)))].slice(0, 5);

              fetch('/api/dm/log-memory', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                  characterName: aiCharName,
                  sessionId: campaign.id,
                  sessionName: campaign.name,
                  action: (partyChat.isParty ? '[PARTY] ' : '') + aiAction.slice(0, 200),
                  narrative: parsed.narrative.slice(0, 300),
                  eventType: partyChat.isParty ? 'dialogue' : detectTurnType(aiAction, parsed.narrative),
                  npcsInvolved: npcs,
                })
              }).catch(e => console.debug('Memory log failed:', e));
            } catch(memLogErr) { console.debug('Memory log error:', memLogErr); }

            // Speak with AI's assigned voice (queued — waits for DM/previous AI to finish)
            await speakTextWithVoice(partyChat.isParty ? partyChat.message : aiAction, ai.voice);
          }
        } catch(aiErr) { console.warn(`AI ${ai.name} co-op turn failed:`, aiErr); }
      }
      autoSave();
    } else if (campaign.coop) {
      // Legacy single co-op fallback
      try {
        const kChar = campaign.kingstonChar || 'Kingston/Elf/Decker';
        const kParts = kChar.split('/');
        const kName = kParts[0] || 'Kingston';
        const kRole = kParts[2] || 'Decker';
        const isSR = campaign.universe === 'shadowrun';

        // Recall memories for legacy co-op character
        let memoryBlock = '';
        try {
          const recallRes = await fetch(`/api/dm/recall?character=${encodeURIComponent(kName)}`);
          if (recallRes.ok) {
            const recallData = await recallRes.json();
            if (recallData.contextText && recallData.contextText !== 'Premiere aventure — aucun souvenir.') {
              memoryBlock = `\nSOUVENIRS & RELATIONS:\n${recallData.contextText}\n`;
            }
          }
        } catch(memErr) { console.debug('Memory recall failed:', memErr); }

        const aiPrompt = `Tu es ${kName}, un ${kRole} ${isSR?'dans les ombres de Seattle 2080':'dans cette aventure'}. Tu joues en co-op avec ${charName}. ${memoryBlock}Derniere action du DM: "${parsed.narrative.substring(0,200)}". Decide ton action en 1-2 phrases, en francais. Sois tactique et complementaire.`;
        const aiAction = await narrateLLM(buildDMPrompt(), [{role:'user', content: aiPrompt}]);
        if (aiAction) {
          const narEl = document.getElementById('narrative');
          narEl.innerHTML += `<div class="msg msg-ai fade-in"><div class="avatar" style="background:linear-gradient(135deg,#0ff,#08f);color:#000;">&#129302;</div><div><div class="turn-label" style="color:#0ff;">${kName} (IA)</div><div class="bubble" style="border-left:3px solid #0ff;">${fmtNarrative(aiAction)}</div></div></div>`;
          narEl.scrollTop = narEl.scrollHeight;
          campaign.turns.push({ player: kName + ' (IA)', action: aiAction, narrative: '', images: [], maps: [], turn: campaign.turnNumber, ts: Date.now() });
          campaign.updatedAt = Date.now();

          // Log memory for legacy co-op
          fetch('/api/dm/log-memory', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              characterName: kName,
              sessionId: campaign.id,
              sessionName: campaign.name,
              action: aiAction.slice(0, 200),
              narrative: parsed.narrative.slice(0, 300),
              eventType: detectTurnType(aiAction, parsed.narrative),
              npcsInvolved: [],
            })
          }).catch(e => console.debug('Memory log failed:', e));

          autoSave();
        }
      } catch(aiErr) { console.warn('Kingston co-op turn failed:', aiErr); }
    }

    // If DM requested a dice roll, transform bottom bar
    if (parsed.tags.roll) {
      showDiceRequest(parsed.tags.roll);
    }
  } catch(err) {
    removeTypingIndicator();
    toast('Erreur: ' + err.message);
  } finally {
    isPlaying = false;
    if (!campaign.concluded) {
      btn.disabled = false;
      input.disabled = false;
      input.focus();
    }
  }
}
function detectTurnType(action, narrative) {
  const la = (action || '').toLowerCase();
  const ln = (narrative || '').toLowerCase();
  if (la.includes('attaque') || la.includes('combat') || la.includes('tire') || ln.includes('combat') || ln.includes('initiative')) return 'combat';
  if (la.includes('parle') || la.includes('discute') || la.includes('dialogue') || la.includes('negocie')) return 'dialogue';
  if (la.includes('hacke') || la.includes('matrix') || la.includes('pirate')) return 'matrix';
  if (la.includes('enigme') || la.includes('puzzle')) return 'puzzle';
  if (la.includes('repos') || la.includes('dormir')) return 'rest';
  if (la.includes('achete') || la.includes('vend') || la.includes('marchand')) return 'shop';
  return 'exploration';
}

/* =============================================================
   ADVENTURE CONCLUSION — triggered when all story beats are done
   ============================================================= */
async function checkAdventureConclusion() {
  if (!campaign?.blueprint?.story_beats?.length) return false;
  if (campaign.concluded) return true; // already concluded
  const allDone = campaign.blueprint.story_beats.every(b => b.completed);
  if (!allDone) return false;

  // All beats completed — narrate the conclusion!
  campaign.concluded = true;
  const ending = campaign.blueprint.ending || 'L\'aventure se termine.';
  const chars = [...campaign.players.map(p => p.character?.name || p.name), ...(campaign.aiPlayers||[]).map(a => a.character?.name || a.name)].join(', ');

  addTypingIndicator();
  try {
    const conclusionPrompt = `CONCLUSION DE L'AVENTURE. Tous les objectifs sont atteints.
Resolution prevue: ${ending}
Personnages: ${chars}
Lieu actuel: ${campaign.location || '?'}

Narre un EPILOGUE magnifique de 3-4 paragraphes. Decris le denouement, le sort de chaque personnage, et termine sur une note memorable.
Inclus une [IMAGE:] finale epique.
Tu parles en francais.`;

    const conclusion = await narrateLLM(buildDMPrompt(), [{role:'user', content: conclusionPrompt}]);
    removeTypingIndicator();

    const parsed = parseDMResponse(conclusion);
    const turn = { player: 'Epilogue', action: '', narrative: parsed.narrative, images: [], maps: [], turn: campaign.turnNumber + 1, ts: Date.now() };
    processResponseTags(parsed.tags, turn, conclusion);
    campaign.turns.push(turn);
    campaign.turnNumber++;
    campaign.updatedAt = Date.now();

    // Render conclusion in narrative
    const narEl = document.getElementById('narrative');
    narEl.innerHTML += `<div class="conclusion-banner fade-in">
      <h2>&#127942; Aventure Terminee &#127942;</h2>
      <div class="conclusion-text">${fmtNarrative(parsed.narrative)}</div>
      ${(turn.images||[]).filter(u=>!u.startsWith('dimg-')).map(u=>`<img class="inline-img" src="${esc(u)}" onclick="openLB('${esc(u)}')" style="max-width:80%;margin:12px auto;display:block;">`).join('')}
      <div style="margin-top:20px;font-size:13px;color:var(--text-dim);">
        ${campaign.turnNumber} tours &bull; ${chars}
      </div>
      <button class="btn btn-gold btn-restart" onclick="saveAndQuit()" style="margin-top:16px;">&#128190; Sauvegarder &amp; Retour</button>
      <button class="btn btn-ghost" onclick="campaign.concluded=false;renderGame();" style="margin-top:8px;">&#9854; Continuer quand meme</button>
    </div>`;
    narEl.scrollTop = narEl.scrollHeight;

    await speakText(parsed.narrative);
    autoSave();
    // Disable input
    document.getElementById('action-input').disabled = true;
    document.getElementById('btn-play').disabled = true;
    return true;
  } catch(e) {
    removeTypingIndicator();
    console.warn('Conclusion generation failed:', e);
    campaign.concluded = false;
    return false;
  }
}

/* =============================================================
   AI PARTY CHAT — parse [PARTY:target] prefix for direct speech
   ============================================================= */
function parsePartyChat(aiResponse) {
  // Check if AI chose to do party chat: [PARTY:Nicolas] Hé, on devrait...
  const partyMatch = aiResponse.match(/^\[PARTY(?::([^\]]*))?\]\s*([\s\S]+)/i);
  if (partyMatch) {
    return { isParty: true, target: (partyMatch[1] || '').trim(), message: partyMatch[2].trim() };
  }
  return { isParty: false, target: '', message: aiResponse };
}

function buildConversationHistory() {
  // Last 6 turns (reduced from 10 for faster Gemini inference)
  const msgs = [];
  campaign.turns.slice(-6).forEach(t => {
    if (t.action) msgs.push({ role:'user', content: `[${t.player}]: ${t.action}` });
    if (t.narrative) msgs.push({ role:'assistant', content: t.narrative });
  });
  return msgs;
}

/* =============================================================
   NARRATIVE RENDERING
   ============================================================= */
function renderGame() {
  updateGameHeader();
  renderNarrative();
  renderLeftPanel();
  renderRightPanel();
  // Player select
  const sel = document.getElementById('player-select');
  sel.innerHTML = campaign.players.map(p => `<option value="${esc(p.name)}">${esc(p.name)}</option>`).join('');
}
function updateGameHeader() {
  document.getElementById('gh-name').textContent = campaign.name || 'Campagne';
  document.getElementById('gh-location').textContent = '\uD83D\uDCCD ' + (campaign.location || '...');
  document.getElementById('gh-turn').textContent = 'Tour ' + campaign.turnNumber;
}
function renderNarrative() {
  const el = document.getElementById('narrative');
  if (!campaign.turns.length) {
    el.innerHTML = `<div style="text-align:center;padding:80px 20px;color:var(--text-muted);">
      <div style="font-size:56px;margin-bottom:16px;">&#9876;&#65039;</div>
      <p style="font-family:'Cinzel',serif;font-size:20px;color:var(--text-dim);">L'aventure vous attend</p>
      <p style="font-size:14px;margin-top:8px;">Entrez votre premiere action ou utilisez le micro</p>
    </div>`;
    return;
  }
  el.innerHTML = campaign.turns.map(t => {
    let html = '';
    if (t.action) {
      const isAI = t.player && t.player.includes('(IA)');
      if (isAI) {
        // Find AI player index for color
        const aiName = t.player.replace(/\s*\(IA\)\s*$/, '');
        const aiIdx = (campaign.aiPlayers || []).findIndex(a => (a.character?.name || a.name) === aiName);
        const aiColors = ['#0ff','#f0f','#0f0','#ff0'];
        const aiIcons = ['&#129302;','&#128126;','&#128125;','&#9889;'];
        const color = aiColors[Math.max(0, aiIdx) % aiColors.length];
        const icon = aiIcons[Math.max(0, aiIdx) % aiIcons.length];
        if (t.isPartyChat) {
          // Party chat — direct speech, no DM
          const displayText = t.action.replace(/^\[PARTY\]\s*/i, '');
          html += `<div class="msg msg-party"><div class="avatar" style="background:linear-gradient(135deg,${color},${color}88);color:#000;">${icon}</div><div><div class="party-tag">&#128172; GROUPE</div><div class="turn-label" style="color:${color};">${esc(t.player)}</div><div class="bubble">${fmtNarrative(displayText)}</div></div></div>`;
        } else {
          html += `<div class="msg msg-ai"><div class="avatar" style="background:linear-gradient(135deg,${color},${color}88);color:#000;">${icon}</div><div><div class="player-label" style="color:${color};">${esc(t.player)}</div><div class="bubble" style="border-left:3px solid ${color};">${fmtNarrative(t.action)}</div></div></div>`;
        }
      } else {
        html += `<div class="msg msg-player"><div><div class="player-label">${esc(t.player)}</div><div class="bubble">${esc(t.action)}</div></div></div>`;
      }
    }
    if (t.narrative) {
      html += `<div class="msg msg-dm"><div class="avatar">&#128009;</div><div><div class="turn-label">Tour ${t.turn}</div><div class="bubble">${fmtNarrative(t.narrative)}</div>`;
      // Inline images (shimmer placeholders for pending, real img for loaded)
      (t.images||[]).forEach(url => {
        if (url.startsWith('dimg-')) html += `<div class="img-shimmer" id="${url}">Generation en cours...</div>`;
        else html += `<img class="inline-img" src="${esc(url)}" onclick="openLB('${esc(url)}')" loading="lazy">`;
      });
      (t.maps||[]).forEach(url => {
        if (url.startsWith('dmap-')) html += `<div class="img-shimmer map-shimmer" id="${url}">Carte en cours...</div>`;
        else html += `<img class="inline-map" src="${esc(url)}" onclick="openLB('${esc(url)}')" loading="lazy">`;
      });
      html += `</div></div>`;
    }
    return html;
  }).join('');
  // If adventure was concluded, re-show the banner + disable input
  if (campaign.concluded) {
    const chars = [...campaign.players.map(p => p.character?.name || p.name), ...(campaign.aiPlayers||[]).map(a => a.character?.name || a.name)].join(', ');
    el.innerHTML += `<div class="conclusion-banner">
      <h2>&#127942; Aventure Terminee &#127942;</h2>
      <div style="margin-top:12px;font-size:13px;color:var(--text-dim);">${campaign.turnNumber} tours &bull; ${chars}</div>
      <button class="btn btn-gold btn-restart" onclick="saveAndQuit()" style="margin-top:16px;">&#128190; Sauvegarder &amp; Retour</button>
      <button class="btn btn-ghost" onclick="campaign.concluded=false;document.getElementById('action-input').disabled=false;document.getElementById('btn-play').disabled=false;renderGame();" style="margin-top:8px;">&#9854; Continuer quand meme</button>
    </div>`;
    requestAnimationFrame(() => {
      const inp = document.getElementById('action-input'); if (inp) inp.disabled = true;
      const btn = document.getElementById('btn-play'); if (btn) btn.disabled = true;
    });
  }
  requestAnimationFrame(() => el.scrollTop = el.scrollHeight);
}
function appendPlayerMsg(name, text) {
  const el = document.getElementById('narrative');
  el.innerHTML += `<div class="msg msg-player fade-in"><div><div class="player-label">${esc(name)}</div><div class="bubble">${esc(text)}</div></div></div>`;
  el.scrollTop = el.scrollHeight;
}
function appendDMMsg(narrative, turn) {
  const el = document.getElementById('narrative');
  let html = `<div class="msg msg-dm fade-in"><div class="avatar">&#128009;</div><div><div class="turn-label">Tour ${turn.turn}</div><div class="bubble">${fmtNarrative(narrative)}</div>`;
  (turn.images||[]).forEach(url => {
    if (url.startsWith('dimg-')) html += `<div class="img-shimmer" id="${url}">Generation en cours...</div>`;
    else html += `<img class="inline-img" src="${esc(url)}" onclick="openLB('${esc(url)}')" loading="lazy">`;
  });
  (turn.maps||[]).forEach(url => {
    if (url.startsWith('dmap-')) html += `<div class="img-shimmer map-shimmer" id="${url}">Carte en cours...</div>`;
    else html += `<img class="inline-map" src="${esc(url)}" onclick="openLB('${esc(url)}')" loading="lazy">`;
  });
  html += `</div></div>`;
  el.innerHTML += html;
  el.scrollTop = el.scrollHeight;
}
function addTypingIndicator() {
  const el = document.getElementById('narrative');
  el.innerHTML += `<div class="msg msg-dm fade-in" id="typing-ind"><div class="avatar">&#128009;</div><div class="bubble"><div class="typing"><div class="typing-dots"><span></span><span></span><span></span></div> Le Maitre du Donjon reflechit...</div></div></div>`;
  el.scrollTop = el.scrollHeight;
}
function removeTypingIndicator() {
  const t = document.getElementById('typing-ind');
  if (t) t.remove();
}
function fmtNarrative(text) {
  if (!text) return '';
  let h = esc(text);
  h = h.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  h = h.replace(/\*(.+?)\*/g, '<em>$1</em>');
  h = h.replace(/\[([^\]]*d\d+[^\]]*)\]/g, '<span class="dice-hl">[$1]</span>');
  h = h.replace(/\n\n/g, '</p><p>');
  h = h.replace(/\n/g, '<br>');
  return '<p>' + h + '</p>';
}

/* =============================================================
   LEFT PANEL (PARTY + JOURNAL)
   ============================================================= */
function switchLeftTab(tab, btn) {
  document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
  btn.classList.add('active');
  ['party','dice','journal'].forEach(t => {
    const el = document.getElementById('left-' + t);
    if (el) el.style.display = t === tab ? 'block' : 'none';
  });
  if (tab === 'dice') renderDicePanel();
}
// Condition lists for character sheet rendering
const DEBUFF_CONDITIONS = ['poisoned','stunned','frightened','blinded','deafened','paralyzed','petrified','restrained','charmed','exhaustion','prone','incapacitated','unconscious','grappled'];
const BUFF_CONDITIONS = ['inspired','blessed','hasted','invisible','flying','shielded','raging','concentrated','bardic','heroism','sanctuary','aided'];

function renderLeftPanel() {
  // Party
  const partyEl = document.getElementById('left-party');
  partyEl.innerHTML = campaign.players.map(p => {
    const c = p.character || {};
    const s = c.stats || {};
    const mod = (v) => { const m=Math.floor(((v||10)-10)/2); return m>=0?`+${m}`:m; };
    const hpPct = c.hpMax ? Math.max(0,Math.min(100,(c.hp/c.hpMax)*100)) : 100;
    const hpColor = hpPct>60?'var(--green)':hpPct>30?'var(--gold)':'var(--red)';
    // Conditions
    const condHtml = (c.conditions||[]).map(cond => {
      const isBuff = BUFF_CONDITIONS.includes(cond.name);
      return `<span class="condition-badge ${isBuff?'buff':''}">${esc(cond.name)}${cond.duration?` ${cond.duration}t`:''}</span>`;
    }).join(' ');
    // Spell slots
    let spellHtml = '';
    if (c.spellSlots && Object.keys(c.spellSlots).length) {
      spellHtml = '<div style="margin:4px 0;font-size:10px;color:var(--text-dim);">';
      for (const [lvl, sl] of Object.entries(c.spellSlots).sort()) {
        spellHtml += `<div>Niv.${lvl}: `;
        for (let i=0; i<sl.max; i++) spellHtml += `<span class="spell-slot ${i<sl.max-sl.used?'available':'used'}"></span>`;
        spellHtml += '</div>';
      }
      spellHtml += '</div>';
    }
    // XP bar
    const thresholds = [0,300,900,2700,6500,14000,23000,34000,48000,64000,85000,100000,120000,140000,165000,195000,225000,265000,305000,355000];
    const lvl = c.level || 1;
    const xpCur = c.xp || 0;
    const xpMin = thresholds[lvl-1] || 0;
    const xpMax = thresholds[lvl] || thresholds[thresholds.length-1];
    const xpPct = xpMax > xpMin ? Math.min(100, ((xpCur-xpMin)/(xpMax-xpMin))*100) : 0;
    return `<div class="pc-card">
      <div class="pc-name">${esc(c.name || p.name)} ${c.level ? '<span style="font-size:10px;color:var(--purple);font-weight:400;">Niv.'+c.level+'</span>' : ''}</div>
      <div class="pc-concept">${esc(c.race||'')} ${esc(c.class||'')}</div>
      <div style="font-size:11px;color:var(--text-muted);margin-bottom:4px;">${esc(c.background||'')}</div>
      <div class="hp-bar-outer" style="height:6px;background:rgba(255,255,255,0.06);border-radius:3px;margin-bottom:2px;">
        <div style="height:100%;width:${hpPct}%;background:${hpColor};border-radius:3px;transition:width 0.3s;"></div>
      </div>
      <div style="font-size:10px;color:var(--text-dim);margin-bottom:2px;">PV ${c.hp||'?'}/${c.hpMax||'?'} &nbsp; CA ${c.ac||'?'}</div>
      ${condHtml ? `<div style="margin-bottom:4px;display:flex;gap:3px;flex-wrap:wrap;">${condHtml}</div>` : ''}
      ${c.xp !== undefined ? `<div class="xp-bar-outer"><div class="xp-bar-fill" style="width:${xpPct}%"></div></div><div style="font-size:9px;color:var(--text-dim);margin-bottom:4px;">XP ${xpCur}/${xpMax}</div>` : ''}
      ${spellHtml}
      <div class="pc-stats" style="display:grid;grid-template-columns:repeat(3,1fr);gap:2px;font-size:10px;text-align:center;margin-bottom:6px;">
        <span class="pc-tag">FOR ${s.str||'?'}</span><span class="pc-tag">DEX ${s.dex||'?'}</span><span class="pc-tag">CON ${s.con||'?'}</span>
        <span class="pc-tag">INT ${s.int||'?'}</span><span class="pc-tag">SAG ${s.wis||'?'}</span><span class="pc-tag">CHA ${s.cha||'?'}</span>
      </div>
      <details class="pc-detail"><summary>Equipement & Maitrises</summary>
        <div style="font-size:11px;color:var(--text-dim);padding:4px 0;white-space:pre-wrap;">${esc(c.equipment||'')}\n${esc(c.proficiencies||'')}</div>
      </details>
      <details class="pc-detail"><summary>Personnalite</summary>
        <div style="font-size:11px;color:var(--text-dim);padding:4px 0;">
          <div><strong>Traits:</strong> ${esc(c.traits||'')}</div>
          <div><strong>Defaut:</strong> ${esc(c.flaw||'')}</div>
          <div><strong>Lien:</strong> ${esc(c.bond||'')}</div>
          <div><strong>Ideal:</strong> ${esc(c.ideal||'')}</div>
        </div>
      </details>
    </div>`;
  }).join('');

  // AI player cards
  partyEl.innerHTML += (campaign.aiPlayers || []).filter(a => a.character).map((ai, idx) => {
    const c = ai.character;
    const s = c.stats || {};
    const aiColors = ['#0ff','#f0f','#0f0','#ff0'];
    const color = aiColors[idx % aiColors.length];
    const hpPct = c.hpMax ? Math.max(0,Math.min(100,(c.hp/c.hpMax)*100)) : 100;
    const hpColor = hpPct>60?'var(--green)':hpPct>30?'var(--gold)':'var(--red)';
    if (c.isShadowrun) {
      return `<div class="pc-card" style="border-left:2px solid ${color};">
        <div class="pc-name" style="color:${color};">${esc(c.name)} <span style="font-size:9px;opacity:0.6;">(IA)</span></div>
        <div class="pc-concept">${esc(c.race||'')} ${esc(c.class||'')}</div>
        <div class="hp-bar-outer" style="height:6px;background:rgba(255,255,255,0.06);border-radius:3px;margin-bottom:2px;">
          <div style="height:100%;width:${hpPct}%;background:${hpColor};border-radius:3px;"></div>
        </div>
        <div style="font-size:10px;color:var(--text-dim);margin-bottom:4px;">PV ${c.hp||'?'}/${c.hpMax||'?'} &nbsp; Stun ${c.stunMax||'?'}</div>
        <div class="pc-stats" style="display:grid;grid-template-columns:repeat(3,1fr);gap:2px;font-size:10px;text-align:center;">
          <span class="pc-tag" style="color:${color};">BOD ${s.body||'?'}</span><span class="pc-tag" style="color:${color};">AGI ${s.agility||'?'}</span><span class="pc-tag" style="color:${color};">LOG ${s.logic||'?'}</span>
          <span class="pc-tag" style="color:${color};">CHA ${s.charisma||'?'}</span><span class="pc-tag" style="color:${color};">EDGE ${s.edge||'?'}</span><span class="pc-tag" style="color:${color};">ESS ${s.essence||'?'}</span>
        </div>
        <div style="font-size:9px;color:var(--text-muted);margin-top:4px;">${esc(AI_PERSONALITY_LABELS[ai.personality]||'')}</div>
      </div>`;
    }
    const mod = (v) => { const m=Math.floor(((v||10)-10)/2); return m>=0?`+${m}`:m; };
    return `<div class="pc-card" style="border-left:2px solid ${color};">
      <div class="pc-name" style="color:${color};">${esc(c.name)} <span style="font-size:9px;opacity:0.6;">(IA)</span></div>
      <div class="pc-concept">${esc(c.race||'')} ${esc(c.class||'')}</div>
      <div class="hp-bar-outer" style="height:6px;background:rgba(255,255,255,0.06);border-radius:3px;margin-bottom:2px;">
        <div style="height:100%;width:${hpPct}%;background:${hpColor};border-radius:3px;"></div>
      </div>
      <div style="font-size:10px;color:var(--text-dim);margin-bottom:4px;">PV ${c.hp||'?'}/${c.hpMax||'?'} &nbsp; CA ${c.ac||'?'}</div>
      <div class="pc-stats" style="display:grid;grid-template-columns:repeat(3,1fr);gap:2px;font-size:10px;text-align:center;">
        <span class="pc-tag" style="color:${color};">FOR ${s.str||'?'}</span><span class="pc-tag" style="color:${color};">DEX ${s.dex||'?'}</span><span class="pc-tag" style="color:${color};">CON ${s.con||'?'}</span>
        <span class="pc-tag" style="color:${color};">INT ${s.int||'?'}</span><span class="pc-tag" style="color:${color};">SAG ${s.wis||'?'}</span><span class="pc-tag" style="color:${color};">CHA ${s.cha||'?'}</span>
      </div>
      <div style="font-size:9px;color:var(--text-muted);margin-top:4px;">${esc(AI_PERSONALITY_LABELS[ai.personality]||'')}</div>
    </div>`;
  }).join('');

  // Journal
  const journalEl = document.getElementById('left-journal');
  let jhtml = '';
  // Quests
  jhtml += `<div class="journal-section"><h4>&#128220; Quetes</h4>`;
  if (campaign.quests.length) {
    jhtml += campaign.quests.map(q => `<div class="journal-entry"><span class="q-name">${esc(q.name)}</span><span class="q-status ${q.status==='complete'?'q-done':'q-active'}">${esc(q.status||'?')}</span><br><span style="font-size:11px;">${esc(q.detail||'')}</span></div>`).join('');
  } else jhtml += '<div class="journal-entry" style="font-style:italic;">Aucune quete active</div>';
  jhtml += '</div>';
  // NPCs
  jhtml += `<div class="journal-section"><h4>&#128100; PNJ Rencontres</h4>`;
  if (campaign.npcs.length) {
    jhtml += campaign.npcs.map(n => `<div class="npc-entry"><span class="npc-name">${esc(n.name)}</span><span class="npc-desc">${esc(n.description||'')}</span></div>`).join('');
  } else jhtml += '<div class="journal-entry" style="font-style:italic;">Aucun PNJ notable</div>';
  jhtml += '</div>';
  // Timeline
  jhtml += `<div class="journal-section"><h4>&#128337; Chronologie</h4>`;
  if (campaign.timeline.length) {
    jhtml += campaign.timeline.slice(-20).reverse().map(e => `<div class="timeline-entry"><span class="tl-time">T${e.turn}</span> ${esc(e.text)}</div>`).join('');
  } else jhtml += '<div class="journal-entry" style="font-style:italic;">Aucun evenement</div>';
  jhtml += '</div>';
  journalEl.innerHTML = jhtml;
}

/* =============================================================
   RIGHT PANEL (SCENES + MAPS)
   ============================================================= */
/* =============================================================
   STAGE — Central Visual Area
   ============================================================= */
function renderStage() {
  const poster = document.getElementById('stage-poster');
  const thumbs = document.getElementById('stage-thumbs');
  if (!poster || !campaign) return;
  // All visual assets combined (scenes + maps + custom) — filter out pending placeholders
  const allMedia = [
    ...(campaign.images||[]).map(i => ({...i, type:'scene'})),
    ...(campaign.maps||[]).map(m => ({...m, type:'map'})),
    ...(campaign.customImages||[]).map(c => ({...c, type:'custom'}))
  ].filter(m => m.url && !m.url.startsWith('dimg-') && !m.url.startsWith('dmap-'))
   .sort((a,b) => (b.ts||b.turn||0) - (a.ts||a.turn||0));
  // Main image: campaign poster or latest scene
  if (allMedia.length) {
    const latest = allMedia[0];
    poster.innerHTML = `<img src="${esc(latest.url)}" onclick="openLB('${esc(latest.url)}')" loading="lazy">
      <div class="poster-overlay">
        <div class="poster-title">${esc(campaign.name || 'Aventure')}</div>
        <div class="poster-sub">${esc(campaign.location || '')} &middot; Tour ${campaign.turnNumber}</div>
      </div>`;
  } else if (campaign.posterUrl) {
    poster.innerHTML = `<img src="${esc(campaign.posterUrl)}" onclick="openLB('${esc(campaign.posterUrl)}')" loading="lazy">
      <div class="poster-overlay">
        <div class="poster-title">${esc(campaign.name || 'Aventure')}</div>
        <div class="poster-sub">${esc(campaign.arcOutline?.split('\\n')[0] || '')}</div>
      </div>`;
  } else {
    poster.innerHTML = `<div style="text-align:center;padding:40px;">
      <div style="font-size:72px;margin-bottom:16px;">&#9876;&#65039;</div>
      <div style="font-family:'Cinzel',serif;font-size:22px;color:var(--gold);">${esc(campaign.name||'Aventure')}</div>
      <div style="color:var(--text-dim);margin-top:8px;font-style:italic;">L'aventure commence bientot...</div>
    </div>`;
  }
  // Thumbnails
  if (thumbs && allMedia.length > 1) {
    thumbs.innerHTML = allMedia.slice(1, 12).map((m,i) =>
      `<div class="thumb" onclick="showMediaInStage(${i+1})"><img src="${esc(m.url)}" loading="lazy"></div>`
    ).join('');
  } else if (thumbs) {
    thumbs.innerHTML = '';
  }
}
function showMediaInStage(idx) {
  const allMedia = [
    ...(campaign.images||[]).map(i => ({...i, type:'scene'})),
    ...(campaign.maps||[]).map(m => ({...m, type:'map'})),
    ...(campaign.customImages||[]).map(c => ({...c, type:'custom'}))
  ].sort((a,b) => (b.ts||b.turn||0) - (a.ts||a.turn||0));
  if (allMedia[idx]) openLB(allMedia[idx].url);
}
function showImageCreator() {
  const el = document.getElementById('img-creator');
  el.style.display = el.style.display === 'none' ? 'block' : 'none';
}
async function generateCampaignPoster() {
  if (!campaign) return;
  const universe = campaign.universe === 'custom' ? campaign.universeCustom : campaign.universe;
  const chars = campaign.players.map(p => p.character?.concept || p.character?.class || 'adventurer').join(', ');
  const desc = `epic ${campaign.tone} ${universe} adventure movie poster, ${chars}, dramatic composition, cinematic, title card, professional book cover art`;
  campaign.posterUrl = await genImg(desc);
  renderStage();
  autoSave();
}
async function manualGenScene() {
  const desc = campaign.location + ', ' + (campaign.turns[campaign.turns.length-1]?.narrative||'').substring(0,80);
  toast('Generation de la scene...');
  const imgStyle = campaign.universe === 'shadowrun' ? 'cyberpunk shadowrun scene, neon lights, rain, dark' : 'fantasy scene';
  const url = await genImg(`${imgStyle}, ${desc}`);
  campaign.images.push({ url, desc, turn: campaign.turnNumber, ts: Date.now() });
  campaign.updatedAt = Date.now();
  renderStage();
  autoSave();
  toast('Scene generee!');
}
async function manualGenMap() {
  toast('Generation de la carte...');
  const url = await genMap(campaign.location);
  campaign.maps.push({ url, desc: campaign.location, turn: campaign.turnNumber, ts: Date.now() });
  campaign.updatedAt = Date.now();
  renderStage();
  autoSave();
  toast('Carte generee!');
}
async function generateCustomImage() {
  const promptEl = document.getElementById('custom-img-prompt');
  const styleEl = document.getElementById('custom-img-style');
  const desc = (promptEl?.value || '').trim();
  if (!desc) { toast('Entrez une description'); return; }
  const style = styleEl?.value || 'epic fantasy art';
  toast('Generation en cours...');
  const url = await genImg(`${desc}, ${style}, detailed, high quality, dramatic lighting`);
  if (!campaign.customImages) campaign.customImages = [];
  campaign.customImages.push({ url, desc, style, turn: campaign.turnNumber, ts: Date.now() });
  campaign.updatedAt = Date.now();
  autoSave();
  promptEl.value = '';
  document.getElementById('img-creator').style.display = 'none';
  renderStage();
  toast('Image generee!');
}

/* =============================================================
   DICE ROLLER
   ============================================================= */
function renderDicePanel() {
  const el = document.getElementById('left-dice');
  if (!el) return;
  el.innerHTML = `
    <div style="padding:10px;">
      <div style="font-family:'Cinzel',serif;font-size:13px;color:var(--gold);margin-bottom:12px;">Lanceur de Des</div>
      <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-bottom:12px;">
        ${['d4','d6','d8','d10','d12','d20'].map(d =>
          `<button class="dice-btn" onclick="rollDice('${d}',this)">${d}</button>`
        ).join('')}
        <button class="dice-btn" onclick="rollDice('2d6',this)" style="grid-column:span 2;">2d6</button>
      </div>
      <div style="display:flex;gap:6px;margin-bottom:12px;">
        <input class="input" id="custom-dice" placeholder="3d8+5" style="flex:1;font-size:13px;padding:8px;">
        <button class="btn btn-gold btn-small" onclick="rollDice(document.getElementById('custom-dice').value)">&#127922;</button>
      </div>
      <div id="dice-results" style="font-family:'Cinzel',serif;font-size:14px;"></div>
    </div>`;
}
function rollDice(notation, btnEl) {
  if (!notation) return;
  const match = notation.match(/^(\d*)d(\d+)([+-]\d+)?$/i);
  if (!match) { toast('Format invalide (ex: 2d6+3)'); return; }
  // Animate the button if provided
  if (btnEl) { btnEl.classList.add('rolling'); setTimeout(()=>btnEl.classList.remove('rolling'),300); }

  // 3D dice overlay + SFX
  rollDice3D(notation, (result) => {
    const {total, rolls, isCrit, isFumble} = result;
    const count = rolls.length;
    const sides = parseInt(match[2]);
    const mod = parseInt(match[3]||'0');
    const modStr = mod > 0 ? `+${mod}` : mod < 0 ? `${mod}` : '';
    const resultEl = document.getElementById('dice-results');
    if (!resultEl) return;
    const borderColor = isCrit ? 'var(--gold)' : isFumble ? 'var(--red)' : 'var(--border-accent)';
    const numColor = isCrit ? 'var(--gold)' : isFumble ? 'var(--red)' : 'var(--gold-light)';
    const badge = isCrit ? '<div style="font-size:11px;color:var(--gold);margin-top:2px;">CRITIQUE!</div>' : isFumble ? '<div style="font-size:11px;color:var(--red);margin-top:2px;">ECHEC CRITIQUE!</div>' : '';
    resultEl.innerHTML = `
      <div class="dice-result fade-in" style="background:var(--bg-card);border:1px solid ${borderColor};border-radius:8px;padding:12px;margin-bottom:8px;text-align:center;">
        <div style="font-size:28px;color:${numColor};margin-bottom:4px;">${total}</div>
        <div style="font-size:11px;color:var(--text-dim);">${count}d${sides}${modStr} = [${rolls.join(', ')}]${modStr}</div>
        ${badge}
      </div>` + resultEl.innerHTML;
    while (resultEl.children.length > 5) resultEl.removeChild(resultEl.lastChild);
  });
}

/* =============================================================
   DICE REQUEST — DM-initiated rolls via [ROLL:] tag
   ============================================================= */
function showDiceRequest(roll) {
  pendingRoll = roll;
  const bar = document.querySelector('.transcript-input');
  if (!bar) return;
  // Hide normal input rows
  const rows = bar.querySelectorAll('.transcript-input-row, .transcript-voice-row');
  rows.forEach(r => r.style.display = 'none');
  // Add dice request UI
  const div = document.createElement('div');
  div.id = 'dice-request-bar';
  div.className = 'dice-request fade-in';
  div.innerHTML = `
    <div class="dice-request-desc">"${esc(roll.description)}"</div>
    <div class="dice-request-notation">&#127922; ${esc(roll.notation)}</div>
    <div class="dice-request-actions">
      <button class="btn btn-gold" onclick="virtualRollRequest()">&#127922; Lancer ${esc(roll.notation)}</button>
      <div class="dice-manual">
        <input class="input" id="manual-dice" type="number" placeholder="Score" onkeydown="if(event.key==='Enter'){submitManualRoll();}">
        <button class="btn btn-ghost btn-small" onclick="submitManualRoll()">OK</button>
      </div>
    </div>
    <div id="dice-anim-display"></div>`;
  bar.appendChild(div);
}

function virtualRollRequest() {
  if (!pendingRoll) return;
  const notation = pendingRoll.notation;

  // Use 3D dice overlay
  rollDice3D(notation, (result) => {
    submitRollResult(result.total, notation, result.rolls, false);
  });
}

function submitManualRoll() {
  const input = document.getElementById('manual-dice');
  const val = parseInt(input?.value);
  if (isNaN(val)) { toast('Entrez un nombre valide'); return; }
  submitRollResult(val, pendingRoll?.notation || 'd20', [], true);
}

function submitRollResult(total, notation, rolls, isManual) {
  if (!pendingRoll) return;
  const desc = pendingRoll.description;
  const rollInfo = isManual
    ? `(resultat annonce: ${total})`
    : `(${rolls.join(', ')}${notation.match(/[+-]\d+/)?.[0]||''} = ${total})`;
  const resultText = `[Jet: ${desc} (${notation})] Resultat: ${total} ${rollInfo}`;
  hideDiceRequest();
  playTurn(resultText);
}

function hideDiceRequest() {
  pendingRoll = null;
  const diceBar = document.getElementById('dice-request-bar');
  if (diceBar) diceBar.remove();
  const bar = document.querySelector('.transcript-input');
  if (!bar) return;
  const rows = bar.querySelectorAll('.transcript-input-row, .transcript-voice-row');
  rows.forEach(r => r.style.display = '');
}

/* =============================================================
   AMBIENT SOUND ENGINE — Web Audio API procedural audio
   ============================================================= */
const AmbientEngine = (() => {
  let ctx = null;
  let masterGain = null;
  let currentScene = null;
  let activeNodes = [];
  let enabled = false;
  let volume = 0.4;

  function getCtx() {
    if (!ctx) { ctx = new (window.AudioContext || window.webkitAudioContext)(); masterGain = ctx.createGain(); masterGain.gain.value = volume; masterGain.connect(ctx.destination); }
    if (ctx.state === 'suspended') ctx.resume();
    return ctx;
  }

  // Noise generator
  function createNoise(type='white') {
    const c = getCtx();
    const bufSize = c.sampleRate * 2;
    const buf = c.createBuffer(1, bufSize, c.sampleRate);
    const data = buf.getChannelData(0);
    if (type === 'brown') {
      let last = 0;
      for (let i = 0; i < bufSize; i++) { const w = Math.random()*2-1; data[i] = (last + 0.02*w)/1.02; last = data[i]; data[i] *= 3.5; }
    } else if (type === 'pink') {
      let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
      for (let i = 0; i < bufSize; i++) { const w=Math.random()*2-1; b0=0.99886*b0+w*0.0555179; b1=0.99332*b1+w*0.0750759; b2=0.969*b2+w*0.153852; b3=0.8665*b3+w*0.3104856; b4=0.55*b4+w*0.5329522; b5=-0.7616*b5-w*0.016898; data[i]=b0+b1+b2+b3+b4+b5+b6+w*0.5362; data[i]*=0.11; b6=w*0.115926; }
    } else {
      for (let i = 0; i < bufSize; i++) data[i] = Math.random()*2-1;
    }
    const src = c.createBufferSource(); src.buffer = buf; src.loop = true;
    return src;
  }

  function createOsc(freq, type='sine') {
    const c = getCtx();
    const osc = c.createOscillator(); osc.type = type; osc.frequency.value = freq;
    return osc;
  }

  function createLFO(freq, min, max, param) {
    const c = getCtx();
    const lfo = c.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = freq;
    const g = c.createGain(); g.gain.value = (max-min)/2;
    lfo.connect(g); g.connect(param);
    param.value = (min+max)/2;
    lfo.start();
    return lfo;
  }

  function stop() {
    activeNodes.forEach(n => { try { n.stop ? n.stop() : n.disconnect(); } catch {} });
    activeNodes = [];
  }

  // Scene generators — each returns array of nodes to track
  const scenes = {
    tavern() {
      const c = getCtx();
      // Warm crackle (fire)
      const noise = createNoise('brown'); const nGain = c.createGain(); nGain.gain.value = 0.08;
      const nFilter = c.createBiquadFilter(); nFilter.type = 'bandpass'; nFilter.frequency.value = 800; nFilter.Q.value = 0.5;
      noise.connect(nFilter); nFilter.connect(nGain); nGain.connect(masterGain); noise.start();
      // Low warm drone (lute-like)
      const d1 = createOsc(110,'triangle'); const d1g = c.createGain(); d1g.gain.value = 0.04;
      d1.connect(d1g); d1g.connect(masterGain); d1.start();
      const d2 = createOsc(165,'sine'); const d2g = c.createGain(); d2g.gain.value = 0.02;
      d2.connect(d2g); d2g.connect(masterGain); d2.start();
      // Murmur
      const murmur = createNoise('pink'); const mGain = c.createGain(); mGain.gain.value = 0.03;
      const mFilter = c.createBiquadFilter(); mFilter.type = 'bandpass'; mFilter.frequency.value = 400; mFilter.Q.value = 1;
      murmur.connect(mFilter); mFilter.connect(mGain); mGain.connect(masterGain); murmur.start();
      createLFO(0.1, 0.01, 0.05, mGain.gain);
      return [noise,d1,d2,murmur,nGain,nFilter,d1g,d2g,mGain,mFilter];
    },
    forest() {
      const c = getCtx();
      // Wind
      const wind = createNoise('pink'); const wGain = c.createGain(); wGain.gain.value = 0.06;
      const wFilter = c.createBiquadFilter(); wFilter.type = 'lowpass'; wFilter.frequency.value = 600;
      wind.connect(wFilter); wFilter.connect(wGain); wGain.connect(masterGain); wind.start();
      createLFO(0.08, 200, 900, wFilter.frequency);
      // Birds (high pitched oscillators with tremolo)
      const b1 = createOsc(2200,'sine'); const b1g = c.createGain(); b1g.gain.value = 0;
      b1.connect(b1g); b1g.connect(masterGain); b1.start();
      createLFO(3, 0, 0.015, b1g.gain); createLFO(0.15, 1800, 2800, b1.frequency);
      const b2 = createOsc(3100,'sine'); const b2g = c.createGain(); b2g.gain.value = 0;
      b2.connect(b2g); b2g.connect(masterGain); b2.start();
      createLFO(4.5, 0, 0.01, b2g.gain); createLFO(0.2, 2600, 3600, b2.frequency);
      // Leaves rustle
      const rustle = createNoise('white'); const rGain = c.createGain(); rGain.gain.value = 0.01;
      const rFilter = c.createBiquadFilter(); rFilter.type = 'highpass'; rFilter.frequency.value = 3000;
      rustle.connect(rFilter); rFilter.connect(rGain); rGain.connect(masterGain); rustle.start();
      createLFO(0.3, 0.005, 0.02, rGain.gain);
      return [wind,b1,b2,rustle,wGain,wFilter,b1g,b2g,rGain,rFilter];
    },
    dungeon() {
      const c = getCtx();
      // Deep ominous drone
      const d1 = createOsc(55,'sawtooth'); const d1g = c.createGain(); d1g.gain.value = 0.03;
      const d1f = c.createBiquadFilter(); d1f.type = 'lowpass'; d1f.frequency.value = 200;
      d1.connect(d1f); d1f.connect(d1g); d1g.connect(masterGain); d1.start();
      const d2 = createOsc(82.5,'triangle'); const d2g = c.createGain(); d2g.gain.value = 0.02;
      d2.connect(d2g); d2g.connect(masterGain); d2.start();
      createLFO(0.05, 50, 65, d1.frequency);
      // Dripping water
      const drip = createNoise('white'); const dGain = c.createGain(); dGain.gain.value = 0;
      const dFilter = c.createBiquadFilter(); dFilter.type = 'bandpass'; dFilter.frequency.value = 4000; dFilter.Q.value = 20;
      drip.connect(dFilter); dFilter.connect(dGain); dGain.connect(masterGain); drip.start();
      // Random drips via LFO
      createLFO(0.5, 0, 0.04, dGain.gain);
      // Reverb-like echo
      const echo = createNoise('brown'); const eGain = c.createGain(); eGain.gain.value = 0.015;
      const eFilter = c.createBiquadFilter(); eFilter.type = 'lowpass'; eFilter.frequency.value = 300;
      echo.connect(eFilter); eFilter.connect(eGain); eGain.connect(masterGain); echo.start();
      return [d1,d2,drip,echo,d1g,d1f,d2g,dGain,dFilter,eGain,eFilter];
    },
    combat() {
      const c = getCtx();
      // Tension drone
      const d1 = createOsc(73.4,'sawtooth'); const d1g = c.createGain(); d1g.gain.value = 0.04;
      const d1f = c.createBiquadFilter(); d1f.type = 'lowpass'; d1f.frequency.value = 250;
      d1.connect(d1f); d1f.connect(d1g); d1g.connect(masterGain); d1.start();
      // Heartbeat-like pulse
      const pulse = createOsc(55,'sine'); const pGain = c.createGain(); pGain.gain.value = 0;
      pulse.connect(pGain); pGain.connect(masterGain); pulse.start();
      createLFO(1.2, 0, 0.08, pGain.gain);
      // Rhythmic hits
      const hit = createNoise('brown'); const hGain = c.createGain(); hGain.gain.value = 0;
      const hFilter = c.createBiquadFilter(); hFilter.type = 'lowpass'; hFilter.frequency.value = 150;
      hit.connect(hFilter); hFilter.connect(hGain); hGain.connect(masterGain); hit.start();
      createLFO(2.4, 0, 0.06, hGain.gain);
      // High tension string
      const str = createOsc(440,'sawtooth'); const sGain = c.createGain(); sGain.gain.value = 0.01;
      const sFilter = c.createBiquadFilter(); sFilter.type = 'bandpass'; sFilter.frequency.value = 500; sFilter.Q.value = 5;
      str.connect(sFilter); sFilter.connect(sGain); sGain.connect(masterGain); str.start();
      createLFO(0.1, 380, 520, str.frequency);
      return [d1,pulse,hit,str,d1g,d1f,pGain,hGain,hFilter,sGain,sFilter];
    },
    town() {
      const c = getCtx();
      // Crowd murmur
      const crowd = createNoise('pink'); const cGain = c.createGain(); cGain.gain.value = 0.05;
      const cFilter = c.createBiquadFilter(); cFilter.type = 'bandpass'; cFilter.frequency.value = 500; cFilter.Q.value = 0.8;
      crowd.connect(cFilter); cFilter.connect(cGain); cGain.connect(masterGain); crowd.start();
      createLFO(0.12, 0.02, 0.07, cGain.gain);
      // Light cheerful drone
      const d1 = createOsc(220,'triangle'); const d1g = c.createGain(); d1g.gain.value = 0.015;
      d1.connect(d1g); d1g.connect(masterGain); d1.start();
      const d2 = createOsc(330,'sine'); const d2g = c.createGain(); d2g.gain.value = 0.01;
      d2.connect(d2g); d2g.connect(masterGain); d2.start();
      return [crowd,d1,d2,cGain,cFilter,d1g,d2g];
    },
    ocean() {
      const c = getCtx();
      // Waves
      const wave = createNoise('brown'); const wGain = c.createGain(); wGain.gain.value = 0.07;
      const wFilter = c.createBiquadFilter(); wFilter.type = 'lowpass'; wFilter.frequency.value = 400;
      wave.connect(wFilter); wFilter.connect(wGain); wGain.connect(masterGain); wave.start();
      createLFO(0.08, 200, 800, wFilter.frequency);
      createLFO(0.06, 0.03, 0.1, wGain.gain);
      // Wind
      const wind = createNoise('pink'); const wiGain = c.createGain(); wiGain.gain.value = 0.03;
      const wiFilter = c.createBiquadFilter(); wiFilter.type = 'lowpass'; wiFilter.frequency.value = 500;
      wind.connect(wiFilter); wiFilter.connect(wiGain); wiGain.connect(masterGain); wind.start();
      return [wave,wind,wGain,wFilter,wiGain,wiFilter];
    },
    temple() {
      const c = getCtx();
      // Choir-like pad (stacked sines with slow LFO)
      const freqs = [261.6, 329.6, 392, 523.3];
      const nodes = [];
      freqs.forEach(f => {
        const o = createOsc(f,'sine'); const g = c.createGain(); g.gain.value = 0.015;
        o.connect(g); g.connect(masterGain); o.start();
        createLFO(0.04+Math.random()*0.03, 0.005, 0.02, g.gain);
        nodes.push(o, g);
      });
      // Reverb-ish tail
      const rev = createNoise('pink'); const rGain = c.createGain(); rGain.gain.value = 0.015;
      const rFilter = c.createBiquadFilter(); rFilter.type = 'lowpass'; rFilter.frequency.value = 800;
      rev.connect(rFilter); rFilter.connect(rGain); rGain.connect(masterGain); rev.start();
      nodes.push(rev, rGain, rFilter);
      return nodes;
    },
    cave() {
      const c = getCtx();
      // Deep rumble
      const rumble = createNoise('brown'); const rGain = c.createGain(); rGain.gain.value = 0.04;
      const rFilter = c.createBiquadFilter(); rFilter.type = 'lowpass'; rFilter.frequency.value = 120;
      rumble.connect(rFilter); rFilter.connect(rGain); rGain.connect(masterGain); rumble.start();
      createLFO(0.03, 0.02, 0.06, rGain.gain);
      // Drips (high resonant)
      const drip = createNoise('white'); const dGain = c.createGain(); dGain.gain.value = 0;
      const dFilter = c.createBiquadFilter(); dFilter.type = 'bandpass'; dFilter.frequency.value = 3500; dFilter.Q.value = 30;
      drip.connect(dFilter); dFilter.connect(dGain); dGain.connect(masterGain); drip.start();
      createLFO(0.7, 0, 0.03, dGain.gain);
      // Echo drone
      const d = createOsc(65,'triangle'); const dg = c.createGain(); dg.gain.value = 0.025;
      d.connect(dg); dg.connect(masterGain); d.start();
      createLFO(0.02, 55, 75, d.frequency);
      return [rumble,drip,d,rGain,rFilter,dGain,dFilter,dg];
    }
  };

  // Keyword → scene mapping
  const SCENE_MAP = {
    tavern: ['taverne','auberge','bar','inn','tavern','pub','brasserie','estaminet','relais'],
    forest: ['foret','forêt','bois','jungle','clairiere','bosquet','sylvestre','arbre','sentier','woods','forest'],
    dungeon: ['donjon','souterrain','crypte','labyrinthe','tunnel','egout','catacombes','dungeon','ruines','prison','cellule'],
    combat: ['combat','attaque','bataille','fight','initiative','ennemi','monstre','assaut','embuscade','melee','duel'],
    town: ['ville','marche','marché','place','cite','cité','village','hameau','quartier','rue','boutique','town','city','shop'],
    ocean: ['ocean','océan','mer','bateau','navire','port','plage','cote','côte','ile','île','pirate','vague','ship','sea'],
    temple: ['temple','eglise','église','autel','sanctuaire','chapelle','monastere','monastère','cathedrale','cathédrale','divin','sacre','sacré','priere','prière'],
    cave: ['grotte','caverne','cave','mine','gouffre','abime','abîme','souterrain','stalactite','crystal','cristal']
  };

  function detectScene(text) {
    const lower = (text||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    let best = null; let bestScore = 0;
    for (const [scene, keywords] of Object.entries(SCENE_MAP)) {
      const score = keywords.filter(k => lower.includes(k.normalize('NFD').replace(/[\u0300-\u036f]/g, ''))).length;
      if (score > bestScore) { bestScore = score; best = scene; }
    }
    return best;
  }

  function play(sceneName) {
    if (!sceneName || sceneName === currentScene) return;
    if (!scenes[sceneName]) return;
    stop();
    try {
      activeNodes = scenes[sceneName]();
      currentScene = sceneName;
      const label = document.getElementById('amb-label');
      if (label) label.textContent = sceneName.charAt(0).toUpperCase() + sceneName.slice(1);
      const btn = document.getElementById('amb-toggle');
      if (btn) btn.classList.add('active');
    } catch(e) { console.warn('[Ambient] Scene error:', e); }
  }

  function setVolume(v) {
    volume = v;
    if (masterGain) masterGain.gain.value = v;
  }

  function toggle() {
    enabled = !enabled;
    const btn = document.getElementById('amb-toggle');
    if (!enabled) {
      stop(); currentScene = null;
      if (btn) { btn.textContent = '\u{1F507}'; btn.classList.remove('active'); }
      document.getElementById('amb-label').textContent = 'Muet';
    } else {
      if (btn) btn.textContent = '\u{1F509}';
      // Try to detect scene from current location
      if (campaign?.location) {
        const scene = detectScene(campaign.location);
        if (scene) play(scene);
        else play('tavern');
      } else play('tavern');
    }
    return enabled;
  }

  function onLocationChange(location) {
    if (!enabled) return;
    const scene = detectScene(location);
    if (scene) play(scene);
  }

  function onNarrative(text) {
    if (!enabled) return;
    // Check for combat keywords in narrative
    const scene = detectScene(text);
    if (scene === 'combat' && currentScene !== 'combat') play('combat');
  }

  return { play, stop, toggle, setVolume, detectScene, onLocationChange, onNarrative, isEnabled: () => enabled, getScene: () => currentScene };
})();

function ambientToggle() { AmbientEngine.toggle(); }
function ambientSetVolume(v) { AmbientEngine.setVolume(v); }

/* =============================================================
   SFX ENGINE — Synthesized sound effects
   ============================================================= */
const SFX = (() => {
  let ctx = null;
  function getCtx() {
    if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
    if (ctx.state === 'suspended') ctx.resume();
    return ctx;
  }

  function diceRoll() {
    const c = getCtx(); const t = c.currentTime;
    // Rattle noise burst
    const buf = c.createBuffer(1, c.sampleRate*0.4, c.sampleRate);
    const data = buf.getChannelData(0);
    for (let i=0; i<data.length; i++) data[i] = (Math.random()*2-1) * Math.exp(-i/(c.sampleRate*0.08));
    const src = c.createBufferSource(); src.buffer = buf;
    const gain = c.createGain(); gain.gain.setValueAtTime(0.15, t); gain.gain.exponentialRampToValueAtTime(0.001, t+0.4);
    const filter = c.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.value = 2000; filter.Q.value = 0.5;
    src.connect(filter); filter.connect(gain); gain.connect(c.destination); src.start(t);
    // Wooden thud
    const osc = c.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(80, t+0.1);
    const og = c.createGain(); og.gain.setValueAtTime(0.12, t); og.gain.exponentialRampToValueAtTime(0.001, t+0.15);
    osc.connect(og); og.connect(c.destination); osc.start(t); osc.stop(t+0.15);
  }

  function criticalHit() {
    const c = getCtx(); const t = c.currentTime;
    // Rising shimmer
    [1,1.5,2,2.5,3].forEach((mult, i) => {
      const osc = c.createOscillator(); osc.type = 'sine';
      osc.frequency.setValueAtTime(600*mult, t+i*0.05); osc.frequency.exponentialRampToValueAtTime(1200*mult, t+0.3+i*0.05);
      const g = c.createGain(); g.gain.setValueAtTime(0.06, t+i*0.05); g.gain.exponentialRampToValueAtTime(0.001, t+0.8);
      osc.connect(g); g.connect(c.destination); osc.start(t+i*0.05); osc.stop(t+0.8);
    });
    // Impact
    const osc = c.createOscillator(); osc.type='triangle'; osc.frequency.value=100;
    const g = c.createGain(); g.gain.setValueAtTime(0.2, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.3);
    osc.connect(g); g.connect(c.destination); osc.start(t); osc.stop(t+0.3);
  }

  function fumble() {
    const c = getCtx(); const t = c.currentTime;
    // Descending sad tone
    const osc = c.createOscillator(); osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(400, t); osc.frequency.exponentialRampToValueAtTime(80, t+0.6);
    const g = c.createGain(); g.gain.setValueAtTime(0.08, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.7);
    const f = c.createBiquadFilter(); f.type='lowpass'; f.frequency.value=600;
    osc.connect(f); f.connect(g); g.connect(c.destination); osc.start(t); osc.stop(t+0.7);
  }

  function swordHit() {
    const c = getCtx(); const t = c.currentTime;
    const buf = c.createBuffer(1, c.sampleRate*0.15, c.sampleRate);
    const data = buf.getChannelData(0);
    for (let i=0; i<data.length; i++) data[i] = (Math.random()*2-1) * Math.exp(-i/(c.sampleRate*0.02));
    const src = c.createBufferSource(); src.buffer=buf;
    const g = c.createGain(); g.gain.setValueAtTime(0.15, t);
    const f = c.createBiquadFilter(); f.type='highpass'; f.frequency.value=3000;
    src.connect(f); f.connect(g); g.connect(c.destination); src.start(t);
  }

  function magic() {
    const c = getCtx(); const t = c.currentTime;
    [1,1.25,1.5,2].forEach((mult,i) => {
      const osc = c.createOscillator(); osc.type='sine';
      osc.frequency.setValueAtTime(400*mult, t+i*0.08);
      osc.frequency.exponentialRampToValueAtTime(1600*mult, t+0.5+i*0.08);
      const g = c.createGain(); g.gain.setValueAtTime(0.04, t+i*0.08);
      g.gain.exponentialRampToValueAtTime(0.001, t+1.0);
      osc.connect(g); g.connect(c.destination); osc.start(t+i*0.08); osc.stop(t+1.0);
    });
  }

  function levelUp() {
    const c = getCtx(); const t = c.currentTime;
    const notes = [523.3, 659.3, 784, 1047]; // C5 E5 G5 C6
    notes.forEach((f,i) => {
      const osc = c.createOscillator(); osc.type='triangle'; osc.frequency.value=f;
      const g = c.createGain(); g.gain.setValueAtTime(0, t+i*0.15);
      g.gain.linearRampToValueAtTime(0.1, t+i*0.15+0.05);
      g.gain.exponentialRampToValueAtTime(0.001, t+i*0.15+0.6);
      osc.connect(g); g.connect(c.destination); osc.start(t+i*0.15); osc.stop(t+i*0.15+0.6);
    });
  }

  return { diceRoll, criticalHit, fumble, swordHit, magic, levelUp };
})();

/* =============================================================
   3D DICE ROLLER — Visual dice with physics animation
   ============================================================= */
function rollDice3D(notation, callback) {
  const match = notation.match(/^(\d*)d(\d+)([+-]\d+)?$/i);
  if (!match) return null;
  const count = parseInt(match[1]||'1');
  const sides = parseInt(match[2]);
  const mod = parseInt(match[3]||'0');
  const rolls = Array.from({length:count}, ()=> Math.floor(Math.random()*sides)+1);
  const total = rolls.reduce((a,b)=>a+b,0) + mod;
  const isCrit = count===1 && sides===20 && rolls[0]===20;
  const isFumble = count===1 && sides===20 && rolls[0]===1;

  SFX.diceRoll();

  // Create overlay
  const overlay = document.createElement('div');
  overlay.className = 'dice3d-overlay';
  const stage = document.createElement('div');
  stage.className = 'dice3d-stage';
  stage.style.position = 'relative';

  rolls.forEach((val, i) => {
    const die = document.createElement('div');
    die.className = 'dice3d-die';
    die.style.animationDelay = `${i*0.15}s`;
    // 6 faces — show result on front, random on others
    const faces = ['front','back','left','right','top','bottom'];
    faces.forEach(f => {
      const face = document.createElement('div');
      face.className = `face ${f}`;
      face.textContent = f === 'front' ? val : Math.floor(Math.random()*sides)+1;
      die.appendChild(face);
    });
    stage.appendChild(die);
  });

  // Total display
  const modStr = mod > 0 ? `+${mod}` : mod < 0 ? `${mod}` : '';
  const totalEl = document.createElement('div');
  totalEl.className = `dice3d-total ${isCrit?'crit':''} ${isFumble?'fumble':''}`;
  totalEl.textContent = total;
  stage.appendChild(totalEl);

  // Badge
  if (isCrit || isFumble) {
    const badge = document.createElement('div');
    badge.className = `dice3d-badge ${isCrit?'crit':'fumble'}`;
    badge.textContent = isCrit ? 'CRITIQUE!' : 'ECHEC CRITIQUE!';
    stage.appendChild(badge);
    setTimeout(() => { if(isCrit) SFX.criticalHit(); else SFX.fumble(); }, 1200);
  }

  overlay.appendChild(stage);
  document.body.appendChild(overlay);

  // Remove after animation
  setTimeout(() => {
    overlay.style.transition = 'opacity 0.4s';
    overlay.style.opacity = '0';
    setTimeout(() => overlay.remove(), 400);
    if (callback) callback({ total, rolls, isCrit, isFumble, notation: `${count}d${sides}${modStr}` });
  }, 2500);

  return { total, rolls, isCrit, isFumble };
}

/* =============================================================
   CHARACTER SHEET — Live HP, Conditions, Spell Slots, XP
   ============================================================= */
function parseCharacterTags(rawText) {
  const tags = { hp: [], conditions: [], xp: [], spells: [], levels: [] };
  // [HP: Name | -5] or [HP: Name | +3] or [HP: Name -5] (both formats)
  rawText.replace(/\[HP:\s*([^|\]]+?)\s*\|\s*([=+-]\d+)\s*\]/gi, (_, name, delta) => {
    tags.hp.push({ name: name.trim(), delta: delta.trim() });
    return '';
  });
  rawText.replace(/\[HP:\s*([^|\]]+?)\s+([=+-]\d+)\s*\]/gi, (_, name, delta) => {
    if (!tags.hp.find(h => h.name === name.trim())) tags.hp.push({ name: name.trim(), delta: delta.trim() });
    return '';
  });
  // [CONDITION: Name | condition_name | duration_turns] or [CONDITION: Name | -condition_name] (remove)
  rawText.replace(/\[CONDITION:\s*([^|\]]+)\|([^|\]]+)(?:\|(\d+))?\s*\]/gi, (_, name, cond, dur) => {
    tags.conditions.push({ name: name.trim(), condition: cond.trim(), duration: dur ? parseInt(dur) : null });
    return '';
  });
  // [XP: Name | +100] or [XP: Name +100]
  rawText.replace(/\[XP:\s*([^|\]]+?)\s*\|\s*([+-]\d+)\s*\]/gi, (_, name, delta) => {
    tags.xp.push({ name: name.trim(), delta: parseInt(delta) });
    return '';
  });
  rawText.replace(/\[XP:\s*([^|\]]+?)\s+([+-]\d+)\s*\]/gi, (_, name, delta) => {
    if (!tags.xp.find(x => x.name === name.trim())) tags.xp.push({ name: name.trim(), delta: parseInt(delta) });
    return '';
  });
  // [SPELL: Name | level | delta] e.g. [SPELL: Eldrin | 1 | -1]
  rawText.replace(/\[SPELL:\s*([^|\]]+)\|(\d+)\|([+-]?\d+)\s*\]/gi, (_, name, level, delta) => {
    tags.spells.push({ name: name.trim(), level: parseInt(level), delta: parseInt(delta) });
    return '';
  });
  // [LEVEL: Name | level]
  rawText.replace(/\[LEVEL:\s*([^|\]]+)\|(\d+)\s*\]/gi, (_, name, lvl) => {
    tags.levels.push({ name: name.trim(), level: parseInt(lvl) });
    return '';
  });
  return tags;
}

function applyCharacterTags(charTags) {
  if (!campaign?.players) return;
  const findChar = (name) => {
    const lower = name.toLowerCase();
    return campaign.players.find(p => {
      const cName = (p.character?.name||'').toLowerCase();
      const pName = p.name.toLowerCase();
      return cName === lower || pName === lower || cName.includes(lower) || lower.includes(cName);
    })?.character;
  };

  charTags.hp.forEach(({ name, delta }) => {
    const c = findChar(name);
    if (!c) return;
    if (!c.hp) c.hp = c.hpMax || 20;
    if (delta.startsWith('=')) c.hp = parseInt(delta.slice(1));
    else c.hp = Math.max(0, Math.min(c.hpMax || 99, c.hp + parseInt(delta)));
    if (c.hp <= 0 && !c.conditions?.find(x => x.name === 'unconscious')) {
      if (!c.conditions) c.conditions = [];
      c.conditions.push({ name: 'unconscious', duration: null, turn: campaign.turnNumber });
    }
  });

  charTags.conditions.forEach(({ name, condition, duration }) => {
    const c = findChar(name);
    if (!c) return;
    if (!c.conditions) c.conditions = [];
    if (condition.startsWith('-')) {
      // Remove condition
      c.conditions = c.conditions.filter(x => x.name !== condition.slice(1));
    } else {
      const existing = c.conditions.find(x => x.name === condition);
      if (existing) { existing.duration = duration; existing.turn = campaign.turnNumber; }
      else c.conditions.push({ name: condition, duration, turn: campaign.turnNumber });
    }
  });

  charTags.xp.forEach(({ name, delta }) => {
    const c = findChar(name);
    if (!c) return;
    if (!c.xp) c.xp = 0;
    c.xp += delta;
    // XP thresholds (D&D 5e simplified)
    const thresholds = [0,300,900,2700,6500,14000,23000,34000,48000,64000,85000,100000,120000,140000,165000,195000,225000,265000,305000,355000];
    const newLevel = thresholds.findIndex(t => (c.xp||0) < t);
    if (newLevel > 0 && newLevel > (c.level||1)) {
      c.level = newLevel;
      SFX.levelUp();
      toast(`${c.name} passe niveau ${newLevel}!`);
    }
  });

  charTags.spells.forEach(({ name, level, delta }) => {
    const c = findChar(name);
    if (!c) return;
    if (!c.spellSlots) c.spellSlots = {};
    if (!c.spellSlots[level]) c.spellSlots[level] = { max: 2, used: 0 };
    c.spellSlots[level].used = Math.max(0, Math.min(c.spellSlots[level].max, c.spellSlots[level].used - delta));
  });

  charTags.levels.forEach(({ name, level }) => {
    const c = findChar(name);
    if (!c) return;
    c.level = level;
    SFX.levelUp();
    toast(`${c.name} est maintenant niveau ${level}!`);
  });
}

// Tick down condition durations each turn
function tickConditions() {
  if (!campaign?.players) return;
  campaign.players.forEach(p => {
    const c = p.character;
    if (!c?.conditions) return;
    c.conditions = c.conditions.filter(cond => {
      if (cond.duration !== null) {
        cond.duration--;
        if (cond.duration <= 0) return false;
      }
      return true;
    });
  });
}

/* =============================================================
   SAVE & QUIT
   ============================================================= */
function saveAndQuit() {
  autoSave();
  // Generate session log (fire-and-forget)
  if (campaign && campaign.turns?.length > 0) {
    api('/api/dm/session-log', 'POST', campaign).then(r => {
      if (r?.ok) console.log('[DM] Session log saved:', r.file);
    }).catch(e => console.debug('Session log failed:', e));
  }
  toast('Campagne sauvegardee!');
  setTimeout(() => showLanding(), 800);
}

// Backward compat alias
function renderRightPanel() { renderStage(); }

/* =============================================================
   VOICE ENGINE — Toggle Mic STT + Edge TTS
   ============================================================= */
let isListening = false;
let isSpeaking = false;
let micAlwaysOn = true; // Keep mic always active
let recognition = null;
let silenceTimer = null;
const SILENCE_MS = 1200; // auto-send after 1.2s of silence
let ttsCurrentAudio = null;  // Current <audio> element for TTS playback
let lastSentResultCount = 0; // Track processed results to avoid re-sending accumulated text

// STT Setup — continuous with silence detection
const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition;
if (SpeechRec) {
  recognition = new SpeechRec();
  recognition.lang = 'fr-CA';
  recognition.interimResults = true;
  recognition.continuous = true;
  recognition.onresult = (e) => {
    // Ignore all results while TTS is playing (prevents echo feedback loop)
    if (isSpeaking) return;
    // Build transcript only from unprocessed results (prevents re-sending accumulated text)
    let transcript = '';
    for (let i = lastSentResultCount; i < e.results.length; i++) {
      transcript += e.results[i][0].transcript;
    }
    // Determine which input to fill based on active view
    const isStandaloneCC = document.getElementById('view-char-create')?.classList.contains('active');
    const isWizardCC = document.getElementById('view-onboarding')?.classList.contains('active');
    const isCharCreation = isStandaloneCC || isWizardCC;
    const ccInput = isStandaloneCC ? document.getElementById('sa-cc-input') : document.getElementById('cc-input');
    const actionInput = document.getElementById('action-input');
    const target = isCharCreation && ccInput ? ccInput : actionInput;
    if (target) target.value = transcript;
    // Reset silence timer on each result
    clearTimeout(silenceTimer);
    if (e.results[e.results.length - 1].isFinal) {
      silenceTimer = setTimeout(() => {
        const val = (target ? target.value.trim() : '');
        if (!val) return;
        // Mark results as processed, pass text directly to avoid re-read from input
        lastSentResultCount = e.results.length;
        if (target) target.value = '';
        if (isStandaloneCC) ccSendStandalone(val);
        else if (isWizardCC) ccSend(val);
        else playTurn(val);
      }, SILENCE_MS);
    }
  };
  recognition.onstart = () => {
    lastSentResultCount = 0; // Reset on fresh recognition session
    isListening = true;
    updateVoiceUI();
  };
  recognition.onend = () => {
    // Auto-restart if still toggled on
    if (isListening) {
      setTimeout(() => { try { recognition.start(); } catch(e){} }, 300);
    } else {
      updateVoiceUI();
    }
  };
  recognition.onerror = (e) => {
    console.warn('STT error:', e.error);
    if (e.error === 'not-allowed') {
      isListening = false;
      updateVoiceUI();
      toast('Erreur: acces au micro refuse');
    } else if (e.error === 'network') {
      toast('Erreur reseau — verifiez votre connexion');
    } else if (e.error !== 'no-speech' && e.error !== 'aborted') {
      toast('Erreur micro: ' + e.error);
    }
  };
}

async function toggleMic() {
  if (!recognition) { toast('Reconnaissance vocale non supportee (Chrome ou Edge)'); return; }
  // If DM is speaking, interrupt TTS and activate mic
  if (isSpeaking) {
    stopTTS();
    // Activate mic (start fresh recognition session)
    if (!isListening) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach(t => t.stop());
      } catch(err) {
        toast('Erreur: acces au micro refuse.');
        return;
      }
      isListening = true;
      try { recognition.start(); } catch(e) {}
      updateVoiceUI();
    }
    return;
  }
  if (isListening) {
    // Turn OFF
    isListening = false;
    clearTimeout(silenceTimer);
    try { recognition.stop(); } catch(e){}
    updateVoiceUI();
  } else {
    await ensureMicOn();
  }
}

// Auto-start mic — call on any user gesture that enters an interactive view
let micPermissionGranted = false;
async function ensureMicOn() {
  if (!recognition) return;
  if (isListening) return;
  if (!micPermissionGranted) {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      stream.getTracks().forEach(t => t.stop());
      micPermissionGranted = true;
    } catch(err) {
      console.warn('Mic permission denied:', err);
      return;
    }
  }
  isListening = true;
  try { recognition.start(); } catch(e) {}
  updateVoiceUI();
}

function updateVoiceUI() {
  // Update ALL mic buttons (game view + char creation view)
  const btns = [document.getElementById('voice-btn'), document.getElementById('cc-voice-btn'), document.getElementById('sa-cc-voice-btn')];
  const status = document.getElementById('voice-status');
  btns.forEach(btn => {
    if (!btn) return;
    btn.classList.remove('listening','speaking');
    if (isListening) btn.classList.add('listening');
    else if (isSpeaking) btn.classList.add('speaking');
  });
  if (status) {
    if (isSpeaking) status.textContent = 'Le DM parle... (cliquez ou Espace pour couper)';
    else if (isListening) status.textContent = 'Ecoute active — parlez...';
    else status.textContent = 'Micro desactive';
  }
}

// TTS via Edge TTS (server-side, /api/tts, voice: fr-male = RemyMultilingualNeural)
// Mic paused during TTS to prevent echo. User can interrupt via mic button, Space, or V key.
// TTS queue: prevents overlapping voices. Each speaker waits for the previous to finish.
let ttsQueuePromise = Promise.resolve();
function enqueueTTS(fn) {
  ttsQueuePromise = ttsQueuePromise.then(fn).catch(e => console.warn('TTS queue error:', e));
  return ttsQueuePromise;
}
let ttsWasListening = false; // Track mic state before TTS to restore after

/** Internal: play TTS chunks with a given voice. Returns when all chunks are done. */
async function _playTTSChunks(text, voice, pauseMic) {
  const clean = text.replace(/\*\*(.+?)\*\*/g,'$1').replace(/\*(.+?)\*/g,'$1').replace(/\[.*?\]/g,'').trim();
  if (!clean) return;
  if (pauseMic) {
    ttsWasListening = isListening;
    if (recognition && isListening) {
      isListening = false;
      clearTimeout(silenceTimer);
      try { recognition.stop(); } catch(e) {}
    }
  }
  const chunks = splitTTSChunks(clean, 400);
  isSpeaking = true;
  updateVoiceUI();
  for (const chunk of chunks) {
    if (!isSpeaking) break;
    try {
      const resp = await fetch('/api/tts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...(AUTH ? {'X-Auth-Token': AUTH} : {}) },
        body: JSON.stringify({ text: chunk, voice: voice || 'fr-male' })
      });
      if (!resp.ok) { console.warn('TTS error:', resp.status); continue; }
      const buf = await resp.arrayBuffer();
      if (!isSpeaking) break;
      const blob = new Blob([buf], { type: 'audio/mpeg' });
      const url = URL.createObjectURL(blob);
      const audio = new Audio(url);
      ttsCurrentAudio = audio;
      await new Promise((resolve) => {
        audio.onended = resolve;
        audio.onerror = resolve;
        audio.onpause = resolve; // Critical: resolves when stopTTS() pauses, unblocking the queue
        audio.play().catch(resolve);
      });
      URL.revokeObjectURL(url);
      ttsCurrentAudio = null;
    } catch(err) {
      console.warn('TTS playback error:', err);
    }
  }
  isSpeaking = false;
  updateVoiceUI();
  // Always restart mic after TTS if micAlwaysOn or was previously listening
  if (pauseMic && (micAlwaysOn || ttsWasListening) && !isListening && recognition) {
    setTimeout(() => {
      isListening = true;
      try { recognition.start(); } catch(e) {}
      updateVoiceUI();
    }, 300);
  }
}

/** Speak text (DM voice). Queued: waits for any previous TTS to finish. Does NOT cancel ongoing speech. */
async function speakText(text) {
  if (!document.getElementById('tts-toggle')?.checked) return;
  if (!text) return;
  return enqueueTTS(() => _playTTSChunks(text, 'fr-male', true));
}

function stopTTS() {
  isSpeaking = false;
  if (ttsCurrentAudio) { try { ttsCurrentAudio.pause(); ttsCurrentAudio.currentTime = 0; } catch(e){} ttsCurrentAudio = null; }
  updateVoiceUI();
  // Auto-restart mic after TTS interruption
  if (micAlwaysOn && !isListening && recognition && micPermissionGranted) {
    setTimeout(() => {
      isListening = true;
      try { recognition.start(); } catch(e) {}
      updateVoiceUI();
    }, 200);
  }
}

/** Speak text with a specific voice (for AI players). Queued: waits for DM/other AIs to finish first. */
async function speakTextWithVoice(text, voiceKey) {
  if (!text) return;
  if (!document.getElementById('tts-toggle')?.checked) return;
  return enqueueTTS(() => _playTTSChunks(text, voiceKey || 'fr-male', false));
}

function splitTTSChunks(text, maxLen) {
  const sentences = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [text];
  const chunks = [];
  let current = '';
  for (const s of sentences) {
    if ((current + s).length > maxLen && current) { chunks.push(current.trim()); current = ''; }
    current += s;
  }
  if (current.trim()) chunks.push(current.trim());
  return chunks;
}

// Keyboard shortcuts: V toggles mic, Space interrupts TTS (when not in input field)
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
  if (e.repeat) return;
  // V key: toggle mic (or interrupt TTS if speaking)
  if (e.code === 'KeyV') {
    e.preventDefault();
    toggleMic();
  }
  // Space key: interrupt TTS if speaking
  if (e.code === 'Space' && isSpeaking) {
    e.preventDefault();
    toggleMic(); // stops TTS + activates mic
  }
});

/* =============================================================
   SAVE / LOAD / EXPORT / IMPORT
   ============================================================= */
let lastLoggedTurn = 0; // Track when we last saved a session log
function autoSave() {
  if (!campaign) return;
  campaign.updatedAt = Date.now();
  // Save to localStorage (index + individual)
  const campaigns = JSON.parse(localStorage.getItem('dm_campaigns') || '[]');
  const idx = campaigns.findIndex(c => c.id === campaign.id);
  if (idx >= 0) campaigns[idx] = campaign;
  else campaigns.push(campaign);
  localStorage.setItem('dm_campaigns', JSON.stringify(campaigns));
  localStorage.setItem('dm_campaign_' + campaign.id, JSON.stringify(campaign));
  // Save to server as individual file (background)
  api('/api/dm/campaigns', 'POST', campaign).catch(()=>{});
  // Auto-log session every 5 turns (prevents data loss)
  if (campaign.turns?.length > 0 && campaign.turnNumber - lastLoggedTurn >= 5) {
    lastLoggedTurn = campaign.turnNumber;
    api('/api/dm/session-log', 'POST', campaign).catch(()=>{});
  }
}
function saveGame() {
  autoSave();
  toast('Campagne sauvegardee!');
}
function exportGame() {
  if (!campaign) return;
  const blob = new Blob([JSON.stringify(campaign, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `dm-campaign-${campaign.name||'export'}-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
  toast('Campagne exportee!');
}
function doImport() {
  const file = document.getElementById('import-file').files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const data = JSON.parse(e.target.result);
      if (!data.id || !data.players) throw new Error('Format invalide');
      campaign = data;
      // Save
      const campaigns = JSON.parse(localStorage.getItem('dm_campaigns') || '[]');
      const idx = campaigns.findIndex(c => c.id === campaign.id);
      if (idx >= 0) campaigns[idx] = campaign;
      else campaigns.push(campaign);
      localStorage.setItem('dm_campaigns', JSON.stringify(campaigns));
      closeImportModal();
      showGame();
      toast('Campagne importee!');
    } catch(err) { toast('Erreur d\'import: ' + err.message); }
  };
  reader.readAsText(file);
}
function closeSaveModal() { document.getElementById('save-modal').classList.remove('show'); }
function doSave() { saveGame(); closeSaveModal(); }
function closeImportModal() { document.getElementById('import-modal').classList.remove('show'); }

/* =============================================================
   UTILITIES
   ============================================================= */
function esc(s) { if (!s) return ''; const d=document.createElement('div'); d.textContent=String(s); return d.innerHTML; }
function toast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.style.background = msg.includes('Erreur') ? 'var(--red)' : 'var(--green)';
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 3500);
}
function openLB(url) {
  document.getElementById('lb-img').src = url;
  document.getElementById('lightbox').classList.add('show');
}
document.addEventListener('keydown', (e) => { if (e.key === 'Escape') document.getElementById('lightbox').classList.remove('show'); });

/* =============================================================
   INIT
   ============================================================= */
// Pre-load campaigns from localStorage only (server fetch happens on "Continuer")
allCampaigns = JSON.parse(localStorage.getItem('dm_campaigns') || '[]');
document.getElementById('btn-continue').style.display = allCampaigns.length ? 'inline-flex' : 'none';

// Pre-warm TTS WebSocket so first speech has no "computer voice" artifact
if (document.getElementById('tts-toggle')?.checked) {
  fetch('/api/tts/warmup', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({voice:'fr-male'}) }).catch(() => {});
}
// Also warmup when TTS toggle is enabled
document.getElementById('tts-toggle')?.addEventListener('change', (e) => {
  if (e.target.checked) {
    fetch('/api/tts/warmup', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({voice:'fr-male'}) }).catch(() => {});
  }
});
</script>
</body>
</html>