/**
 * Built-in skill: revenue.report ‚Äî Revenue tracking dashboard.
 * Tracks leads, conversions, and revenue generated by Kingston autonomously.
 * The scoreboard: when this shows $1+ autonomous revenue, we've won.
 */
import { registerSkill } from "../loader.js";
import { getDb } from "../../storage/store.js";
import { log } from "../../utils/log.js";

function safeCount(db: any, sql: string, params: any[] = []): number {
  try {
    return (db.prepare(sql).get(...params) as any)?.c ?? 0;
  } catch {
    return 0;
  }
}

function safeSum(db: any, sql: string, params: any[] = []): number {
  try {
    return (db.prepare(sql).get(...params) as any)?.s ?? 0;
  } catch {
    return 0;
  }
}

function safeRows(db: any, sql: string, params: any[] = []): any[] {
  try {
    return db.prepare(sql).all(...params);
  } catch {
    return [];
  }
}

registerSkill({
  name: "revenue.report",
  description:
    "Full revenue report: leads pipeline, follow-ups sent, conversions, revenue generated. This is Kingston's scoreboard for autonomous business generation.",
  adminOnly: true,
  argsSchema: {
    type: "object",
    properties: {
      period: {
        type: "string",
        description: "Report period: 'today', 'week', 'month', 'all' (default: week)",
      },
    },
  },
  async execute(args): Promise<string> {
    const period = (args.period as string) || "week";
    const db = getDb();
    const sections: string[] = [];

    // Date filter
    let dateFilter = "";
    switch (period) {
      case "today":
        dateFilter = "AND created_at > datetime('now', '-1 day')";
        break;
      case "week":
        dateFilter = "AND created_at > datetime('now', '-7 days')";
        break;
      case "month":
        dateFilter = "AND created_at > datetime('now', '-30 days')";
        break;
      default:
        dateFilter = "";
    }

    // 1. Lead Pipeline
    const totalLeads = safeCount(db, `SELECT COUNT(*) as c FROM leads WHERE 1=1 ${dateFilter}`);
    const newLeads = safeCount(db, `SELECT COUNT(*) as c FROM leads WHERE status = 'new' ${dateFilter}`);
    const contactedLeads = safeCount(db, `SELECT COUNT(*) as c FROM leads WHERE status = 'contacted' ${dateFilter}`);
    const qualifiedLeads = safeCount(db, `SELECT COUNT(*) as c FROM leads WHERE status = 'qualified' ${dateFilter}`);
    const convertedLeads = safeCount(db, `SELECT COUNT(*) as c FROM leads WHERE status = 'converted' ${dateFilter}`);
    const coldLeads = safeCount(db, `SELECT COUNT(*) as c FROM leads WHERE status = 'cold' ${dateFilter}`);

    const conversionRate = totalLeads > 0 ? ((convertedLeads / totalLeads) * 100).toFixed(1) : "0";

    sections.push(
      `**Lead Pipeline (${period})**\n` +
        `  Total: ${totalLeads}\n` +
        `  üÜï Nouveaux: ${newLeads}\n` +
        `  üìß Contact√©s: ${contactedLeads}\n` +
        `  ‚≠ê Qualifi√©s: ${qualifiedLeads}\n` +
        `  üí∞ Convertis: ${convertedLeads}\n` +
        `  ‚ùÑÔ∏è Froids: ${coldLeads}\n` +
        `  Taux conversion: ${conversionRate}%`,
    );

    // 2. Follow-up Activity
    const totalFollowups = safeSum(db, `SELECT SUM(followup_count) as s FROM leads WHERE 1=1 ${dateFilter}`);
    const avgFollowups = totalLeads > 0 ? (totalFollowups / totalLeads).toFixed(1) : "0";
    sections.push(
      `**Activit√© Follow-up**\n` +
        `  Relances envoy√©es: ${totalFollowups}\n` +
        `  Moyenne par lead: ${avgFollowups}`,
    );

    // 3. Revenue (from revenue table if it exists)
    const revenue = safeSum(db, `SELECT SUM(amount) as s FROM revenue WHERE 1=1 ${dateFilter.replace("created_at", "date")}`);
    const revenueEntries = safeRows(
      db,
      `SELECT source, SUM(amount) as total FROM revenue WHERE 1=1 ${dateFilter.replace("created_at", "date")} GROUP BY source ORDER BY total DESC LIMIT 5`,
    );

    if (revenue > 0 || revenueEntries.length > 0) {
      const lines = revenueEntries.map((r: any) => `  ${r.source}: $${r.total.toFixed(2)}`);
      sections.push(
        `**Revenue (${period})**\n` +
          `  Total: $${revenue.toFixed(2)}\n` +
          (lines.length > 0 ? lines.join("\n") : "  Aucune source"),
      );
    } else {
      sections.push(
        `**Revenue (${period})**\n` +
          `  Total: $0.00\n` +
          `  üéØ Objectif: Premier dollar autonome`,
      );
    }

    // 4. Response Quality (from quality gate)
    const avgQuality = safeCount(
      db,
      `SELECT CAST(AVG(score) * 10 AS INTEGER) as c FROM response_quality WHERE 1=1 ${dateFilter}`,
    );
    const totalResponses = safeCount(db, `SELECT COUNT(*) as c FROM response_quality WHERE 1=1 ${dateFilter}`);
    const lowQuality = safeCount(db, `SELECT COUNT(*) as c FROM response_quality WHERE score <= 2 ${dateFilter}`);

    if (totalResponses > 0) {
      sections.push(
        `**Qualit√© R√©ponses (${period})**\n` +
          `  Score moyen: ${(avgQuality / 10).toFixed(1)}/5\n` +
          `  Total √©valu√©s: ${totalResponses}\n` +
          `  Faible qualit√© (‚â§2): ${lowQuality}`,
      );
    }

    // 5. Autonomous Actions
    const decisions = safeCount(
      db,
      `SELECT COUNT(*) as c FROM autonomous_decisions WHERE 1=1 ${dateFilter.replace("created_at", "timestamp")}`,
    );
    const goals = safeCount(
      db,
      `SELECT COUNT(*) as c FROM goals WHERE status = 'completed' ${dateFilter}`,
    );
    sections.push(
      `**Autonomie**\n` +
        `  D√©cisions autonomes: ${decisions}\n` +
        `  Goals compl√©t√©s: ${goals}`,
    );

    // Verdict
    let verdict: string;
    if (revenue > 0) {
      verdict = `üéâ REVENUE AUTONOME: $${revenue.toFixed(2)}! L'objectif est atteint!`;
    } else if (convertedLeads > 0) {
      verdict = `üî• ${convertedLeads} lead(s) converti(s) ‚Äî le premier dollar approche!`;
    } else if (qualifiedLeads > 0) {
      verdict = `‚≠ê ${qualifiedLeads} lead(s) qualifi√©(s) ‚Äî on se rapproche!`;
    } else if (totalLeads > 0) {
      verdict = `üìä ${totalLeads} lead(s) dans le pipeline ‚Äî le syst√®me fonctionne.`;
    } else {
      verdict = `üöÄ Pipeline vide ‚Äî pr√™t √† capturer le premier lead.`;
    }

    return `Kingston Revenue Dashboard\n${"‚ïê".repeat(30)}\n\n${verdict}\n\n${sections.join("\n\n")}`;
  },
});

registerSkill({
  name: "revenue.add",
  description:
    "Record a revenue entry. Use when a sale is closed, a payment is received, or any income is generated (even partially) through Kingston's autonomous actions.",
  adminOnly: true,
  argsSchema: {
    type: "object",
    properties: {
      amount: { type: "number", description: "Revenue amount in dollars" },
      source: { type: "string", description: "Revenue source (e.g. 'broker-ai', 'consulting', 'trading')" },
      description: { type: "string", description: "What this revenue is for" },
      lead_email: { type: "string", description: "Associated lead email (optional)" },
    },
    required: ["amount", "source"],
  },
  async execute(args): Promise<string> {
    const amount = Number(args.amount);
    const source = args.source as string;
    const description = (args.description as string) || "";
    const leadEmail = (args.lead_email as string) || "";

    if (amount <= 0) return "Error: Amount must be positive";

    const db = getDb();

    // Ensure revenue table exists
    db.exec(`
      CREATE TABLE IF NOT EXISTS revenue (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        amount REAL NOT NULL,
        source TEXT NOT NULL,
        description TEXT,
        lead_email TEXT,
        date TEXT DEFAULT (datetime('now'))
      );
    `);

    db.prepare(
      "INSERT INTO revenue (amount, source, description, lead_email) VALUES (?, ?, ?, ?)",
    ).run(amount, source, description, leadEmail);

    // Update lead status to converted if applicable
    if (leadEmail) {
      try {
        db.prepare("UPDATE leads SET status = 'converted', updated_at = datetime('now') WHERE email = ?").run(leadEmail);
      } catch {
        // Lead table might not exist yet
      }
    }

    log.info(`[revenue] Recorded $${amount.toFixed(2)} from ${source}: ${description}`);

    // Notify Nicolas
    try {
      const { getBotSendFn } = await import("./telegram.js");
      const send = getBotSendFn();
      const { config } = await import("../../config/env.js");
      if (send && config.adminChatId) {
        await send(
          config.adminChatId,
          `üí∞ Revenue enregistr√©e!\n\n` +
            `Montant: $${amount.toFixed(2)}\n` +
            `Source: ${source}\n` +
            `${description ? `D√©tails: ${description}\n` : ""}` +
            `${leadEmail ? `Lead: ${leadEmail}` : ""}`,
        );
      }
    } catch {
      // Non-critical
    }

    return `Revenue enregistr√©e: $${amount.toFixed(2)} de ${source}. üéâ`;
  },
});
